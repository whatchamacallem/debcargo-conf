# -*- mode: sh -*-
# Common shell utilities.
#
# Envvars:
# DEBCARGO
#     Path to debcargo. Set this to use your custom version, e.g. from git.
set -e

abort() { local x=$1; shift; for i in "$@"; do echo >&2 "$0: abort: $i"; done; exit "$x"; }

GIT_DIR="$(git rev-parse --absolute-git-dir)"

mkdir -p "$GIT_DIR/hooks"
HOOK_COMMIT="$GIT_DIR/hooks/pre-commit"
if [ ! -x "$HOOK_COMMIT" ]; then
cat <<'eof' >"$HOOK_COMMIT"
#!/bin/sh
if git rev-parse -q --verify MERGE_HEAD; then exit; fi
case $(git rev-parse --abbrev-ref HEAD) in
pending-*) true;;
*)	if git diff --cached --name-only | \
	   grep '^src/.*/debian/changelog$' | \
	   while read x; do if ! [ -f "$x" ]; then continue; fi; echo "$x: $(head -n1 $x)"; done | \
	   grep -v UNRELEASED-FIXME-AUTOGENERATED-DEBCARGO; then
		echo >&2 "please don't finalise changelogs directly on the master branch, use ./release.sh instead"; exit 1;
	fi;;
esac
eof
chmod +x "$HOOK_COMMIT"
fi

if [ -n "$DEBCARGO" ]; then
	true
elif type -p debcargo >/dev/null 2>&1; then
	DEBCARGO=$(type -p debcargo)
elif [ -f "$HOME/.cargo/bin/debcargo" ]; then
	DEBCARGO="$HOME/.cargo/bin/debcargo"
else
	abort 1 "debcargo not found, run \`cargo install debcargo\` or set DEBCARGO to point to it"
fi

test -x "$DEBCARGO" || abort 1 "debcargo found but not executable: $DEBCARGO"
dcver=$($DEBCARGO --version | sed -ne 's/debcargo //p')
case $dcver in
2.0.*|2.1.*|2.2.*|2.3.*)	abort 1 "unsupported debcargo version $dcver. try reinstalling with \`cargo install debcargo --force\`";;
2.4.*)	true;;
2.5.*)	true;;
2.6.*)	true;;
2.7.*)	true;;
*)	abort 1 "unsupported debcargo version: $dcver";;
esac

if [ $# -ne 1 -a $# -ne 2 ]; then
	echo >&2 "Usage: $0 <rust-crate-name>"
	echo >&2 "       $0 <rust-crate-name> <old-version>"
	echo >&2 "See README.rst for more details on usage."
	exit 2
fi

CRATE="$1"
VER="$2"

if [ -n "$CRATE" -a -z "$VER" ] && grep -q crate_src_path "src/$CRATE/debian/debcargo.toml" 2>/dev/null; then
	# special hack for crate_src_path, could be cleaner...
	PKGNAME="$CRATE"
	PKGBASE="$CRATE"
else
	PKGNAME=${PKGNAME:-$($DEBCARGO deb-src-name "$CRATE" $VER || abort 1 "couldn't find crate $CRATE")}
	PKGBASE=${PKGBASE:-$($DEBCARGO deb-src-name "$CRATE" || abort 1 "couldn't find crate $CRATE")}
fi

PKGDIR_REL="src/$PKGNAME"
PKGDIR="$PWD/$PKGDIR_REL"
BUILDDIR="$PWD/build/$PKGNAME"
PKGCFG="$PKGDIR/debian/debcargo.toml"
UPLOADER="${DEBFULLNAME:-$NAME} <${DEBEMAIL:-$EMAIL}>"

mkdir -p "$(dirname "$BUILDDIR")"
ln -srf "$PWD/build.sh" "$PWD/build/build.sh"
chmod +x "$PWD/build/build.sh"

if [ -z "$CRATE" ]; then
	abort 2 "Usage: $0 <crate> [<version>]"
fi

run_debcargo() {
	rm -rf "$BUILDDIR" "$(dirname "$BUILDDIR")/rust-${PKGNAME}_${REALVER:-$VER}"*.orig.tar.*
	set +e
	$DEBCARGO package --config "$PKGCFG" --directory "$BUILDDIR" "$@" "$CRATE" "${REALVER:-$VER}"
	if [ $? -ne 0 ]; then
		echo "Command failed. If the patches failed to apply, to rebase them, run":
		echo "./dev/link-patches.sh $PKGNAME"
		echo "cd $BUILDDIR"
		echo "Then for each patch, run"
		echo "QUILT_PATCHES=debian/patches quilt push -f"
		echo "and if needed, edit patched files or the patch and then run"
		echo "quilt refresh"
		echo "Repeat until there are no more patches, and then"
		echo "git-add all of the patches in $PKGDIR"
		exit 1
	fi
	set -e
}

shouldbuild() {
	local dst="$1"
	local src="$2"
	test ! -e "$dst" -o "$src" -nt "$dst"
}

get_existing_version() {
	dpkg-parsechangelog -SVersion -l "$1/debian/changelog" | sed -e "s/-[^-]*$//" -e "s/~/-/"
}
