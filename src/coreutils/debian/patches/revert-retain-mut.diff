commit 500771c78d4b6b62bc7203d1624174cd28bd994b
Author: Ivan <diskonnect@tut.by>
Date:   Sat Mar 27 22:02:49 2021 +0300

    tee: should match GNU's output if used with /dev/full (#1944)
    
    + aligned 'tee' output with GNU tee when one of the files is '/dev/full'
    + don't stop tee when one of the outputs fails; just continue and return
    error status from tee in the end
    
    Co-authored-by: Ivan Rymarchyk <irymarchyk@arlo.com>

diff --git b/src/uu/tee/Cargo.toml a/src/uu/tee/Cargo.toml
index 51bba2e4..99a6ec23 100644
--- b/src/uu/tee/Cargo.toml
+++ a/src/uu/tee/Cargo.toml
@@ -17,7 +17,6 @@ path = "src/tee.rs"
 [dependencies]
 clap = "2.33.3"
 libc = "0.2.42"
-retain_mut = "0.1.2"
 uucore = { version=">=0.0.7", package="uucore", path="../../uucore", features=["libc"] }
 uucore_procs = { version=">=0.0.5", package="uucore_procs", path="../../uucore_procs" }
 
diff --git b/src/uu/tee/src/tee.rs a/src/uu/tee/src/tee.rs
index 7c6a86b4..c54fa0d1 100644
--- b/src/uu/tee/src/tee.rs
+++ a/src/uu/tee/src/tee.rs
@@ -9,7 +9,6 @@
 extern crate uucore;
 
 use clap::{App, Arg};
-use retain_mut::RetainMut;
 use std::fs::OpenOptions;
 use std::io::{copy, sink, stdin, stdout, Error, ErrorKind, Read, Result, Write};
 use std::path::{Path, PathBuf};
@@ -94,32 +93,18 @@ fn tee(options: Options) -> Result<()> {
     if options.ignore_interrupts {
         ignore_interrupts()?
     }
-    let mut writers: Vec<NamedWriter> = options
+    let mut writers: Vec<Box<dyn Write>> = options
         .files
         .clone()
         .into_iter()
-        .map(|file| NamedWriter {
-            name: file.clone(),
-            inner: open(file, options.append),
-        })
+        .map(|file| open(file, options.append))
         .collect();
-
-    writers.insert(
-        0,
-        NamedWriter {
-            name: "'standard output'".to_owned(),
-            inner: Box::new(stdout()),
-        },
-    );
-
-    let mut output = MultiWriter::new(writers);
+    writers.push(Box::new(stdout()));
+    let output = &mut MultiWriter { writers };
     let input = &mut NamedReader {
         inner: Box::new(stdin()) as Box<dyn Read>,
     };
-
-    // TODO: replaced generic 'copy' call to be able to stop copying
-    // if all outputs are closed (due to errors)
-    if copy(input, &mut output).is_err() || output.flush().is_err() || output.error_occured() {
+    if copy(input, output).is_err() || output.flush().is_err() {
         Err(Error::new(ErrorKind::Other, ""))
     } else {
         Ok(())
@@ -127,7 +112,7 @@ fn tee(options: Options) -> Result<()> {
 }
 
 fn open(name: String, append: bool) -> Box<dyn Write> {
-    let path = PathBuf::from(name.clone());
+    let path = PathBuf::from(name);
     let inner: Box<dyn Write> = {
         let mut options = OpenOptions::new();
         let mode = if append {
@@ -140,68 +125,55 @@ fn open(name: String, append: bool) -> Box<dyn Write> {
             Err(_) => Box::new(sink()),
         }
     };
-    Box::new(NamedWriter { inner, name }) as Box<dyn Write>
+    Box::new(NamedWriter { inner, path }) as Box<dyn Write>
 }
 
 struct MultiWriter {
-    writers: Vec<NamedWriter>,
-    initial_len: usize,
-}
-
-impl MultiWriter {
-    fn new(writers: Vec<NamedWriter>) -> Self {
-        Self {
-            initial_len: writers.len(),
-            writers,
-        }
-    }
-    fn error_occured(&self) -> bool {
-        self.writers.len() != self.initial_len
-    }
+    writers: Vec<Box<dyn Write>>,
 }
 
 impl Write for MultiWriter {
     fn write(&mut self, buf: &[u8]) -> Result<usize> {
-        self.writers.retain_mut(|writer| {
-            let result = writer.write_all(buf);
-            match result {
-                Err(f) => {
-                    show_info!("{}: {}", writer.name, f.to_string());
-                    false
-                }
-                _ => true,
-            }
-        });
+        for writer in &mut self.writers {
+            writer.write_all(buf)?;
+        }
         Ok(buf.len())
     }
 
     fn flush(&mut self) -> Result<()> {
-        self.writers.retain_mut(|writer| {
-            let result = writer.flush();
-            match result {
-                Err(f) => {
-                    show_info!("{}: {}", writer.name, f.to_string());
-                    false
-                }
-                _ => true,
-            }
-        });
+        for writer in &mut self.writers {
+            writer.flush()?;
+        }
         Ok(())
     }
 }
 
 struct NamedWriter {
     inner: Box<dyn Write>,
-    pub name: String,
+    path: PathBuf,
 }
 
 impl Write for NamedWriter {
     fn write(&mut self, buf: &[u8]) -> Result<usize> {
-        self.inner.write(buf)
+        match self.inner.write(buf) {
+            Err(f) => {
+                self.inner = Box::new(sink()) as Box<dyn Write>;
+                show_warning!("{}: {}", self.path.display(), f.to_string());
+                Err(f)
+            }
+            okay => okay,
+        }
     }
 
     fn flush(&mut self) -> Result<()> {
-        self.inner.flush()
+        match self.inner.flush() {
+            Err(f) => {
+                self.inner = Box::new(sink()) as Box<dyn Write>;
+                show_warning!("{}: {}", self.path.display(), f.to_string());
+                Err(f)
+            }
+            okay => okay,
+        }
     }
 }
 
@@ -213,7 +185,7 @@ impl Read for NamedReader {
     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
         match self.inner.read(buf) {
             Err(f) => {
-                show_info!("{}: {}", Path::new("stdin").display(), f.to_string());
+                show_warning!("{}: {}", Path::new("stdin").display(), f.to_string());
                 Err(f)
             }
             okay => okay,
