Index: coreutils/src/uu/install/Cargo.toml
===================================================================
--- coreutils.orig/src/uu/install/Cargo.toml
+++ coreutils/src/uu/install/Cargo.toml
@@ -20,7 +20,6 @@ path = "src/install.rs"
 [dependencies]
 clap = "2.33"
 filetime = "0.2"
-file_diff = "1.0.0"
 libc = ">= 0.2"
 uucore = { version=">=0.0.8", package="uucore", path="../../uucore", features=["mode", "perms", "entries"] }
 uucore_procs = { version=">=0.0.5", package="uucore_procs", path="../../uucore_procs" }
Index: coreutils/src/uu/install/src/install.rs
===================================================================
--- coreutils.orig/src/uu/install/src/install.rs
+++ coreutils/src/uu/install/src/install.rs
@@ -13,12 +13,10 @@ mod mode;
 extern crate uucore;
 
 use clap::{App, Arg, ArgMatches};
-use file_diff::diff;
 use filetime::{set_file_times, FileTime};
 use uucore::entries::{grp2gid, usr2uid};
 use uucore::perms::{wrap_chgrp, wrap_chown, Verbosity};
 
-use libc::{getegid, geteuid};
 use std::fs;
 use std::fs::File;
 use std::os::unix::fs::MetadataExt;
@@ -36,7 +34,6 @@ pub struct Behavior {
     group: String,
     verbose: bool,
     preserve_timestamps: bool,
-    compare: bool,
 }
 
 #[derive(Clone, Eq, PartialEq)]
@@ -115,10 +112,11 @@ pub fn uumain(args: impl uucore::Args) -
             .help("ignored")
         )
         .arg(
+            // TODO implement flag
             Arg::with_name(OPT_COMPARE)
             .short("C")
             .long(OPT_COMPARE)
-            .help("compare each pair of source and destination files, and in some cases, do not modify the destination at all")
+            .help("(unimplemented) compare each pair of source and destination files, and in some cases, do not modify the destination at all")
         )
         .arg(
             Arg::with_name(OPT_DIRECTORY)
@@ -264,6 +262,8 @@ fn check_unimplemented<'a>(matches: &Arg
         Err("--backup")
     } else if matches.is_present(OPT_BACKUP_2) {
         Err("-b")
+    } else if matches.is_present(OPT_COMPARE) {
+        Err("--compare, -C")
     } else if matches.is_present(OPT_CREATED) {
         Err("-D")
     } else if matches.is_present(OPT_STRIP) {
@@ -338,7 +338,6 @@ fn behavior(matches: &ArgMatches) -> Res
         group: matches.value_of(OPT_GROUP).unwrap_or("").to_string(),
         verbose: matches.is_present(OPT_VERBOSE),
         preserve_timestamps: matches.is_present(OPT_PRESERVE_TIMESTAMPS),
-        compare: matches.is_present(OPT_COMPARE),
     })
 }
 
@@ -507,13 +506,7 @@ fn copy(from: &PathBuf, to: &PathBuf, b:
             );
             return Err(());
         }
-    }
-
-    if b.compare && !need_copy(from, to, b) {
-        return Ok(());
-    }
-
-    if let Err(err) = fs::copy(from, to) {
+    } else if let Err(err) = fs::copy(from, to) {
         show_error!(
             "cannot install '{}' to '{}': {}",
             from.display(),
@@ -596,81 +589,3 @@ fn copy(from: &PathBuf, to: &PathBuf, b:
 
     Ok(())
 }
-
-/// Return true if a file is necessary to copy. This is the case when:
-/// - _from_ or _to_ is nonexistent;
-/// - either file has a sticky bit or set[ug]id bit, or the user specified one;
-/// - either file isn't a regular file;
-/// - the sizes of _from_ and _to_ differ;
-/// - _to_'s owner differs from intended; or
-/// - the contents of _from_ and _to_ differ.
-///
-/// # Parameters
-///
-/// _from_ and _to_, if existent, must be non-directories.
-///
-/// # Errors
-///
-/// Crashes the program if a nonexistent owner or group is specified in _b_.
-///
-fn need_copy(from: &PathBuf, to: &PathBuf, b: &Behavior) -> bool {
-    let from_meta = match fs::metadata(from) {
-        Ok(meta) => meta,
-        Err(_) => return true,
-    };
-    let to_meta = match fs::metadata(to) {
-        Ok(meta) => meta,
-        Err(_) => return true,
-    };
-
-    // setuid || setgid || sticky
-    let extra_mode: u32 = 0o7000;
-
-    if b.specified_mode.unwrap_or(0) & extra_mode != 0
-        || from_meta.mode() & extra_mode != 0
-        || to_meta.mode() & extra_mode != 0
-    {
-        return true;
-    }
-
-    if !from_meta.is_file() || !to_meta.is_file() {
-        return true;
-    }
-
-    if from_meta.len() != to_meta.len() {
-        return true;
-    }
-
-    // TODO: if -P (#1809) and from/to contexts mismatch, return true.
-
-    if !b.owner.is_empty() {
-        let owner_id = match usr2uid(&b.owner) {
-            Ok(id) => id,
-            _ => crash!(1, "no such user: {}", b.owner),
-        };
-        if owner_id != to_meta.uid() {
-            return true;
-        }
-    } else if !b.group.is_empty() {
-        let group_id = match grp2gid(&b.group) {
-            Ok(id) => id,
-            _ => crash!(1, "no such group: {}", b.group),
-        };
-        if group_id != to_meta.gid() {
-            return true;
-        }
-    } else {
-        #[cfg(not(target_os = "windows"))]
-        unsafe {
-            if to_meta.uid() != geteuid() || to_meta.gid() != getegid() {
-                return true;
-            }
-        }
-    }
-
-    if !diff(from.to_str().unwrap(), to.to_str().unwrap()) {
-        return true;
-    }
-
-    false
-}
Index: coreutils/tests/by-util/test_install.rs
===================================================================
--- coreutils.orig/tests/by-util/test_install.rs
+++ coreutils/tests/by-util/test_install.rs
@@ -1,5 +1,4 @@
 use crate::common::util::*;
-use filetime::FileTime;
 use rust_users::*;
 use std::os::unix::fs::PermissionsExt;
 #[cfg(target_os = "linux")]
@@ -481,6 +480,7 @@ fn test_install_failing_no_such_file() {
 }
 
 #[test]
+#[ignore]
 fn test_install_copy_then_compare_file() {
     let scene = TestScenario::new(util_name!());
     let at = &scene.fixtures;
@@ -515,6 +515,7 @@ fn test_install_copy_then_compare_file()
 
 #[test]
 #[cfg(target_os = "linux")]
+#[ignore]
 fn test_install_copy_then_compare_file_with_extra_mode() {
     let scene = TestScenario::new(util_name!());
     let at = &scene.fixtures;
