Index: ring/src/aead/aes.rs
===================================================================
--- ring.orig/src/aead/aes.rs
+++ ring/src/aead/aes.rs
@@ -205,6 +205,7 @@ fn encrypt_iv_xor_block_using_ctr32(key:
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::testutil as test;
Index: ring/src/aead/poly1305.rs
===================================================================
--- ring.orig/src/aead/poly1305.rs
+++ ring/src/aead/poly1305.rs
@@ -90,6 +90,7 @@ pub(super) fn sign(key: Key, input: &[u8
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::testutil as test;
Index: ring/src/ec/suite_b/ecdsa/digest_scalar.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/digest_scalar.rs
+++ ring/src/ec/suite_b/ecdsa/digest_scalar.rs
@@ -66,6 +66,7 @@ fn digest_scalar_(n: &Modulus<N>, digest
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::digest_bytes_scalar;
     use crate::testutil as test;
Index: ring/src/ec/suite_b/ecdsa/signing.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/signing.rs
+++ ring/src/ec/suite_b/ecdsa/signing.rs
@@ -525,6 +525,7 @@ static EC_PUBLIC_KEY_P384_PKCS8_V1_TEMPL
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::testutil as test;
     use crate::{rand, signature};
Index: ring/src/ec/suite_b/ecdsa/verification.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/verification.rs
+++ ring/src/ec/suite_b/ecdsa/verification.rs
@@ -274,6 +274,7 @@ pub static ECDSA_P384_SHA384_ASN1: Ecdsa
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     extern crate alloc;
     use super::*;
Index: ring/src/ec/suite_b/ops.rs
===================================================================
--- ring.orig/src/ec/suite_b/ops.rs
+++ ring/src/ec/suite_b/ops.rs
@@ -665,6 +665,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_add_test() {
         elem_add_test(
             &p384::PUBLIC_SCALAR_OPS,
@@ -672,6 +673,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_add_test(ops: &PublicScalarOps, test_file: test::File) {
         let cops = ops.public_key_ops.common;
         let q = &cops.elem_modulus(cpu::features());
@@ -698,6 +700,7 @@ mod tests {
     // the point arithmetic functions. Thus, we can't test it.
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_sub_test() {
         prefixed_extern! {
             fn p384_elem_sub(r: *mut Limb, a: *const Limb, b: *const Limb);
@@ -709,6 +712,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_sub_test(
         ops: &'static CommonOps,
         elem_sub: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, b: *const Limb),
@@ -750,6 +754,7 @@ mod tests {
     // into the point arithmetic functions. Thus, we can't test it.
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_div_by_2_test() {
         prefixed_extern! {
             fn p384_elem_div_by_2(r: *mut Limb, a: *const Limb);
@@ -761,6 +766,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_div_by_2_test(
         ops: &'static CommonOps,
         elem_div_by_2: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -786,6 +792,7 @@ mod tests {
     // There is no `ecp_nistz256_neg` on other targets.
     /* #[cfg(target_arch = "x86_64")]
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_neg_test() {
         prefixed_extern! {
             fn ecp_nistz256_neg(r: *mut Limb, a: *const Limb);
@@ -798,6 +805,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_neg_test() {
         prefixed_extern! {
             fn p384_elem_neg(r: *mut Limb, a: *const Limb);
@@ -809,6 +817,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_neg_test(
         ops: &'static CommonOps,
         elem_neg: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -844,6 +853,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_mul_test() {
         elem_mul_test(
             &p256::COMMON_OPS,
@@ -852,11 +862,13 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_mul_test() {
         elem_mul_test(
             &p384::COMMON_OPS,
             test_vector_file!("ops/p384_elem_mul_tests.txt"),
         );
+    #[cfg(feature = "alloc")]
     }*/
 
     fn elem_mul_test(ops: &'static CommonOps, test_file: test::File) {
@@ -875,6 +887,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_mul_test() {
         scalar_mul_test(
             &p256::SCALAR_OPS,
@@ -883,6 +896,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_scalar_mul_test() {
         scalar_mul_test(
             &p384::SCALAR_OPS,
@@ -890,6 +904,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn scalar_mul_test(ops: &ScalarOps, test_file: test::File) {
         let cpu = cpu::features();
         let cops = ops.common;
@@ -907,6 +922,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_square_test() {
         prefixed_extern! {
             fn p256_scalar_sqr_rep_mont(r: *mut Limb, a: *const Limb, rep: LeakyWord);
@@ -921,6 +937,7 @@ mod tests {
     // XXX: There's no `p384_scalar_square_test()` because there's no dedicated
     // `p384_scalar_sqr_rep_mont()`.
 
+    #[cfg(feature = "alloc")]
     fn scalar_square_test(
         ops: &ScalarOps,
         sqr_rep: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, rep: LeakyWord),
@@ -969,6 +986,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_sum_test() {
         point_sum_test(
             &p256::PRIVATE_KEY_OPS,
@@ -977,6 +995,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_sum_test() {
         point_sum_test(
             &p384::PRIVATE_KEY_OPS,
@@ -984,6 +1003,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_sum_test(ops: &PrivateKeyOps, test_file: test::File) {
         let cpu = cpu::features();
 
@@ -1019,6 +1039,7 @@ mod tests {
 
     // XXX: There is no `nistz384_point_add_affine()`.
 
+    #[cfg(feature = "alloc")]
     fn point_sum_mixed_test(
         ops: &PrivateKeyOps,
         point_add_affine: unsafe extern "C" fn(
@@ -1047,6 +1068,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_double_test() {
         prefixed_extern! {
             fn p256_point_double(
@@ -1062,6 +1084,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_double_test() {
         prefixed_extern! {
             fn p384_point_double(
@@ -1076,6 +1099,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_double_test(
         ops: &PrivateKeyOps,
         point_double: unsafe extern "C" fn(
@@ -1103,6 +1127,7 @@ mod tests {
 
     /// TODO: We should be testing `point_mul` with points other than the generator.
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_test() {
         let generator = (
             Elem::from(&p256::GENERATOR.0),
@@ -1117,6 +1142,7 @@ mod tests {
 
     /* /// TODO: We should be testing `point_mul` with points other than the generator.
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_test() {
         let generator = (
             Elem::from(&p384::GENERATOR.0),
@@ -1124,6 +1150,7 @@ mod tests {
         );
 
         point_mul_base_tests(
+    #[cfg(feature = "alloc")]
             &p384::PRIVATE_KEY_OPS,
             |s, cpu| p384::PRIVATE_KEY_OPS.point_mul(s, &generator, cpu),
             test_vector_file!("ops/p384_point_mul_base_tests.txt"),
@@ -1138,7 +1165,9 @@ mod tests {
             test_vector_file!("ops/p256_point_mul_serialized_tests.txt"),
         );
     }*/
+    #[cfg(feature = "alloc")]
 
+    #[cfg(feature = "alloc")]
     fn point_mul_serialized_test(
         priv_ops: &PrivateKeyOps,
         pub_ops: &PublicKeyOps,
@@ -1149,6 +1178,7 @@ mod tests {
         let q = &cops.elem_modulus(cpu);
         let n = &cops.scalar_modulus(cpu);
         test::run(test_file, |section, test_case| {
+    #[cfg(feature = "alloc")]
             assert_eq!(section, "");
             let p_scalar = consume_scalar(n, test_case, "p_scalar");
 
@@ -1184,6 +1214,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_base_test() {
         point_mul_base_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -1193,6 +1224,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_base_test() {
         point_mul_base_tests(
             &p384::PRIVATE_KEY_OPS,
@@ -1201,6 +1233,7 @@ mod tests {
         );
     }*/
 
+    #[cfg(feature = "alloc")]
     pub(super) fn point_mul_base_tests(
         ops: &PrivateKeyOps,
         f: impl Fn(&Scalar, cpu::Features) -> Point,
@@ -1255,6 +1288,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_jacobian_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1275,6 +1309,7 @@ mod tests {
         xy: [Limb; 2 * elem::NumLimbs::MAX],
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_affine_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1289,6 +1324,7 @@ mod tests {
         };
         consume_point_elem(q, &mut p.xy, &elems, 0);
         consume_point_elem(q, &mut p.xy, &elems, 1);
+    #[cfg(feature = "alloc")]
         p
     }
 
@@ -1306,6 +1342,7 @@ mod tests {
         Affine(Elem<E>, Elem<E>),
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point<E: Encoding>(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1384,6 +1421,7 @@ mod tests {
         scalar_parse_big_endian_variable(n, AllowZero::Yes, bytes).unwrap()
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar_mont(
         n: &Modulus<N>,
         test_case: &mut test::TestCase,
@@ -1394,6 +1432,7 @@ mod tests {
         let s = scalar_parse_big_endian_variable(n, AllowZero::Yes, bytes).unwrap();
         // “Transmute” it to a `Scalar<R>`.
         Scalar {
+    #[cfg(feature = "alloc")]
             limbs: s.limbs,
             m: PhantomData,
             encoding: PhantomData,
Index: ring/src/ec/suite_b/public_key.rs
===================================================================
--- ring.orig/src/ec/suite_b/public_key.rs
+++ ring/src/ec/suite_b/public_key.rs
@@ -72,6 +72,7 @@ mod tests {
     use crate::testutil as test;
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn parse_uncompressed_point_test() {
         let cpu = cpu::features();
         test::run(
Index: ring/tests/aead_tests.rs
===================================================================
--- ring.orig/tests/aead_tests.rs
+++ ring/tests/aead_tests.rs
@@ -23,12 +23,16 @@ wasm_bindgen_test_configure!(run_in_brow
 use core::ops::RangeFrom;
 use ring::{aead, error};
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 /// Generate the known answer test functions for the given algorithm and test
 /// case input file, where each test is implemented by a test in `$test`.
 ///
 /// All of these tests can be run in parallel.
+#[cfg(feature = "alloc")]
 macro_rules! test_known_answer {
     ( $alg:ident, $test_file:expr, [ $( $test:ident ),+, ] ) => {
         $(
@@ -46,6 +50,7 @@ macro_rules! test_known_answer {
 /// Generate the tests for a given algorithm.
 ///
 /// All of these tests can be run in parallel.
+#[cfg(feature = "alloc")]
 macro_rules! test_aead {
     { $( { $alg:ident, $test_file:expr } ),+, } => {
         mod aead_test { // Make `cargo test aead` include these files.
@@ -82,7 +87,8 @@ macro_rules! test_aead {
     }
 }
 
-/*test_aead! {
+/*#[cfg(feature = "alloc")]
+test_aead! {
     { AES_128_GCM, "aead_aes_128_gcm_tests.txt" },
     { AES_256_GCM, "aead_aes_256_gcm_tests.txt" },
     { CHACHA20_POLY1305, "aead_chacha20_poly1305_tests.txt" },
@@ -447,6 +453,7 @@ fn test_aead_nonce_sizes() {
 
 /* #[allow(clippy::range_plus_one)]
 #[test]
+#[cfg(feature = "alloc")]
 fn aead_chacha20_poly1305_openssh() {
     // TODO: test_aead_key_sizes(...);
 
Index: ring/tests/agreement_tests.rs
===================================================================
--- ring.orig/tests/agreement_tests.rs
+++ ring/tests/agreement_tests.rs
@@ -24,7 +24,10 @@ extern crate alloc;
 
 use ring::{agreement, error, rand};
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[test]
 fn agreement_traits() {
@@ -73,6 +76,7 @@ fn agreement_traits() {
 }
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn agreement_agree_ephemeral() {
     let rng = rand::SystemRandom::new();
 
@@ -131,6 +135,7 @@ fn agreement_agree_ephemeral() {
 } */
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_agreement_ecdh_x25519_rfc_iterated() {
     let mut k = h("0900000000000000000000000000000000000000000000000000000000000000");
     let mut u = k.clone();
@@ -196,6 +201,7 @@ fn x25519_(private_key: &[u8], public_ke
     })
 }
 
+#[cfg(feature = "alloc")]
 fn h(s: &str) -> Vec<u8> {
     match test::from_hex(s) {
         Ok(v) => v,
Index: ring/tests/digest_tests.rs
===================================================================
--- ring.orig/tests/digest_tests.rs
+++ ring/tests/digest_tests.rs
@@ -16,7 +16,10 @@
 
 use ring::digest;
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -26,6 +29,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /// Test vectors from BoringSSL, Go, and other sources.
 /* #[test]
+#[cfg(feature = "alloc")]
 fn digest_misc() {
     test::run(test_file!("digest_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
Index: ring/tests/ecdsa_tests.rs
===================================================================
--- ring.orig/tests/ecdsa_tests.rs
+++ ring/tests/ecdsa_tests.rs
@@ -19,11 +19,15 @@ use ring::{
     signature::{self, KeyPair},
 };
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+ 
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 // ECDSA *signing* tests are in src/ec/ecdsa/signing.rs.
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn ecdsa_from_pkcs8_test() {
     let rng = rand::SystemRandom::new();
 
@@ -114,6 +118,7 @@ fn ecdsa_generate_pkcs8_test() {
 }
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_asn1_test() {
     test::run(
         test_file!("ecdsa_verify_asn1_tests.txt"),
@@ -147,6 +152,7 @@ fn signature_ecdsa_verify_asn1_test() {
 } 
 
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_fixed_test() {
     test::run(
         test_file!("ecdsa_verify_fixed_tests.txt"),
@@ -218,6 +224,7 @@ fn ecdsa_test_public_key_coverage() {
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 /* #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_fixed_sign_and_verify_test() {
     let rng = rand::SystemRandom::new();
 
@@ -272,6 +279,7 @@ fn signature_ecdsa_sign_fixed_sign_and_v
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_asn1_test() {
     let rng = rand::SystemRandom::new();
 
Index: ring/tests/ed25519_tests.rs
===================================================================
--- ring.orig/tests/ed25519_tests.rs
+++ ring/tests/ed25519_tests.rs
@@ -19,7 +19,10 @@ use ring::{
     signature::{self, Ed25519KeyPair, KeyPair},
 };
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+ 
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -29,6 +32,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /* /// Test vectors from BoringSSL.
 #[test]
+#[cfg(feature = "alloc")]
 fn test_signature_ed25519() {
     test::run(test_file!("ed25519_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -93,6 +97,7 @@ fn test_signature_ed25519_verify() {
     );
 }*/
 
+#[cfg(feature = "alloc")]
 fn test_signature_verification(
     public_key: &[u8],
     msg: &[u8],
@@ -136,6 +141,7 @@ fn test_ed25519_from_pkcs8_unchecked() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_ed25519_from_pkcs8() {
     test_ed25519_from_pkcs8_(FromPkcs8Variant::Checked, Ed25519KeyPair::from_pkcs8)
 }
Index: ring/tests/hmac_tests.rs
===================================================================
--- ring.orig/tests/hmac_tests.rs
+++ ring/tests/hmac_tests.rs
@@ -16,7 +16,10 @@
 
 use ring::{digest, hmac};
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -26,6 +29,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /*#[test]
 fn hmac_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("hmac_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let digest_alg = test_case.consume_digest_alg("HMAC");
Index: ring/tests/pbkdf2_tests.rs
===================================================================
--- ring.orig/tests/pbkdf2_tests.rs
+++ ring/tests/pbkdf2_tests.rs
@@ -17,7 +17,10 @@
 use core::num::NonZeroU32;
 use ring::{digest, error, pbkdf2};
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -28,6 +31,7 @@ wasm_bindgen_test_configure!(run_in_brow
 /* /// Test vectors from BoringSSL, Go, and other sources.
 #[test]
 pub fn pbkdf2_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("pbkdf2_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let algorithm = {
Index: ring/tests/quic_tests.rs
===================================================================
--- ring.orig/tests/quic_tests.rs
+++ ring/tests/quic_tests.rs
@@ -16,23 +16,30 @@
 
 use ring::aead::quic;
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_128() {
     test_quic(&quic::AES_128, test_file!("quic_aes_128_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_256() {
     test_quic(&quic::AES_256, test_file!("quic_aes_256_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_chacha20() {
     test_quic(&quic::CHACHA20, test_file!("quic_chacha20_tests.txt"));
 }*/
 
+#[cfg(feature = "alloc")]
 fn test_quic(alg: &'static quic::Algorithm, test_file: test::File) {
     test_key_len(alg);
     test_sample_len(alg);
Index: ring/src/lib.rs
===================================================================
--- ring.orig/src/lib.rs
+++ ring/src/lib.rs
@@ -91,7 +91,7 @@
 )]
 #![no_std]
 
-#[cfg(feature = "alloc")]
+#[cfg(any(feature = "alloc",test))]
 extern crate alloc;
 
 #[macro_use]
Index: ring/src/limb.rs
===================================================================
--- ring.orig/src/limb.rs
+++ ring/src/limb.rs
@@ -393,6 +393,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_are_even() {
         static EVENS: &[&[LeakyLimb]] = &[
             &[],
@@ -463,6 +464,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_equal_limb() {
         // Equal
         static EQUAL: &[&[LeakyLimb]] = &[&[1], &[1, 0], &[1, 0, 0], &[1, 0, 0, 0, 0, 0, 0]];
@@ -636,6 +638,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_minimal_bits() {
         const ALL_ONES: LeakyLimb = LeakyLimb::MAX;
         static CASES: &[(&[LeakyLimb], usize)] = &[
Index: ring/src/testutil.rs
===================================================================
--- ring.orig/src/testutil.rs
+++ ring/src/testutil.rs
@@ -537,6 +537,7 @@ pub mod rand {
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::error;
     use crate::testutil as test;
Index: ring/tests/hkdf_tests.rs
===================================================================
--- ring.orig/tests/hkdf_tests.rs
+++ ring/tests/hkdf_tests.rs
@@ -16,7 +16,10 @@
 
 use ring::{digest, error, hkdf};
 #[allow(deprecated)]
-use ring::{test, test_file};
+use ring::test;
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -25,6 +28,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 wasm_bindgen_test_configure!(run_in_browser);
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn hkdf_tests() {
     test::run(test_file!("hkdf_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
