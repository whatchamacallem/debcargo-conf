Index: ring/src/aead/aes.rs
===================================================================
--- ring.orig/src/aead/aes.rs
+++ ring/src/aead/aes.rs
@@ -425,6 +425,7 @@ fn detect_implementation(cpu_features: c
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::test;
Index: ring/src/aead/poly1305.rs
===================================================================
--- ring.orig/src/aead/poly1305.rs
+++ ring/src/aead/poly1305.rs
@@ -121,6 +121,7 @@ pub(super) fn sign(key: Key, input: &[u8
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::test;
Index: ring/src/ec/suite_b/ecdsa/digest_scalar.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/digest_scalar.rs
+++ ring/src/ec/suite_b/ecdsa/digest_scalar.rs
@@ -69,6 +69,7 @@ fn digest_scalar_(ops: &ScalarOps, diges
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::digest_bytes_scalar;
     use crate::{digest, ec::suite_b::ops::*, limb, test};
Index: ring/src/ec/suite_b/ecdsa/signing.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/signing.rs
+++ ring/src/ec/suite_b/ecdsa/signing.rs
@@ -512,6 +512,7 @@ static EC_PUBLIC_KEY_P384_PKCS8_V1_TEMPL
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::{rand, signature, test};
 
Index: ring/src/ec/suite_b/ecdsa/verification.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/verification.rs
+++ ring/src/ec/suite_b/ecdsa/verification.rs
@@ -273,6 +273,7 @@ pub static ECDSA_P384_SHA384_ASN1: Ecdsa
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     extern crate alloc;
     use super::*;
Index: ring/src/ec/suite_b/ops.rs
===================================================================
--- ring.orig/src/ec/suite_b/ops.rs
+++ ring/src/ec/suite_b/ops.rs
@@ -505,2 +505,3 @@ mod tests {
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_add_test() {
@@ -516,6 +518,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_add_test(ops: &PublicScalarOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -541,6 +544,7 @@ mod tests {
     // the point arithmetic functions. Thus, we can't test it.
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_sub_test() {
         prefixed_extern! {
             fn p384_elem_sub(r: *mut Limb, a: *const Limb, b: *const Limb);
@@ -552,6 +556,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_sub_test(
         ops: &CommonOps,
         elem_sub: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, b: *const Limb),
@@ -592,6 +597,7 @@ mod tests {
     // into the point arithmetic functions. Thus, we can't test it.
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_div_by_2_test() {
         prefixed_extern! {
             fn p384_elem_div_by_2(r: *mut Limb, a: *const Limb);
@@ -603,6 +609,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_div_by_2_test(
         ops: &CommonOps,
         elem_div_by_2: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -627,6 +634,7 @@ mod tests {
     // There is no `ecp_nistz256_neg` on other targets.
     /* #[cfg(target_arch = "x86_64")]
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_neg_test() {
         prefixed_extern! {
             fn ecp_nistz256_neg(r: *mut Limb, a: *const Limb);
@@ -639,6 +647,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_neg_test() {
         prefixed_extern! {
             fn p384_elem_neg(r: *mut Limb, a: *const Limb);
@@ -650,6 +659,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_neg_test(
         ops: &CommonOps,
         elem_neg: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -684,15 +694,18 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_mul_test() {
         elem_mul_test(&p256::COMMON_OPS, test_file!("ops/p256_elem_mul_tests.txt"));
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_mul_test() {
         elem_mul_test(&p384::COMMON_OPS, test_file!("ops/p384_elem_mul_tests.txt"));
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_mul_test(ops: &CommonOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -708,6 +721,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_mul_test() {
         scalar_mul_test(
             &p256::SCALAR_OPS,
@@ -716,6 +730,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_scalar_mul_test() {
         scalar_mul_test(
             &p384::SCALAR_OPS,
@@ -723,6 +738,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn scalar_mul_test(ops: &ScalarOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -738,6 +754,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_square_test() {
         prefixed_extern! {
             fn p256_scalar_sqr_rep_mont(r: *mut Limb, a: *const Limb, rep: Limb);
@@ -752,6 +769,7 @@ mod tests {
     // XXX: There's no `p384_scalar_square_test()` because there's no dedicated
     // `p384_scalar_sqr_rep_mont()`.
 
+    #[cfg(feature = "alloc")]
     fn scalar_square_test(
         ops: &ScalarOps,
         sqr_rep: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, rep: Limb),
@@ -797,6 +815,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_sum_test() {
         point_sum_test(
             &p256::PRIVATE_KEY_OPS,
@@ -805,6 +824,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_sum_test() {
         point_sum_test(
             &p384::PRIVATE_KEY_OPS,
@@ -812,6 +832,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_sum_test(ops: &PrivateKeyOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -845,6 +867,7 @@ mod tests {
 
     // XXX: There is no `nistz384_point_add_affine()`.
 
+    #[cfg(feature = "alloc")]
     fn point_sum_mixed_test(
         ops: &PrivateKeyOps,
         point_add_affine: unsafe extern "C" fn(
@@ -873,6 +896,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_double_test() {
         prefixed_extern! {
             fn p256_point_double(
@@ -888,6 +912,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_double_test() {
         prefixed_extern! {
             fn p384_point_double(
@@ -902,6 +927,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_double_test(
         ops: &PrivateKeyOps,
         point_double: unsafe extern "C" fn(
@@ -929,6 +955,7 @@ mod tests {
 
     /// TODO: We should be testing `point_mul` with points other than the generator.
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_test() {
         point_mul_base_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -937,6 +964,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     /// TODO: We should be testing `point_mul` with points other than the generator.
     #[test]
     fn p384_point_mul_test() {
@@ -944,2 +972,3 @@ mod tests {
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_serialized_test() {
@@ -956,6 +986,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_mul_serialized_test(
         priv_ops: &PrivateKeyOps,
         pub_ops: &PublicKeyOps,
@@ -997,6 +1028,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_base_test() {
         point_mul_base_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -1006,6 +1038,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_base_test() {
         point_mul_base_tests(
             &p384::PRIVATE_KEY_OPS,
@@ -1014,6 +1047,7 @@ mod tests {
         );
     }*/
 
+    #[cfg(feature = "alloc")]
     pub(super) fn point_mul_base_tests(
         ops: &PrivateKeyOps,
         f: impl Fn(&Scalar) -> Point,
@@ -1063,6 +1097,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_jacobian_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1082,6 +1117,7 @@ mod tests {
         xy: [Limb; 2 * MAX_LIMBS],
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_affine_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1098,6 +1134,7 @@ mod tests {
         p
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point_elem(ops: &CommonOps, limbs_out: &mut [Limb], elems: &[&str], i: usize) {
         let bytes = test::from_hex(elems[i]).unwrap();
         let bytes = untrusted::Input::from(&bytes);
@@ -1112,6 +1149,7 @@ mod tests {
         Affine(Elem<E>, Elem<E>),
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point<E: Encoding>(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1167,6 +1205,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_elem(ops: &CommonOps, test_case: &mut test::TestCase, name: &str) -> Elem<R> {
         let bytes = consume_padded_bytes(ops, test_case, name);
         let bytes = untrusted::Input::from(&bytes);
@@ -1179,12 +1218,14 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar(ops: &CommonOps, test_case: &mut test::TestCase, name: &str) -> Scalar {
         let bytes = test_case.consume_bytes(name);
         let bytes = untrusted::Input::from(&bytes);
         scalar_parse_big_endian_variable(ops, AllowZero::Yes, bytes).unwrap()
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar_mont(
         ops: &CommonOps,
         test_case: &mut test::TestCase,
@@ -1201,6 +1242,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_padded_bytes(
         ops: &CommonOps,
         test_case: &mut test::TestCase,
Index: ring/src/ec/suite_b/public_key.rs
===================================================================
--- ring.orig/src/ec/suite_b/public_key.rs
+++ ring/src/ec/suite_b/public_key.rs
@@ -70,6 +70,7 @@ mod tests {
     use crate::test;
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn parse_uncompressed_point_test() {
         test::run(
             test_file!("suite_b_public_key_tests.txt"),
Index: ring/tests/aead_tests.rs
===================================================================
--- ring.orig/tests/aead_tests.rs
+++ ring/tests/aead_tests.rs
@@ -19,10 +19,14 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 wasm_bindgen_test_configure!(run_in_browser);
 
 use core::ops::RangeFrom;
-use ring::{aead, error, test, test_file};
+use ring::{aead, error, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 /// Generate the known answer test functions for the given algorithm and test
 /// case input file, where each test is implemented by a test in `$test`.
+#[cfg(feature = "alloc")]
 ///
 /// All of these tests can be run in parallel.
 macro_rules! test_known_answer {
@@ -42,6 +46,7 @@ macro_rules! test_known_answer {
 /// Generate the tests for a given algorithm.
 ///
 /// All of these tests can be run in parallel.
+#[cfg(feature = "alloc")]
 macro_rules! test_aead {
     { $( { $alg:ident, $test_file:expr } ),+, } => {
         mod aead_test { // Make `cargo test aead` include these files.
@@ -78,7 +83,8 @@ macro_rules! test_aead {
     }
 }
 
-/*test_aead! {
+/*#[cfg(feature = "alloc")]
+test_aead! {
     { AES_128_GCM, "aead_aes_128_gcm_tests.txt" },
     { AES_256_GCM, "aead_aes_256_gcm_tests.txt" },
     { CHACHA20_POLY1305, "aead_chacha20_poly1305_tests.txt" },
@@ -443,6 +449,7 @@ fn test_aead_nonce_sizes() {
 
 /* #[allow(clippy::range_plus_one)]
 #[test]
+#[cfg(feature = "alloc")]
 fn aead_chacha20_poly1305_openssh() {
     // TODO: test_aead_key_sizes(...);
 
Index: ring/tests/agreement_tests.rs
===================================================================
--- ring.orig/tests/agreement_tests.rs
+++ ring/tests/agreement_tests.rs
@@ -20,7 +20,10 @@ wasm_bindgen_test_configure!(run_in_brow
 
 extern crate alloc;
 
-use ring::{agreement, error, rand, test, test_file};
+use ring::{agreement, error, rand, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[test]
 fn agreement_traits() {
@@ -69,6 +72,7 @@ fn agreement_traits() {
 }
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn agreement_agree_ephemeral() {
     let rng = rand::SystemRandom::new();
 
@@ -126,6 +130,7 @@ fn agreement_agree_ephemeral() {
 } */
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_agreement_ecdh_x25519_rfc_iterated() {
     let mut k = h("0900000000000000000000000000000000000000000000000000000000000000");
     let mut u = k.clone();
@@ -190,6 +195,7 @@ fn x25519_(private_key: &[u8], public_ke
     })
 }
 
+#[cfg(feature = "alloc")]
 fn h(s: &str) -> Vec<u8> {
     match test::from_hex(s) {
         Ok(v) => v,
Index: ring/tests/digest_tests.rs
===================================================================
--- ring.orig/tests/digest_tests.rs
+++ ring/tests/digest_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, test, test_file};
+use ring::{digest, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -23,4 +26,5 @@
 /// Test vectors from BoringSSL, Go, and other sources.
 /* #[test]
+#[cfg(feature = "alloc")]
 fn digest_misc() {
     test::run(test_file!("digest_tests.txt"), |section, test_case| {
@@ -46,6 +50,7 @@ fn digest_misc() {
     });
 } */
 
+#[cfg(feature = "alloc")]
 mod digest_shavs {
     use ring::{digest, test};
 
@@ -84,4 +89,5 @@ mod digest_shavs {
 
                 #[test]
+                #[cfg(feature = "alloc")]
                 fn short_msg_known_answer_test() {
                     run_known_answer_test(
@@ -97,2 +103,3 @@ mod digest_shavs {
                 #[test]
+                #[cfg(feature = "alloc")]
                 fn long_msg_known_answer_test() {
@@ -109,2 +116,3 @@ mod digest_shavs {
                 #[test]
+                #[cfg(feature = "alloc")]
                 fn monte_carlo_test() {
Index: ring/tests/ecdsa_tests.rs
===================================================================
--- ring.orig/tests/ecdsa_tests.rs
+++ ring/tests/ecdsa_tests.rs
@@ -15,12 +15,16 @@
 use ring::{
     rand,
     signature::{self, KeyPair},
-    test, test_file,
+    test,
 };
 
+#[cfg(feature = "alloc")]
+use ring::test_file;
+
 // ECDSA *signing* tests are in src/ec/ecdsa/signing.rs.
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn ecdsa_from_pkcs8_test() {
     let rng = rand::SystemRandom::new();
 
@@ -111,6 +115,7 @@ fn ecdsa_generate_pkcs8_test() {
 }
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_asn1_test() {
     test::run(
         test_file!("ecdsa_verify_asn1_tests.txt"),
@@ -144,6 +149,7 @@ fn signature_ecdsa_verify_asn1_test() {
 } 
 
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_fixed_test() {
     test::run(
         test_file!("ecdsa_verify_fixed_tests.txt"),
@@ -215,6 +221,7 @@ fn ecdsa_test_public_key_coverage() {
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 /* #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_fixed_sign_and_verify_test() {
     let rng = rand::SystemRandom::new();
 
@@ -269,6 +276,7 @@ fn signature_ecdsa_sign_fixed_sign_and_v
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_asn1_test() {
     let rng = rand::SystemRandom::new();
 
Index: ring/tests/ed25519_tests.rs
===================================================================
--- ring.orig/tests/ed25519_tests.rs
+++ ring/tests/ed25519_tests.rs
@@ -15,9 +15,12 @@
 use ring::{
     error, rand,
     signature::{self, Ed25519KeyPair, KeyPair},
-    test, test_file,
+    test,
 };
 
+#[cfg(feature = "alloc")]
+use ring::test_file;
+
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
 
@@ -26,6 +29,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /* /// Test vectors from BoringSSL.
 #[test]
+#[cfg(feature = "alloc")]
 fn test_signature_ed25519() {
     test::run(test_file!("ed25519_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -89,6 +93,7 @@ fn test_signature_ed25519_verify() {
     );
 }*/
 
+#[cfg(feature = "alloc")]
 fn test_signature_verification(
     public_key: &[u8],
     msg: &[u8],
@@ -132,6 +137,7 @@ fn test_ed25519_from_pkcs8_unchecked() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_ed25519_from_pkcs8() {
     test_ed25519_from_pkcs8_(FromPkcs8Variant::Checked, Ed25519KeyPair::from_pkcs8)
 }
Index: ring/tests/hmac_tests.rs
===================================================================
--- ring.orig/tests/hmac_tests.rs
+++ ring/tests/hmac_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, hmac, test, test_file};
+use ring::{digest, hmac, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -22,6 +25,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /*#[test]
 fn hmac_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("hmac_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let digest_alg = test_case.consume_digest_alg("HMAC");
Index: ring/tests/pbkdf2_tests.rs
===================================================================
--- ring.orig/tests/pbkdf2_tests.rs
+++ ring/tests/pbkdf2_tests.rs
@@ -13,7 +13,10 @@
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 use core::num::NonZeroU32;
-use ring::{digest, error, pbkdf2, test, test_file};
+use ring::{digest, error, pbkdf2, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -24,6 +27,7 @@ wasm_bindgen_test_configure!(run_in_brow
 /* /// Test vectors from BoringSSL, Go, and other sources.
 #[test]
 pub fn pbkdf2_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("pbkdf2_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let algorithm = {
Index: ring/tests/quic_tests.rs
===================================================================
--- ring.orig/tests/quic_tests.rs
+++ ring/tests/quic_tests.rs
@@ -12,23 +12,30 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{aead::quic, test, test_file};
+use ring::{aead::quic, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_128() {
     test_quic(&quic::AES_128, test_file!("quic_aes_128_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_256() {
     test_quic(&quic::AES_256, test_file!("quic_aes_256_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_chacha20() {
     test_quic(&quic::CHACHA20, test_file!("quic_chacha20_tests.txt"));
 }*/
 
+#[cfg(feature = "alloc")]
 fn test_quic(alg: &'static quic::Algorithm, test_file: test::File) {
     test_sample_len(alg);
 
Index: ring/src/lib.rs
===================================================================
--- ring.orig/src/lib.rs
+++ ring/src/lib.rs
@@ -76,7 +76,7 @@
 )]
 #![no_std]
 
-#[cfg(feature = "alloc")]
+#[cfg(any(feature = "alloc",test))]
 extern crate alloc;
 
 #[macro_use]
Index: ring/src/limb.rs
===================================================================
--- ring.orig/src/limb.rs
+++ ring/src/limb.rs
@@ -377,6 +377,7 @@ mod tests {
     const MAX: Limb = LimbMask::True as Limb;
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_are_even() {
         static EVENS: &[&[Limb]] = &[
             &[],
@@ -440,6 +441,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_equal_limb() {
         for zero in ZEROES {
             assert_eq!(limbs_equal_limb_constant_time(zero, 0), LimbMask::True);
@@ -603,6 +605,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_minimal_bits() {
         const ALL_ONES: Limb = LimbMask::True as Limb;
         static CASES: &[(&[Limb], usize)] = &[
Index: ring/src/test.rs
===================================================================
--- ring.orig/src/test.rs
+++ ring/src/test.rs
@@ -538,6 +538,7 @@ pub mod rand {
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::{error, test};
 
Index: ring/tests/hkdf_tests.rs
===================================================================
--- ring.orig/tests/hkdf_tests.rs
+++ ring/tests/hkdf_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, error, hkdf, test, test_file};
+use ring::{digest, error, hkdf, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -22,4 +25,5 @@
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn hkdf_tests() {
     test::run(test_file!("hkdf_tests.txt"), |section, test_case| {
