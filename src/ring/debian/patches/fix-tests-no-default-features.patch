Index: ring/src/aead/aes.rs
===================================================================
--- ring.orig/src/aead/aes.rs
+++ ring/src/aead/aes.rs
@@ -409,6 +409,7 @@ fn detect_implementation(cpu_features: c
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::{super::BLOCK_LEN, *};
     use crate::test;
Index: ring/src/aead/chacha.rs
===================================================================
--- ring.orig/src/aead/chacha.rs
+++ ring/src/aead/chacha.rs
@@ -157,6 +157,7 @@ mod tests {
     // This test exists largely as a canary for detecting if/when that type of
     // problem spreads to other platforms.
     #[test]
+    #[cfg(feature = "alloc")]
     pub fn chacha20_tests() {
         test::run(test_file!("chacha_tests.txt"), |section, test_case| {
             assert_eq!(section, "");
Index: ring/src/aead/poly1305.rs
===================================================================
--- ring.orig/src/aead/poly1305.rs
+++ ring/src/aead/poly1305.rs
@@ -129,6 +129,7 @@ pub(super) fn sign(key: Key, input: &[u8
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::test;
Index: ring/src/arithmetic/bigint.rs
===================================================================
--- ring.orig/src/arithmetic/bigint.rs
+++ ring/src/arithmetic/bigint.rs
@@ -1404,6 +1404,7 @@ mod tests {
     unsafe impl PublicModulus for M {}
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_elem_exp_consttime() {
         test::run(
             test_file!("bigint_elem_exp_consttime_tests.txt"),
@@ -1432,6 +1433,7 @@ mod tests {
     // In the meantime, the function is tested indirectly via the RSA
     // verification and signing tests.
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_elem_mul() {
         test::run(
             test_file!("bigint_elem_mul_tests.txt"),
@@ -1455,6 +1457,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_elem_squared() {
         test::run(
             test_file!("bigint_elem_squared_tests.txt"),
@@ -1476,6 +1479,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_elem_reduced() {
         test::run(
             test_file!("bigint_elem_reduced_tests.txt"),
@@ -1502,6 +1506,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_elem_reduced_once() {
         test::run(
             test_file!("bigint_elem_reduced_once_tests.txt"),
Index: ring/src/ec/suite_b/ecdsa/digest_scalar.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/digest_scalar.rs
+++ ring/src/ec/suite_b/ecdsa/digest_scalar.rs
@@ -75,6 +75,7 @@ fn digest_scalar_(ops: &ScalarOps, diges
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::digest_bytes_scalar;
     use crate::{
Index: ring/src/ec/suite_b/ecdsa/signing.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/signing.rs
+++ ring/src/ec/suite_b/ecdsa/signing.rs
@@ -514,6 +514,7 @@ static EC_PUBLIC_KEY_P384_PKCS8_V1_TEMPL
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::{signature, test};
 
Index: ring/src/ec/suite_b/ecdsa/verification.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/verification.rs
+++ ring/src/ec/suite_b/ecdsa/verification.rs
@@ -285,7 +285,9 @@ pub static ECDSA_P384_SHA384_ASN1: Ecdsa
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
+    extern crate alloc;
     use super::*;
     use crate::test;
     use alloc::vec::Vec;
Index: ring/src/ec/suite_b/ops.rs
===================================================================
--- ring.orig/src/ec/suite_b/ops.rs
+++ ring/src/ec/suite_b/ops.rs
@@ -465,6 +465,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_add_test() {
         elem_add_test(
             &p256::PUBLIC_SCALAR_OPS,
@@ -473,6 +474,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_add_test() {
         elem_add_test(
             &p384::PUBLIC_SCALAR_OPS,
@@ -480,6 +482,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn elem_add_test(ops: &PublicScalarOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -505,6 +508,7 @@ mod tests {
     // the point arithmetic functions. Thus, we can't test it.
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_sub_test() {
         extern "C" {
             fn GFp_p384_elem_sub(r: *mut Limb, a: *const Limb, b: *const Limb);
@@ -516,6 +520,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn elem_sub_test(
         ops: &CommonOps,
         elem_sub: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, b: *const Limb),
@@ -556,6 +561,7 @@ mod tests {
     // into the point arithmetic functions. Thus, we can't test it.
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_div_by_2_test() {
         extern "C" {
             fn GFp_p384_elem_div_by_2(r: *mut Limb, a: *const Limb);
@@ -567,6 +573,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn elem_div_by_2_test(
         ops: &CommonOps,
         elem_div_by_2: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -590,6 +597,7 @@ mod tests {
 
     // TODO: Add test vectors that test the range of values above `q`.
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_neg_test() {
         extern "C" {
             fn GFp_nistz256_neg(r: *mut Limb, a: *const Limb);
@@ -602,6 +610,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_neg_test() {
         extern "C" {
             fn GFp_p384_elem_neg(r: *mut Limb, a: *const Limb);
@@ -613,6 +622,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn elem_neg_test(
         ops: &CommonOps,
         elem_neg: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -647,15 +657,18 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_mul_test() {
         elem_mul_test(&p256::COMMON_OPS, test_file!("ops/p256_elem_mul_tests.txt"));
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_mul_test() {
         elem_mul_test(&p384::COMMON_OPS, test_file!("ops/p384_elem_mul_tests.txt"));
     }
 
+    #[cfg(feature = "alloc")]
     fn elem_mul_test(ops: &CommonOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -671,6 +684,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_mul_test() {
         scalar_mul_test(
             &p256::SCALAR_OPS,
@@ -679,6 +693,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_scalar_mul_test() {
         scalar_mul_test(
             &p384::SCALAR_OPS,
@@ -686,6 +701,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn scalar_mul_test(ops: &ScalarOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -701,6 +717,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_square_test() {
         extern "C" {
             fn GFp_p256_scalar_sqr_rep_mont(r: *mut Limb, a: *const Limb, rep: Limb);
@@ -715,6 +732,7 @@ mod tests {
     // XXX: There's no `p384_scalar_square_test()` because there's no dedicated
     // `GFp_p384_scalar_sqr_rep_mont()`.
 
+    #[cfg(feature = "alloc")]
     fn scalar_square_test(
         ops: &ScalarOps,
         sqr_rep: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, rep: Limb),
@@ -760,6 +778,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_sum_test() {
         point_sum_test(
             &p256::PRIVATE_KEY_OPS,
@@ -768,6 +787,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_sum_test() {
         point_sum_test(
             &p384::PRIVATE_KEY_OPS,
@@ -775,6 +795,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn point_sum_test(ops: &PrivateKeyOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -795,6 +816,7 @@ mod tests {
     // multiplication to use.
     #[cfg(any(target_arch = "aarch64", target_arch = "x86", target_arch = "x86_64"))]
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_sum_mixed_test() {
         extern "C" {
             fn GFp_nistz256_point_add_affine(
@@ -813,6 +835,7 @@ mod tests {
     // XXX: There is no `GFp_nistz384_point_add_affine()`.
 
     #[cfg(any(target_arch = "aarch64", target_arch = "x86", target_arch = "x86_64"))]
+    #[cfg(feature = "alloc")]
     fn point_sum_mixed_test(
         ops: &PrivateKeyOps,
         point_add_affine: unsafe extern "C" fn(
@@ -841,6 +864,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_double_test() {
         extern "C" {
             fn GFp_nistz256_point_double(
@@ -856,6 +880,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_double_test() {
         extern "C" {
             fn GFp_nistz384_point_double(
@@ -870,6 +895,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn point_double_test(
         ops: &PrivateKeyOps,
         point_double: unsafe extern "C" fn(
@@ -896,6 +922,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_test() {
         point_mul_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -904,6 +931,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_test() {
         point_mul_tests(
             &p384::PRIVATE_KEY_OPS,
@@ -911,6 +939,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn point_mul_tests(ops: &PrivateKeyOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -929,6 +958,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_serialized_test() {
         point_mul_serialized_test(
             &p256::PRIVATE_KEY_OPS,
@@ -937,6 +967,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn point_mul_serialized_test(
         priv_ops: &PrivateKeyOps,
         pub_ops: &PublicKeyOps,
@@ -978,6 +1009,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_base_test() {
         point_mul_base_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -986,6 +1018,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_base_test() {
         point_mul_base_tests(
             &p384::PRIVATE_KEY_OPS,
@@ -993,6 +1026,7 @@ mod tests {
         );
     }
 
+    #[cfg(feature = "alloc")]
     fn point_mul_base_tests(ops: &PrivateKeyOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -1033,6 +1067,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_jacobian_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1054,6 +1089,7 @@ mod tests {
     }
 
     #[cfg(any(target_arch = "aarch64", target_arch = "x86", target_arch = "x86_64"))]
+    #[cfg(feature = "alloc")]
     fn consume_affine_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1070,6 +1106,7 @@ mod tests {
         p
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point_elem(ops: &CommonOps, limbs_out: &mut [Limb], elems: &[&str], i: usize) {
         let bytes = test::from_hex(elems[i]).unwrap();
         let bytes = untrusted::Input::from(&bytes);
@@ -1084,6 +1121,7 @@ mod tests {
         Affine(Elem<R>, Elem<R>),
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point(ops: &PrivateKeyOps, test_case: &mut test::TestCase, name: &str) -> TestPoint {
         fn consume_point_elem(ops: &CommonOps, elems: &[&str], i: usize) -> Elem<R> {
             let bytes = test::from_hex(elems[i]).unwrap();
@@ -1130,6 +1168,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_elem(ops: &CommonOps, test_case: &mut test::TestCase, name: &str) -> Elem<R> {
         let bytes = consume_padded_bytes(ops, test_case, name);
         let bytes = untrusted::Input::from(&bytes);
@@ -1142,12 +1181,14 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar(ops: &CommonOps, test_case: &mut test::TestCase, name: &str) -> Scalar {
         let bytes = test_case.consume_bytes(name);
         let bytes = untrusted::Input::from(&bytes);
         scalar_parse_big_endian_variable(ops, AllowZero::Yes, bytes).unwrap()
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar_mont(
         ops: &CommonOps,
         test_case: &mut test::TestCase,
@@ -1164,6 +1205,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_padded_bytes(
         ops: &CommonOps,
         test_case: &mut test::TestCase,
Index: ring/src/ec/suite_b/public_key.rs
===================================================================
--- ring.orig/src/ec/suite_b/public_key.rs
+++ ring/src/ec/suite_b/public_key.rs
@@ -70,6 +70,7 @@ mod tests {
     use crate::test;
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn parse_uncompressed_point_test() {
         test::run(
             test_file!("suite_b_public_key_tests.txt"),
Index: ring/src/rsa/padding.rs
===================================================================
--- ring.orig/src/rsa/padding.rs
+++ ring/src/rsa/padding.rs
@@ -523,6 +523,7 @@ mod test {
     use alloc::vec;
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_pss_padding_verify() {
         test::run(
             test_file!("rsa_pss_padding_tests.txt"),
Index: ring/tests/aead_tests.rs
===================================================================
--- ring.orig/tests/aead_tests.rs
+++ ring/tests/aead_tests.rs
@@ -21,10 +21,14 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 wasm_bindgen_test_configure!(run_in_browser);
 
 use core::ops::RangeFrom;
-use ring::{aead, error, test, test_file};
+use ring::{aead, error, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[test]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+#[cfg(feature = "alloc")]
 fn aead_aes_gcm_128() {
     test_aead(
         &aead::AES_128_GCM,
@@ -42,6 +46,7 @@ fn aead_aes_gcm_128() {
 
 #[test]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+#[cfg(feature = "alloc")]
 fn aead_aes_gcm_256() {
     test_aead(
         &aead::AES_256_GCM,
@@ -64,6 +69,7 @@ fn aead_aes_gcm_256() {
     target_arch = "x86"
 ))]
 #[test]
+#[cfg(feature = "alloc")]
 fn aead_chacha20_poly1305() {
     test_aead(
         &aead::CHACHA20_POLY1305,
@@ -79,6 +85,7 @@ fn aead_chacha20_poly1305() {
     );
 }
 
+#[cfg(feature = "alloc")]
 fn test_aead<Seal, Open>(
     aead_alg: &'static aead::Algorithm,
     seal: Seal,
@@ -335,6 +342,7 @@ fn test_aead_nonce_sizes() -> Result<(),
 ))]
 #[allow(clippy::range_plus_one)]
 #[test]
+#[cfg(feature = "alloc")]
 fn aead_chacha20_poly1305_openssh() {
     // TODO: test_aead_key_sizes(...);
 
Index: ring/tests/agreement_tests.rs
===================================================================
--- ring.orig/tests/agreement_tests.rs
+++ ring/tests/agreement_tests.rs
@@ -14,7 +14,10 @@
 
 extern crate alloc;
 
-use ring::{agreement, error, rand, test, test_file};
+use ring::{agreement, error, rand, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[test]
 fn agreement_traits() {
@@ -60,6 +63,7 @@ fn agreement_traits() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn agreement_agree_ephemeral() {
     let rng = rand::SystemRandom::new();
 
@@ -120,6 +124,7 @@ fn agreement_agree_ephemeral() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_agreement_ecdh_x25519_rfc_iterated() {
     let mut k = h("0900000000000000000000000000000000000000000000000000000000000000");
     let mut u = k.clone();
@@ -187,6 +192,7 @@ fn x25519_(private_key: &[u8], public_ke
     )
 }
 
+#[cfg(feature = "alloc")]
 fn h(s: &str) -> Vec<u8> {
     match test::from_hex(s) {
         Ok(v) => v,
Index: ring/tests/digest_tests.rs
===================================================================
--- ring.orig/tests/digest_tests.rs
+++ ring/tests/digest_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, test, test_file};
+use ring::{digest, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(target_arch = "wasm32")]
 use wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};
@@ -23,6 +26,7 @@ wasm_bindgen_test_configure!(run_in_brow
 /// Test vectors from BoringSSL, Go, and other sources.
 #[test]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+#[cfg(feature = "alloc")]
 fn digest_misc() {
     test::run(test_file!("digest_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -47,6 +51,7 @@ fn digest_misc() {
     });
 }
 
+#[cfg(feature = "alloc")]
 mod digest_shavs {
     use ring::{digest, test};
 
@@ -85,6 +90,7 @@ mod digest_shavs {
 
                 #[test]
                 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+                #[cfg(feature = "alloc")]
                 fn short_msg_known_answer_test() {
                     run_known_answer_test(
                         &digest::$algorithm_name,
@@ -98,6 +104,7 @@ mod digest_shavs {
 
                 #[test]
                 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+                #[cfg(feature = "alloc")]
                 fn long_msg_known_answer_test() {
                     run_known_answer_test(
                         &digest::$algorithm_name,
@@ -111,6 +118,7 @@ mod digest_shavs {
 
                 #[test]
                 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+                #[cfg(feature = "alloc")]
                 fn monte_carlo_test() {
                     run_monte_carlo_test(
                         &digest::$algorithm_name,
Index: ring/tests/ecdsa_tests.rs
===================================================================
--- ring.orig/tests/ecdsa_tests.rs
+++ ring/tests/ecdsa_tests.rs
@@ -15,12 +15,16 @@
 use ring::{
     rand,
     signature::{self, KeyPair},
-    test, test_file,
+    test,
 };
 
+#[cfg(feature = "alloc")]
+use ring::test_file;
+
 // ECDSA *signing* tests are in src/ec/ecdsa/signing.rs.
 
 #[test]
+#[cfg(feature = "alloc")]
 fn ecdsa_from_pkcs8_test() {
     test::run(
         test_file!("ecdsa_from_pkcs8_tests.txt"),
@@ -109,6 +113,7 @@ fn ecdsa_generate_pkcs8_test() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_asn1_test() {
     test::run(
         test_file!("ecdsa_verify_asn1_tests.txt"),
@@ -142,6 +147,7 @@ fn signature_ecdsa_verify_asn1_test() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_fixed_test() {
     test::run(
         test_file!("ecdsa_verify_fixed_tests.txt"),
@@ -211,6 +217,7 @@ fn ecdsa_test_public_key_coverage() {
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_fixed_sign_and_verify_test() {
     let rng = rand::SystemRandom::new();
 
@@ -265,6 +272,7 @@ fn signature_ecdsa_sign_fixed_sign_and_v
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_asn1_test() {
     let rng = rand::SystemRandom::new();
 
Index: ring/tests/ed25519_tests.rs
===================================================================
--- ring.orig/tests/ed25519_tests.rs
+++ ring/tests/ed25519_tests.rs
@@ -15,11 +15,15 @@
 use ring::{
     error,
     signature::{self, Ed25519KeyPair, KeyPair},
-    test, test_file,
+    test,
 };
 
+#[cfg(feature = "alloc")]
+use ring::test_file;
+
 /// Test vectors from BoringSSL.
 #[test]
+#[cfg(feature = "alloc")]
 fn test_signature_ed25519() {
     test::run(test_file!("ed25519_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -113,6 +117,7 @@ fn test_ed25519_from_seed_and_public_key
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_ed25519_from_pkcs8_unchecked() {
     // Just test that we can parse the input.
     test::run(
@@ -135,6 +140,7 @@ fn test_ed25519_from_pkcs8_unchecked() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_ed25519_from_pkcs8() {
     // Just test that we can parse the input.
     test::run(
Index: ring/tests/hmac_tests.rs
===================================================================
--- ring.orig/tests/hmac_tests.rs
+++ ring/tests/hmac_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, error, hmac, test, test_file};
+use ring::{digest, error, hmac, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(target_arch = "wasm32")]
 use wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};
@@ -22,6 +25,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 #[test]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+#[cfg(feature = "alloc")]
 fn hmac_tests() {
     test::run(test_file!("hmac_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
Index: ring/tests/pbkdf2_tests.rs
===================================================================
--- ring.orig/tests/pbkdf2_tests.rs
+++ ring/tests/pbkdf2_tests.rs
@@ -13,7 +13,10 @@
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 use core::num::NonZeroU32;
-use ring::{digest, error, pbkdf2, test, test_file};
+use ring::{digest, error, pbkdf2, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(target_arch = "wasm32")]
 use wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};
@@ -24,6 +27,7 @@ wasm_bindgen_test_configure!(run_in_brow
 /// Test vectors from BoringSSL, Go, and other sources.
 #[test]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+#[cfg(feature = "alloc")]
 pub fn pbkdf2_tests() {
     test::run(test_file!("pbkdf2_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
Index: ring/tests/quic_tests.rs
===================================================================
--- ring.orig/tests/quic_tests.rs
+++ ring/tests/quic_tests.rs
@@ -12,23 +12,30 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{aead::quic, test, test_file};
+use ring::{aead::quic, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_128() {
     test_quic(&quic::AES_128, test_file!("quic_aes_128_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_256() {
     test_quic(&quic::AES_256, test_file!("quic_aes_256_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_chacha20() {
     test_quic(&quic::CHACHA20, test_file!("quic_chacha20_tests.txt"));
 }
 
+#[cfg(feature = "alloc")]
 fn test_quic(alg: &'static quic::Algorithm, test_file: test::File) {
     test_sample_len(alg);
 
Index: ring/src/lib.rs
===================================================================
--- ring.orig/src/lib.rs
+++ ring/src/lib.rs
@@ -73,7 +73,7 @@
 #![forbid(unused_results)]
 #![no_std]
 
-#[cfg(feature = "alloc")]
+#[cfg(any(feature = "alloc",test))]
 extern crate alloc;
 
 #[macro_use]
Index: ring/src/limb.rs
===================================================================
--- ring.orig/src/limb.rs
+++ ring/src/limb.rs
@@ -353,6 +353,7 @@ mod tests {
     const MAX: Limb = LimbMask::True as Limb;
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_are_even() {
         static EVENS: &[&[Limb]] = &[
             &[],
@@ -416,6 +417,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_equal_limb() {
         for zero in ZEROES {
             assert_eq!(limbs_equal_limb_constant_time(zero, 0), LimbMask::True);
@@ -579,6 +581,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_minimal_bits() {
         const ALL_ONES: Limb = LimbMask::True as Limb;
         static CASES: &[(&[Limb], usize)] = &[
Index: ring/src/test.rs
===================================================================
--- ring.orig/src/test.rs
+++ ring/src/test.rs
@@ -541,6 +541,7 @@ pub mod rand {
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::{error, test};
 
Index: ring/tests/hkdf_tests.rs
===================================================================
--- ring.orig/tests/hkdf_tests.rs
+++ ring/tests/hkdf_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, error, hkdf, test, test_file};
+use ring::{digest, error, hkdf, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(target_arch = "wasm32")]
 use wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};
@@ -22,6 +25,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 #[test]
 #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+#[cfg(feature = "alloc")]
 fn hkdf_tests() {
     test::run(test_file!("hkdf_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
