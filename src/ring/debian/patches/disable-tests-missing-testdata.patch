Index: ring/tests/ed25519_tests.rs
===================================================================
--- ring.orig/tests/ed25519_tests.rs
+++ ring/tests/ed25519_tests.rs
@@ -27,7 +27,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 wasm_bindgen_test_configure!(run_in_browser);
 
-/// Test vectors from BoringSSL.
+/* /// Test vectors from BoringSSL.
 #[test]
 fn test_signature_ed25519() {
     test::run(test_file!("ed25519_tests.txt"), |section, test_case| {
@@ -69,10 +69,10 @@ fn test_signature_ed25519() {
 
         Ok(())
     });
-}
+} */
 
 /// Test vectors from BoringSSL.
-#[test]
+/*#[test]
 fn test_signature_ed25519_verify() {
     test::run(
         test_file!("ed25519_verify_tests.txt"),
@@ -91,7 +91,7 @@ fn test_signature_ed25519_verify() {
             Ok(())
         },
     );
-}
+}*/
 
 fn test_signature_verification(
     public_key: &[u8],
@@ -127,7 +127,7 @@ enum FromPkcs8Variant {
     MaybeUnchecked,
 }
 
-#[test]
+/* #[test]
 fn test_ed25519_from_pkcs8_unchecked() {
     test_ed25519_from_pkcs8_(
         FromPkcs8Variant::MaybeUnchecked,
@@ -189,7 +189,7 @@ fn test_ed25519_from_pkcs8_(
             Ok(())
         },
     );
-}
+} */
 
 #[test]
 fn ed25519_test_generate_pkcs8() {
Index: ring/src/aead/aes.rs
===================================================================
--- ring.orig/src/aead/aes.rs
+++ ring/src/aead/aes.rs
@@ -209,7 +209,7 @@ mod tests {
     use super::*;
     use crate::testutil as test;
 
-    #[test]
+    /* #[test]
     pub fn test_aes() {
         test::run(test_vector_file!("aes_tests.txt"), |section, test_case| {
             assert_eq!(section, "");
@@ -223,7 +223,7 @@ mod tests {
 
             Ok(())
         })
-    }
+    } */
 
     fn consume_key(test_case: &mut test::TestCase, name: &str) -> Key {
         let key = test_case.consume_bytes(name);
Index: ring/src/aead/chacha.rs
===================================================================
--- ring.orig/src/aead/chacha.rs
+++ ring/src/aead/chacha.rs
@@ -213,7 +213,7 @@ mod tests {
             (0, 0)
         };
 
-    #[test]
+    /* #[test]
     fn chacha20_test_default() {
         // Always use `MAX_OFFSET` if we hav assembly code.
         let max_offset = if cfg!(any(
@@ -235,7 +235,7 @@ mod tests {
         chacha20_test(MAX_ALIGNMENT_AND_OFFSET_SUBSET, |key, ctr, in_out, _cpu| {
             fallback::ChaCha20_ctr32(key, ctr, in_out)
         });
-    }
+    } */
 
     // Verifies the encryption is successful when done on overlapping buffers.
     //
@@ -244,7 +244,7 @@ mod tests {
     // not exactly overlapping. Such failures are dependent not only on the
     // degree of overlapping but also the length of the data. `encrypt_within`
     // works around that.
-    fn chacha20_test(
+    /*fn chacha20_test(
         max_alignment_and_offset: (usize, usize),
         f: impl for<'k, 'o> Fn(&'k Key, Counter, Overlapping<'o>, cpu::Features),
     ) {
@@ -288,7 +288,7 @@ mod tests {
                 Ok(())
             },
         );
-    }
+    }*/
 
     fn chacha20_test_case_inner(
         key: &Key,
Index: ring/src/arithmetic/bigint.rs
===================================================================
--- ring.orig/src/arithmetic/bigint.rs
+++ ring/src/arithmetic/bigint.rs
@@ -841,7 +841,7 @@ mod tests {
 
     impl PublicModulus for M {}
 
-    #[test]
+    /* #[test]
     fn test_elem_exp_consttime() {
         let cpu_features = cpu::features();
         test::run(
@@ -947,9 +947,9 @@ mod tests {
                 Ok(())
             },
         )
-    }
+    } */
 
-    #[test]
+    /* #[test]
     fn test_elem_squared() {
         let cpu_features = cpu::features();
         test::run(
@@ -970,9 +970,9 @@ mod tests {
                 Ok(())
             },
         )
-    }
+    } */
 
-    #[test]
+    /* #[test]
     fn test_elem_reduced() {
         let cpu_features = cpu::features();
         test::run(
@@ -1022,7 +1022,7 @@ mod tests {
                 Ok(())
             },
         )
-    }
+    } */
 
     fn consume_elem<M>(
         test_case: &mut test::TestCase,
Index: ring/src/ec/suite_b/ops.rs
===================================================================
--- ring.orig/src/ec/suite_b/ops.rs
+++ ring/src/ec/suite_b/ops.rs
@@ -656,7 +656,7 @@ mod tests {
         q_minus_n_plus_n_equals_0_test(&p384::PUBLIC_SCALAR_OPS);
     }
 
-    #[test]
+    /* #[test]
     fn p256_elem_add_test() {
         elem_add_test(
             &p256::PUBLIC_SCALAR_OPS,
@@ -670,7 +670,7 @@ mod tests {
             &p384::PUBLIC_SCALAR_OPS,
             test_vector_file!("ops/p384_elem_sum_tests.txt"),
         );
-    }
+    } */
 
     fn elem_add_test(ops: &PublicScalarOps, test_file: test::File) {
         let cops = ops.public_key_ops.common;
@@ -697,7 +697,7 @@ mod tests {
     // XXX: There's no `p256_sub` in *ring*; it's logic is inlined into
     // the point arithmetic functions. Thus, we can't test it.
 
-    #[test]
+    /* #[test]
     fn p384_elem_sub_test() {
         prefixed_extern! {
             fn p384_elem_sub(r: *mut Limb, a: *const Limb, b: *const Limb);
@@ -707,7 +707,7 @@ mod tests {
             p384_elem_sub,
             test_vector_file!("ops/p384_elem_sum_tests.txt"),
         );
-    }
+    } */
 
     fn elem_sub_test(
         ops: &'static CommonOps,
@@ -749,7 +749,7 @@ mod tests {
     // XXX: There's no `p256_div_by_2` in *ring*; it's logic is inlined
     // into the point arithmetic functions. Thus, we can't test it.
 
-    #[test]
+    /* #[test]
     fn p384_elem_div_by_2_test() {
         prefixed_extern! {
             fn p384_elem_div_by_2(r: *mut Limb, a: *const Limb);
@@ -759,7 +759,7 @@ mod tests {
             p384_elem_div_by_2,
             test_vector_file!("ops/p384_elem_div_by_2_tests.txt"),
         );
-    }
+    } */
 
     fn elem_div_by_2_test(
         ops: &'static CommonOps,
@@ -784,7 +784,7 @@ mod tests {
     }
 
     // There is no `ecp_nistz256_neg` on other targets.
-    #[cfg(target_arch = "x86_64")]
+    /* #[cfg(target_arch = "x86_64")]
     #[test]
     fn p256_elem_neg_test() {
         prefixed_extern! {
@@ -807,7 +807,7 @@ mod tests {
             p384_elem_neg,
             test_vector_file!("ops/p384_elem_neg_tests.txt"),
         );
-    }
+    } */
 
     fn elem_neg_test(
         ops: &'static CommonOps,
@@ -843,7 +843,7 @@ mod tests {
         })
     }
 
-    #[test]
+    /* #[test]
     fn p256_elem_mul_test() {
         elem_mul_test(
             &p256::COMMON_OPS,
@@ -857,7 +857,7 @@ mod tests {
             &p384::COMMON_OPS,
             test_vector_file!("ops/p384_elem_mul_tests.txt"),
         );
-    }
+    }*/
 
     fn elem_mul_test(ops: &'static CommonOps, test_file: test::File) {
         let q = &ops.elem_modulus(cpu::features());
@@ -874,7 +874,7 @@ mod tests {
         })
     }
 
-    #[test]
+    /* #[test]
     fn p256_scalar_mul_test() {
         scalar_mul_test(
             &p256::SCALAR_OPS,
@@ -888,7 +888,7 @@ mod tests {
             &p384::SCALAR_OPS,
             test_vector_file!("ops/p384_scalar_mul_tests.txt"),
         );
-    }
+    } */
 
     fn scalar_mul_test(ops: &ScalarOps, test_file: test::File) {
         let cpu = cpu::features();
@@ -906,7 +906,7 @@ mod tests {
         })
     }
 
-    #[test]
+    /* #[test]
     fn p256_scalar_square_test() {
         prefixed_extern! {
             fn p256_scalar_sqr_rep_mont(r: *mut Limb, a: *const Limb, rep: LeakyWord);
@@ -916,7 +916,7 @@ mod tests {
             p256_scalar_sqr_rep_mont,
             test_vector_file!("ops/p256_scalar_square_tests.txt"),
         );
-    }
+    } */
 
     // XXX: There's no `p384_scalar_square_test()` because there's no dedicated
     // `p384_scalar_sqr_rep_mont()`.
@@ -968,7 +968,7 @@ mod tests {
         let _ = p384::PRIVATE_SCALAR_OPS.scalar_inv_to_mont(&ZERO_SCALAR, cpu::features());
     }
 
-    #[test]
+    /* #[test]
     fn p256_point_sum_test() {
         point_sum_test(
             &p256::PRIVATE_KEY_OPS,
@@ -982,7 +982,7 @@ mod tests {
             &p384::PRIVATE_KEY_OPS,
             test_vector_file!("ops/p384_point_sum_tests.txt"),
         );
-    }
+    } */
 
     fn point_sum_test(ops: &PrivateKeyOps, test_file: test::File) {
         let cpu = cpu::features();
@@ -1001,7 +1001,7 @@ mod tests {
         });
     }
 
-    #[test]
+    /* #[test]
     fn p256_point_sum_mixed_test() {
         prefixed_extern! {
             fn p256_point_add_affine(
@@ -1015,7 +1015,7 @@ mod tests {
             p256_point_add_affine,
             test_vector_file!("ops/p256_point_sum_mixed_tests.txt"),
         );
-    }
+    } */
 
     // XXX: There is no `nistz384_point_add_affine()`.
 
@@ -1046,7 +1046,7 @@ mod tests {
         });
     }
 
-    #[test]
+    /* #[test]
     fn p256_point_double_test() {
         prefixed_extern! {
             fn p256_point_double(
@@ -1074,7 +1074,7 @@ mod tests {
             p384_point_double,
             test_vector_file!("ops/p384_point_double_tests.txt"),
         );
-    }
+    } */
 
     fn point_double_test(
         ops: &PrivateKeyOps,
@@ -1102,7 +1102,7 @@ mod tests {
     }
 
     /// TODO: We should be testing `point_mul` with points other than the generator.
-    #[test]
+    /* #[test]
     fn p256_point_mul_test() {
         let generator = (
             Elem::from(&p256::GENERATOR.0),
@@ -1113,9 +1113,9 @@ mod tests {
             |s, cpu| p256::PRIVATE_KEY_OPS.point_mul(s, &generator, cpu),
             test_vector_file!("ops/p256_point_mul_base_tests.txt"),
         );
-    }
+    } */
 
-    /// TODO: We should be testing `point_mul` with points other than the generator.
+    /* /// TODO: We should be testing `point_mul` with points other than the generator.
     #[test]
     fn p384_point_mul_test() {
         let generator = (
@@ -1137,7 +1137,7 @@ mod tests {
             &p256::PUBLIC_KEY_OPS,
             test_vector_file!("ops/p256_point_mul_serialized_tests.txt"),
         );
-    }
+    }*/
 
     fn point_mul_serialized_test(
         priv_ops: &PrivateKeyOps,
@@ -1183,7 +1183,7 @@ mod tests {
         })
     }
 
-    #[test]
+    /* #[test]
     fn p256_point_mul_base_test() {
         point_mul_base_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -1199,7 +1199,7 @@ mod tests {
             |s, cpu| p384::PRIVATE_KEY_OPS.point_mul_base(s, cpu),
             test_vector_file!("ops/p384_point_mul_base_tests.txt"),
         );
-    }
+    }*/
 
     pub(super) fn point_mul_base_tests(
         ops: &PrivateKeyOps,
Index: ring/src/ec/suite_b/public_key.rs
===================================================================
--- ring.orig/src/ec/suite_b/public_key.rs
+++ ring/src/ec/suite_b/public_key.rs
@@ -71,7 +71,7 @@ mod tests {
     use crate::cpu;
     use crate::testutil as test;
 
-    #[test]
+    /* #[test]
     fn parse_uncompressed_point_test() {
         let cpu = cpu::features();
         test::run(
@@ -97,7 +97,7 @@ mod tests {
                 Ok(())
             },
         );
-    }
+    }*/
 
     fn public_key_ops_from_curve_name(curve_name: &str) -> &'static PublicKeyOps {
         if curve_name == "P-256" {
Index: ring/src/rsa/padding.rs
===================================================================
--- ring.orig/src/rsa/padding.rs
+++ ring/src/rsa/padding.rs
@@ -97,7 +97,7 @@ mod test {
     use crate::{digest, error};
     use alloc::vec;
 
-    #[test]
+    /* #[test]
     fn test_pss_padding_verify() {
         test::run(
             test_vector_file!("rsa_pss_padding_tests.txt"),
@@ -132,10 +132,10 @@ mod test {
                 Ok(())
             },
         );
-    }
+    }*/
 
     // Tests PSS encoding for various public modulus lengths.
-    #[cfg(feature = "alloc")]
+    /*#[cfg(feature = "alloc")]
     #[test]
     fn test_pss_padding_encode() {
         test::run(
@@ -173,5 +173,5 @@ mod test {
                 Ok(())
             },
         );
-    }
+    }*/
 }
Index: ring/src/testutil.rs
===================================================================
--- ring.orig/src/testutil.rs
+++ ring/src/testutil.rs
@@ -541,7 +541,7 @@ mod tests {
     use crate::error;
     use crate::testutil as test;
 
-    #[test]
+    /* #[test]
     fn one_ok() {
         test::run(test_vector_file!("test_1_tests.txt"), |_, test_case| {
             let _ = test_case.consume_string("Key");
@@ -565,9 +565,9 @@ mod tests {
             let _ = test_case.consume_string("Key");
             panic!("Oh noes!");
         });
-    }
+    } */
 
-    #[test]
+    /* #[test]
     #[should_panic(expected = "Test failed.")]
     fn first_err() {
         err_one(0)
@@ -636,5 +636,5 @@ mod tests {
             test_vector_file!("test_1_syntax_error_tests.txt"),
             |_, _| Ok(()),
         );
-    }
+    } */
 }
Index: ring/tests/aead_tests.rs
===================================================================
--- ring.orig/tests/aead_tests.rs
+++ ring/tests/aead_tests.rs
@@ -82,11 +82,11 @@ macro_rules! test_aead {
     }
 }
 
-test_aead! {
+/*test_aead! {
     { AES_128_GCM, "aead_aes_128_gcm_tests.txt" },
     { AES_256_GCM, "aead_aes_256_gcm_tests.txt" },
     { CHACHA20_POLY1305, "aead_chacha20_poly1305_tests.txt" },
-}
+}*/
 
 struct KnownAnswerTestCase<'a> {
     key: &'a [u8],
@@ -445,7 +445,7 @@ fn test_aead_nonce_sizes() {
     assert!(aead::Nonce::try_assume_unique_for_key(&nonce[..16]).is_err()); // 128 bits.
 }
 
-#[allow(clippy::range_plus_one)]
+/* #[allow(clippy::range_plus_one)]
 #[test]
 fn aead_chacha20_poly1305_openssh() {
     // TODO: test_aead_key_sizes(...);
@@ -492,7 +492,7 @@ fn aead_chacha20_poly1305_openssh() {
             Ok(())
         },
     );
-}
+} */
 
 #[test]
 fn aead_test_aad_traits() {
Index: ring/tests/agreement_tests.rs
===================================================================
--- ring.orig/tests/agreement_tests.rs
+++ ring/tests/agreement_tests.rs
@@ -72,7 +72,7 @@ fn agreement_traits() {
     assert_eq!(unparsed_public_key.as_ref(), &[0x01, 0x02, 0x03]);
 }
 
-#[test]
+/* #[test]
 fn agreement_agree_ephemeral() {
     let rng = rand::SystemRandom::new();
 
@@ -128,7 +128,7 @@ fn agreement_agree_ephemeral() {
 
         Ok(())
     });
-}
+} */
 
 #[test]
 fn test_agreement_ecdh_x25519_rfc_iterated() {
Index: ring/tests/digest_tests.rs
===================================================================
--- ring.orig/tests/digest_tests.rs
+++ ring/tests/digest_tests.rs
@@ -25,7 +25,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 wasm_bindgen_test_configure!(run_in_browser);
 
 /// Test vectors from BoringSSL, Go, and other sources.
-#[test]
+/* #[test]
 fn digest_misc() {
     test::run(test_file!("digest_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -48,7 +48,7 @@ fn digest_misc() {
 
         Ok(())
     });
-}
+} */
 
 /// Test some ways in which `Context::update` and/or `Context::finish`
 /// could go wrong by testing every combination of updating three inputs
Index: ring/tests/ecdsa_tests.rs
===================================================================
--- ring.orig/tests/ecdsa_tests.rs
+++ ring/tests/ecdsa_tests.rs
@@ -23,7 +23,7 @@ use ring::{test, test_file};
 
 // ECDSA *signing* tests are in src/ec/ecdsa/signing.rs.
 
-#[test]
+/* #[test]
 fn ecdsa_from_pkcs8_test() {
     let rng = rand::SystemRandom::new();
 
@@ -87,7 +87,7 @@ fn ecdsa_from_pkcs8_test() {
             Ok(())
         },
     );
-}
+} */
 
 // Verify that, at least, we generate PKCS#8 documents that we can read.
 #[test]
@@ -113,7 +113,7 @@ fn ecdsa_generate_pkcs8_test() {
     }
 }
 
-#[test]
+/* #[test]
 fn signature_ecdsa_verify_asn1_test() {
     test::run(
         test_file!("ecdsa_verify_asn1_tests.txt"),
@@ -144,7 +144,7 @@ fn signature_ecdsa_verify_asn1_test() {
             Ok(())
         },
     );
-}
+} 
 
 #[test]
 fn signature_ecdsa_verify_fixed_test() {
@@ -178,7 +178,7 @@ fn signature_ecdsa_verify_fixed_test() {
             Ok(())
         },
     );
-}
+} */
 
 #[test]
 fn ecdsa_test_public_key_coverage() {
@@ -217,7 +217,7 @@ fn ecdsa_test_public_key_coverage() {
 // different each time. Because of that, here we simply verify that the
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
-#[test]
+/* #[test]
 fn signature_ecdsa_sign_fixed_sign_and_verify_test() {
     let rng = rand::SystemRandom::new();
 
@@ -264,9 +264,9 @@ fn signature_ecdsa_sign_fixed_sign_and_v
             Ok(())
         },
     );
-}
+} */
 
-// This test is not a known-answer test, though it re-uses the known-answer
+/* // This test is not a known-answer test, though it re-uses the known-answer
 // test vectors. Because the nonce is randomized, the signature will be
 // different each time. Because of that, here we simply verify that the
 // signature verifies correctly. The known-answer tests themselves are in
@@ -318,4 +318,4 @@ fn signature_ecdsa_sign_asn1_test() {
             Ok(())
         },
     );
-}
+}*/
Index: ring/tests/hkdf_tests.rs
===================================================================
--- ring.orig/tests/hkdf_tests.rs
+++ ring/tests/hkdf_tests.rs
@@ -24,7 +24,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 wasm_bindgen_test_configure!(run_in_browser);
 
-#[test]
+/* #[test]
 fn hkdf_tests() {
     test::run(test_file!("hkdf_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -57,7 +57,7 @@ fn hkdf_tests() {
 
         Ok(())
     });
-}
+} */
 
 #[test]
 fn hkdf_output_len_tests() {
Index: ring/tests/hmac_tests.rs
===================================================================
--- ring.orig/tests/hmac_tests.rs
+++ ring/tests/hmac_tests.rs
@@ -24,7 +24,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 wasm_bindgen_test_configure!(run_in_browser);
 
-#[test]
+/*#[test]
 fn hmac_tests() {
     test::run(test_file!("hmac_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -66,7 +66,7 @@ fn hmac_tests() {
 
         Ok(())
     });
-}
+} */
 
 fn hmac_test_case_inner(
     algorithm: hmac::Algorithm,
Index: ring/tests/pbkdf2_tests.rs
===================================================================
--- ring.orig/tests/pbkdf2_tests.rs
+++ ring/tests/pbkdf2_tests.rs
@@ -25,7 +25,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 wasm_bindgen_test_configure!(run_in_browser);
 
-/// Test vectors from BoringSSL, Go, and other sources.
+/* /// Test vectors from BoringSSL, Go, and other sources.
 #[test]
 pub fn pbkdf2_tests() {
     test::run(test_file!("pbkdf2_tests.txt"), |section, test_case| {
@@ -69,4 +69,4 @@ pub fn pbkdf2_tests() {
 
         Ok(())
     });
-}
+} */
Index: ring/tests/quic_tests.rs
===================================================================
--- ring.orig/tests/quic_tests.rs
+++ ring/tests/quic_tests.rs
@@ -18,7 +18,7 @@ use ring::aead::quic;
 #[allow(deprecated)]
 use ring::{test, test_file};
 
-#[test]
+/* #[test]
 fn quic_aes_128() {
     test_quic(&quic::AES_128, test_file!("quic_aes_128_tests.txt"));
 }
@@ -31,7 +31,7 @@ fn quic_aes_256() {
 #[test]
 fn quic_chacha20() {
     test_quic(&quic::CHACHA20, test_file!("quic_chacha20_tests.txt"));
-}
+}*/
 
 fn test_quic(alg: &'static quic::Algorithm, test_file: test::File) {
     test_key_len(alg);
Index: ring/tests/rsa_tests.rs
===================================================================
--- ring.orig/tests/rsa_tests.rs
+++ ring/tests/rsa_tests.rs
@@ -30,7 +30,7 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 wasm_bindgen_test_configure!(run_in_browser);
 
-#[test]
+/* #[test]
 fn rsa_from_pkcs8_test() {
     test::run(
         test_file!("rsa_from_pkcs8_tests.txt"),
@@ -50,9 +50,9 @@ fn rsa_from_pkcs8_test() {
             Ok(())
         },
     );
-}
+} */
 
-#[cfg(feature = "alloc")]
+/* #[cfg(feature = "alloc")]
 #[test]
 fn test_signature_rsa_pkcs1_sign() {
     let rng = rand::SystemRandom::new();
@@ -91,9 +91,9 @@ fn test_signature_rsa_pkcs1_sign() {
             Ok(())
         },
     );
-}
+} */
 
-#[cfg(feature = "alloc")]
+/* #[cfg(feature = "alloc")]
 #[test]
 fn test_signature_rsa_pss_sign() {
     test::run(
@@ -129,7 +129,7 @@ fn test_signature_rsa_pss_sign() {
             Ok(())
         },
     );
-}
+}*/
 
 // `KeyPair::sign` requires that the output buffer is the same length as
 // the public key modulus. Test what happens when it isn't the same length.
@@ -159,7 +159,7 @@ fn test_signature_rsa_pkcs1_sign_output_
     }
 }
 
-#[cfg(feature = "alloc")]
+/* #[cfg(feature = "alloc")]
 #[test]
 fn test_signature_rsa_pkcs1_verify() {
     let sha1_params = &[
@@ -238,9 +238,9 @@ fn test_signature_rsa_pkcs1_verify() {
             Ok(())
         },
     );
-}
+} */
 
-#[cfg(feature = "alloc")]
+/* #[cfg(feature = "alloc")]
 #[test]
 fn test_signature_rsa_pss_verify() {
     test::run(
@@ -285,11 +285,11 @@ fn test_signature_rsa_pss_verify() {
             Ok(())
         },
     );
-}
+} */
 
 // Test for `primitive::verify()`. Read public key parts from a file
 // and use them to verify a signature.
-#[cfg(feature = "alloc")]
+/* #[cfg(feature = "alloc")]
 #[test]
 fn test_signature_rsa_primitive_verification() {
     test::run(
@@ -307,7 +307,7 @@ fn test_signature_rsa_primitive_verifica
             Ok(())
         },
     )
-}
+}*/
 
 #[cfg(feature = "alloc")]
 #[test]
Index: ring/src/ec/suite_b/ecdsa/digest_scalar.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/digest_scalar.rs
+++ ring/src/ec/suite_b/ecdsa/digest_scalar.rs
@@ -71,7 +71,7 @@ mod tests {
     use crate::testutil as test;
     use crate::{cpu, digest, ec::suite_b::ops::*, limb};
 
-    #[test]
+    /*#[test]
     fn test() {
         let cpu = cpu::features();
         test::run(
@@ -115,5 +115,5 @@ mod tests {
                 Ok(())
             },
         );
-    }
+    }*/
 }
Index: ring/src/ec/suite_b/ecdsa/signing.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/signing.rs
+++ ring/src/ec/suite_b/ecdsa/signing.rs
@@ -529,7 +529,7 @@ mod tests {
     use crate::testutil as test;
     use crate::{rand, signature};
 
-    #[test]
+    /*#[test]
     fn signature_ecdsa_sign_fixed_test() {
         let rng = rand::SystemRandom::new();
 
@@ -611,5 +611,5 @@ mod tests {
                 Ok(())
             },
         );
-    }
+    }*/
 }
Index: ring/src/ec/suite_b/ops/p256.rs
===================================================================
--- ring.orig/src/ec/suite_b/ops/p256.rs
+++ ring/src/ec/suite_b/ops/p256.rs
@@ -316,7 +316,7 @@ prefixed_extern! {
     );
 }
 
-#[cfg(test)]
+/*#[cfg(test)]
 mod tests {
     #[cfg(any(
         all(target_arch = "aarch64", target_endian = "little"),
@@ -331,4 +331,4 @@ mod tests {
             test_vector_file!("p256_point_mul_base_tests.txt"),
         );
     }
-}
+}*/
Index: ring/src/rsa/keypair.rs
===================================================================
--- ring.orig/src/rsa/keypair.rs
+++ ring/src/rsa/keypair.rs
@@ -651,7 +651,7 @@ mod tests {
     use crate::testutil as test;
     use alloc::vec;
 
-    #[test]
+    /*#[test]
     fn test_rsakeypair_private_exponentiate() {
         let cpu = cpu::features();
         test::run(
@@ -681,5 +681,5 @@ mod tests {
                 Ok(())
             },
         );
-    }
+    }*/
 }
