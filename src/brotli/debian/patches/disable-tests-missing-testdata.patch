Index: brotli/src/bin/integration_tests.rs
===================================================================
--- brotli.orig/src/bin/integration_tests.rs
+++ brotli/src/bin/integration_tests.rs
@@ -343,7 +343,7 @@ fn total_roundtrip_helper(data: &[u8]) {
     }
     roundtrip_helper(data, 10, 23, true);
 }
-static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
+/*static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
 #[test]
 fn test_random_then_unicode_0() {
     roundtrip_helper(RANDOM_THEN_UNICODE, 0, 13, false);
@@ -392,7 +392,7 @@ fn test_random_then_unicode_8() {
 #[test]
 fn test_random_then_unicode_9() {
     roundtrip_helper(RANDOM_THEN_UNICODE, 9, 22, false);
-}
+}*/
 #[cfg(feature = "std")]
 const random_then_unicode_compressed_size_9_5: usize = 130036;
 #[cfg(feature = "std")]
@@ -422,7 +422,7 @@ const random_then_unicode_compressed_siz
 #[cfg(not(feature = "std"))] // approx log
 const random_then_unicode_compressed_size_9_5x: usize = 129873;
 
-#[cfg(feature="default")]
+/*#[cfg(feature="default")]
 #[test]
 fn test_random_then_unicode_9_5() {
     let c_size = roundtrip_helper(RANDOM_THEN_UNICODE, 10, 28, true);
@@ -434,9 +434,9 @@ fn test_random_then_unicode_9_5() {
 fn test_random_then_unicode_9x5() {
     let c_size = roundtrip_helper(RANDOM_THEN_UNICODE, 11, 22, true);
     assert_eq!(c_size, random_then_unicode_compressed_size_9_5x);
-}
+}*/
 
-#[test]
+/*#[test]
 fn test_alice29_11() {
     let c_size = roundtrip_helper(include_bytes!("../../testdata/alice29.txt"), 11, 22, false);
     if c_size != 46492 {
@@ -464,7 +464,7 @@ fn test_roundtrip_alice29() {
 #[test]
 fn test_roundtrip_as_you_lik() {
     total_roundtrip_helper(include_bytes!("../../testdata/asyoulik.txt"));
-}
+}*/
 
 #[cfg(feature = "std")]
 fn reader_helper(mut in_buf: &[u8], q: u32, lgwin: u32) {
@@ -557,11 +557,11 @@ fn simple_reader_helper(mut in_buf: &[u8
   assert!(compressed_size < original_buf.len() * pct_ratio / 100);
 }
 */
-#[cfg(feature = "std")]
+/*#[cfg(feature = "std")]
 #[test]
 fn test_reader_64x() {
     reader_helper(include_bytes!("../../testdata/64x"), 9, 20);
-}
+}*/
 /*
 #[cfg(feature="std")]
 #[test]
@@ -569,7 +569,7 @@ fn test_simple_64x() {
     bogus_reader_helper(include_bytes!("../../testdata/64x"), 9, 20);
 }*/
 
-#[cfg(feature = "std")]
+/*#[cfg(feature = "std")]
 #[test]
 fn test_reader_as_you_lik() {
     reader_helper(include_bytes!("../../testdata/asyoulik.txt"), 9, 20);
@@ -589,7 +589,7 @@ fn test_reader_random_then_unicode() {
 #[test]
 fn test_reader_alice() {
     reader_helper(include_bytes!("../../testdata/alice29.txt"), 9, 22);
-}
+}*/
 
 #[cfg(feature = "std")]
 fn writer_helper(mut in_buf: &[u8], buf_size: usize, q: u32, lgwin: u32, do_flush: bool) {
@@ -676,7 +676,7 @@ fn into_inner_writer_helper(mut in_buf:
     assert_eq!(output.data.len(), orig_buf.len());
 }
 
-#[cfg(feature = "std")]
+/*#[cfg(feature = "std")]
 #[test]
 fn test_writer_as_you_lik() {
     writer_helper(
@@ -730,7 +730,7 @@ fn test_writer_alice() {
         22,
         true,
     );
-}
+}*/
 
 #[test]
 fn test_10x_10y() {
@@ -988,7 +988,7 @@ fn benchmark_helper<Run: Runner>(
     assert_eq!(&rt.data[..input_slice.len()], input_slice);
 }
 
-fn expand_test_data(size: usize) -> Vec<u8> {
+/*fn expand_test_data(size: usize) -> Vec<u8> {
     let mut ret = vec![0u8; size];
     let original_data = include_bytes!("../../testdata/random_then_unicode");
     let mut count = 0;
@@ -1003,9 +1003,9 @@ fn expand_test_data(size: usize) -> Vec<
         iter += 1;
     }
     ret
-}
+}*/
 
-#[test]
+/*#[test]
 fn test_1024k() {
     let td = expand_test_data(1024 * 1024);
     benchmark_helper(
@@ -1018,16 +1018,16 @@ fn test_1024k() {
         2,
         false,
     );
-}
+}*/
 
-static UKKONOOA: &[u8] = include_bytes!("../../testdata/ukkonooa");
+/*static UKKONOOA: &[u8] = include_bytes!("../../testdata/ukkonooa");
 #[test]
 fn test_ukkonooa() {
     let td = UKKONOOA;
     benchmark_helper(td, 65536, 65536, true, true, &mut Passthrough {}, 11, false);
-}
+}*/
 
-#[cfg(feature = "benchmark")]
+/*#[cfg(feature = "benchmark")]
 #[bench]
 fn bench_e2e_decode_q9_5_1024k(bench: &mut Bencher) {
     let td = expand_test_data(1024 * 1024);
@@ -1137,9 +1137,9 @@ fn bench_e2e_rt_q5_1024k(bench: &mut Ben
         5,
         false,
     );
-}
+}*/
 
-#[test]
+/*#[test]
 fn test_64x() {
     assert_decompressed_input_matches_output(
         include_bytes!("../../testdata/64x.compressed"),
@@ -1399,7 +1399,7 @@ fn test_empty18() {
         65536,
         65536,
     );
-}
+}*/
 
 pub struct SoonErrorReader(&'static [u8], bool);
 impl io::Read for SoonErrorReader {
Index: brotli/src/bin/test_broccoli.rs
===================================================================
--- brotli.orig/src/bin/test_broccoli.rs
+++ brotli/src/bin/test_broccoli.rs
@@ -14,7 +14,7 @@ use super::brotli::enc::BrotliEncoderPar
 use super::integration_tests::UnlimitedBuffer;
 use super::Rebox;
 
-static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
+/*static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
 static ALICE: &[u8] = include_bytes!("../../testdata/alice29.txt");
 static UKKONOOA: &[u8] = include_bytes!("../../testdata/ukkonooa");
 static ASYOULIKE: &[u8] = include_bytes!("../../testdata/asyoulik.txt");
@@ -22,7 +22,7 @@ static BACKWARD65536: &[u8] = include_by
 static DICTWORD: &[u8] = include_bytes!("../../testdata/ends_with_truncated_dictionary");
 static RANDOM10K: &[u8] = include_bytes!("../../testdata/random_org_10k.bin");
 static RANDOMTHENUNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
-static QUICKFOX: &[u8] = include_bytes!("../../testdata/quickfox_repeated");
+static QUICKFOX: &[u8] = include_bytes!("../../testdata/quickfox_repeated");*/
 static EMPTY: &[u8] = &[];
 
 fn concat(
@@ -165,7 +165,7 @@ fn medium_debug_test(params: &mut Brotli
 #[cfg(not(debug_assertions))]
 fn medium_debug_test(_params: &mut BrotliEncoderParams) {}
 
-#[test]
+/*#[test]
 #[should_panic]
 fn test_appendonly_twice_fails() {
     let mut files = [
@@ -407,4 +407,4 @@ fn test_concat() {
     }
     concat_many_subsets(&mut files[..], &mut ufiles[..], None);
     concat_many_subsets(&mut files[..], &mut ufiles[..], Some(28)); // FIXME: make this 28
-}
+}*/
Index: brotli/src/bin/test_custom_dict.rs
===================================================================
--- brotli.orig/src/bin/test_custom_dict.rs
+++ brotli/src/bin/test_custom_dict.rs
@@ -12,8 +12,8 @@ use super::brotli::enc::BrotliEncoderPar
 use super::integration_tests::UnlimitedBuffer;
 use super::Rebox;
 
-static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
-static ALICE: &[u8] = include_bytes!("../../testdata/alice29.txt");
+/*static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
+static ALICE: &[u8] = include_bytes!("../../testdata/alice29.txt");*/
 
 #[test]
 fn test_custom_dict_minimal() {
@@ -107,7 +107,7 @@ fn test_custom_dict_medium() {
 }
 
 
-#[test]
+/*#[test]
 fn test_custom_dict_alice() {
     let mut raw = UnlimitedBuffer::new(ALICE);
     let mut params = BrotliEncoderParams::default();
@@ -314,4 +314,4 @@ fn test_custom_dict_for_multithreading()
     if output.data().len() != 48568 {
         assert_eq!(output.data().len(), 48563); // as opposed to 46487 with standard settings
     }
-}
+}*/
Index: brotli/src/bin/test_threading.rs
===================================================================
--- brotli.orig/src/bin/test_threading.rs
+++ brotli/src/bin/test_threading.rs
@@ -15,8 +15,8 @@ use super::brotli::enc::{
 use super::integration_tests::UnlimitedBuffer;
 use super::{new_brotli_heap_alloc, Rebox};
 
-static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
-static ALICE: &[u8] = include_bytes!("../../testdata/alice29.txt");
+/*static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../testdata/random_then_unicode");
+static ALICE: &[u8] = include_bytes!("../../testdata/alice29.txt");*/
 
 struct SliceRef<'a>(&'a [u8]);
 impl<'a> SliceWrapper<u8> for SliceRef<'a> {
@@ -88,7 +88,7 @@ fn multi_threaded_split_compression_test
     }
     assert_eq!(rt.data(), input_data);
 }
-#[test]
+/*#[test]
 fn multi_threaded_split_compression_test_1() {
     multi_threaded_split_compression_test(RANDOM_THEN_UNICODE, 1, 3, false, 155808)
 }
@@ -115,7 +115,7 @@ fn multi_threaded_split_compression_test
 #[test]
 fn multi_threaded_split_compression_test_1b5() {
     multi_threaded_split_compression_test(&RANDOM_THEN_UNICODE[..1], 5, 9, false, 139125)
-}
+}*/
 
 #[test]
 fn multi_threaded_split_compression_test_0b1() {
@@ -190,7 +190,7 @@ fn thread_spawn_per_job_split_compressio
     }
     assert_eq!(rt.data(), input_data);
 }
-#[test]
+/*#[test]
 fn thread_spawn_per_job_split_compression_test_1() {
     thread_spawn_per_job_split_compression_test(RANDOM_THEN_UNICODE, 1, 3, false, 155808)
 }
@@ -205,7 +205,7 @@ fn thread_spawn_per_job_split_compressio
 #[test]
 fn thread_spawn_per_job_split_compression_test_1b3() {
     thread_spawn_per_job_split_compression_test(&RANDOM_THEN_UNICODE[..1], 3, 5, false, 144325)
-}
+}*/
 #[test]
 fn thread_spawn_per_job_split_compression_test_0b1() {
     thread_spawn_per_job_split_compression_test(&[], 1, 3, false, 155808)
Index: brotli/src/bin/tests.rs
===================================================================
--- brotli.orig/src/bin/tests.rs
+++ brotli/src/bin/tests.rs
@@ -95,7 +95,7 @@ fn test_10x_10y() {
     assert_eq!(output.data.len(), 20);
 }
 
-#[test]
+/*#[test]
 fn test_alice() {
     let in_buf = include_bytes!("../../testdata/alice29.txt.compressed");
 
@@ -112,4 +112,4 @@ fn test_alice() {
         i += 1;
     }
     assert_eq!(truth.len(), output.data.len());
-}
+}*/
Index: brotli/src/enc/backward_references/test.rs
===================================================================
--- brotli.orig/src/enc/backward_references/test.rs
+++ brotli/src/enc/backward_references/test.rs
@@ -9,7 +9,7 @@ use super::{
 use crate::enc::combined_alloc::allocate;
 use crate::enc::{Allocator, SliceWrapper};
 
-static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../../testdata/random_then_unicode"); //&[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55];
+//static RANDOM_THEN_UNICODE: &[u8] = include_bytes!("../../../testdata/random_then_unicode"); //&[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55];
 
 #[cfg(feature = "std")]
 #[test]
@@ -64,7 +64,7 @@ fn test_bulk_store_range() {
     };
     let mut hasher_d = hasher_c.clone_with_alloc(&mut alloc);
     assert!(hasher_d == hasher_c);
-    hasher_a.BulkStoreRange(
+    /*hasher_a.BulkStoreRange(
         RANDOM_THEN_UNICODE,
         usize::MAX,
         15,
@@ -108,7 +108,7 @@ fn test_bulk_store_range() {
     assert_eq!(hasher_c.num.slice(), hasher_d.num.slice());
     assert!(hasher_a == hasher_b);
     assert!(hasher_d == hasher_c);
-    assert!(hasher_a == hasher_e);
+    assert!(hasher_a == hasher_e);*/
 }
 #[cfg(feature = "std")]
 #[test]
@@ -163,7 +163,7 @@ fn test_bulk_store_range_off_spec() {
     };
     let mut hasher_d = hasher_c.clone_with_alloc(&mut alloc);
     assert!(hasher_d == hasher_c);
-    hasher_a.BulkStoreRange(
+    /*hasher_a.BulkStoreRange(
         RANDOM_THEN_UNICODE,
         0x0fff,
         15,
@@ -190,7 +190,7 @@ fn test_bulk_store_range_off_spec() {
     assert_eq!(hasher_a.num.slice(), hasher_c.num.slice());
     assert_eq!(hasher_b.num.slice(), hasher_d.num.slice());
     assert!(hasher_a == hasher_b);
-    assert!(hasher_d == hasher_c);
+    assert!(hasher_d == hasher_c);*/
 }
 
 #[cfg(feature = "std")]
@@ -246,7 +246,7 @@ fn test_bulk_store_range_pow2() {
     };
     let mut hasher_d = hasher_c.clone_with_alloc(&mut alloc);
     assert!(hasher_d == hasher_c);
-    hasher_a.BulkStoreRange(
+    /*hasher_a.BulkStoreRange(
         RANDOM_THEN_UNICODE,
         usize::MAX,
         RANDOM_THEN_UNICODE.len() - 64 - 3,
@@ -290,5 +290,5 @@ fn test_bulk_store_range_pow2() {
     assert_eq!(hasher_c.num.slice(), hasher_d.num.slice());
     assert!(hasher_a == hasher_b);
     assert!(hasher_d == hasher_c);
-    assert!(hasher_a == hasher_e);
+    assert!(hasher_a == hasher_e);*/
 }
Index: brotli/src/enc/encode.rs
===================================================================
--- brotli.orig/src/enc/encode.rs
+++ brotli/src/enc/encode.rs
@@ -3033,7 +3033,7 @@ mod test {
     #[cfg(test)]
     use alloc_stdlib::StandardAlloc;
 
-    #[test]
+    /*#[test]
     fn test_encoder_compress() {
         let input = include_bytes!("../../testdata/alice29.txt");
         let mut output_buffer = [0; 100000];
@@ -3059,5 +3059,5 @@ mod test {
         );
         assert_eq!(roundtrip[..t], input[..]);
         assert_eq!(s, output_len);
-    }
+    }*/
 }
Index: brotli/src/enc/test.rs
===================================================================
--- brotli.orig/src/enc/test.rs
+++ brotli/src/enc/test.rs
@@ -382,7 +382,7 @@ macro_rules! test_roundtrip_file {
     }};
 }
 
-#[cfg(not(all(target_arch = "arm", target_pointer_width = "32")))]
+/*#[cfg(not(all(target_arch = "arm", target_pointer_width = "32")))]
 #[test]
 fn test_roundtrip_64x() {
     test_roundtrip_file!(include_bytes!("../../testdata/64x"), 72, 9, 10, false, 3, 2);
@@ -548,7 +548,7 @@ fn test_roundtrip_quickfox() {
         1,
         2
     );
-}
+}*/
 
 #[cfg(not(all(target_arch = "arm", target_pointer_width = "32")))]
 #[test]
