diff --git a/src/asn1_types/integer.rs b/src/asn1_types/integer.rs
index e2da928..f638e81 100644
--- a/src/asn1_types/integer.rs
+++ b/src/asn1_types/integer.rs
@@ -276,7 +276,8 @@ impl_int!(u128 => i128);
 ///
 /// Encoding an `Integer` to DER
 ///
-/// ```
+#[cfg_attr(feature = "std", doc = r#"```"#)]
+#[cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 /// use asn1_rs::{Integer, ToDer};
 ///
 /// let i = Integer::from(4);
@@ -576,7 +577,7 @@ macro_rules! int {
     };
 }
 
-#[cfg(test)]
+#[cfg(all(test, feature = "std"))]
 mod tests {
     use crate::{Any, FromDer, Header, Tag, ToDer};
     use std::convert::TryInto;
diff --git a/src/asn1_types/oid.rs b/src/asn1_types/oid.rs
index 3e1022e..cef1eb7 100644
--- a/src/asn1_types/oid.rs
+++ b/src/asn1_types/oid.rs
@@ -464,7 +464,7 @@ macro_rules! oid {
     };
 }
 
-#[cfg(test)]
+#[cfg(all(test, feature = "std"))]
 mod tests {
     use crate::{FromDer, Oid, ToDer};
     use hex_literal::hex;
diff --git a/src/asn1_types/sequence.rs b/src/asn1_types/sequence.rs
index 6c9f3a9..a0228cd 100644
--- a/src/asn1_types/sequence.rs
+++ b/src/asn1_types/sequence.rs
@@ -28,7 +28,8 @@ pub use sequence_of::*;
 /// - if the sequence is composed of objects of the same type, the [`Sequence::from_iter_to_der`] method can be used
 /// - otherwise, the [`ToDer`] trait can be used to create content incrementally
 ///
-/// ```
+#[cfg_attr(feature = "std", doc = r#"```"#)]
+#[cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 /// use asn1_rs::{Integer, Sequence, SerializeResult, ToDer};
 ///
 /// fn build_seq<'a>() -> SerializeResult<Sequence<'a>> {
@@ -48,7 +49,8 @@ pub use sequence_of::*;
 ///
 /// # Examples
 ///
-/// ```
+#[cfg_attr(feature = "std", doc = r#"```"#)]
+#[cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 /// use asn1_rs::{Error, Sequence};
 ///
 /// // build sequence
diff --git a/src/asn1_types/set.rs b/src/asn1_types/set.rs
index 348b23b..924c45e 100644
--- a/src/asn1_types/set.rs
+++ b/src/asn1_types/set.rs
@@ -29,7 +29,8 @@ pub use set_of::*;
 /// - if the set is composed of objects of the same type, the [`Set::from_iter_to_der`] method can be used
 /// - otherwise, the [`ToDer`] trait can be used to create content incrementally
 ///
-/// ```
+#[cfg_attr(feature = "std", doc = r#"```"#)]
+#[cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 /// use asn1_rs::{Integer, Set, SerializeResult, ToDer};
 ///
 /// fn build_set<'a>() -> SerializeResult<Set<'a>> {
@@ -49,7 +50,8 @@ pub use set_of::*;
 ///
 /// # Examples
 ///
-/// ```
+#[cfg_attr(feature = "std", doc = r#"```"#)]
+#[cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 /// use asn1_rs::{Error, Set};
 ///
 /// // build set
diff --git a/src/asn1_types/set/btreeset.rs b/src/asn1_types/set/btreeset.rs
index c077f05..c3fe482 100644
--- a/src/asn1_types/set/btreeset.rs
+++ b/src/asn1_types/set/btreeset.rs
@@ -108,7 +108,7 @@ where
     }
 }
 
-#[cfg(test)]
+#[cfg(all(test, feature = "std"))]
 mod tests {
     use crate::*;
     use core::convert::TryFrom;
diff --git a/src/class.rs b/src/class.rs
index 9a4f9de..f8f3f7c 100644
--- a/src/class.rs
+++ b/src/class.rs
@@ -67,7 +67,7 @@ impl TryFrom<u8> for Class {
     }
 }
 
-#[cfg(test)]
+#[cfg(all(test, feature = "std"))]
 mod tests {
     use super::*;
 
diff --git a/src/derive.rs b/src/derive.rs
index 9fa1672..58c7f97 100644
--- a/src/derive.rs
+++ b/src/derive.rs
@@ -375,7 +375,8 @@ pub use asn1_rs_derive::ToStatic;
 ///
 /// Define a structure and add the `DerSequence` derive:
 ///
-/// ```rust
+#[cfg_attr(feature = "std", doc = r#"```rust"#)]
+#[cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 /// use asn1_rs::*;
 ///
 /// #[derive(DerSequence, ToDerSequence)]
diff --git a/src/doc/mod.rs b/src/doc/mod.rs
index 4c95a87..5b1543e 100644
--- a/src/doc/mod.rs
+++ b/src/doc/mod.rs
@@ -3,6 +3,7 @@
 #[doc = include_str!("../../doc/RECIPES.md")]
 pub mod recipes {}
 
+#[cfg(feature = "std")]
 #[doc = include_str!("../../doc/DERIVE.md")]
 pub mod derive {}
 
diff --git a/src/header.rs b/src/header.rs
index 24f8e26..605de39 100644
--- a/src/header.rs
+++ b/src/header.rs
@@ -452,7 +452,7 @@ impl<'a> PartialEq<Header<'a>> for Header<'a> {
 
 impl Eq for Header<'_> {}
 
-#[cfg(test)]
+#[cfg(all(test, feature = "std"))]
 mod tests {
     use crate::*;
     use hex_literal::hex;
diff --git a/src/lib.rs b/src/lib.rs
index 690e9fc..e62f006 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -101,7 +101,8 @@
 //!
 //! Writing 2 BER integers:
 //!
-//! ```rust
+#![cfg_attr(feature = "std", doc = r#"```rust"#)]
+#![cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 //! use asn1_rs::{Integer, ToDer};
 //!
 //! let mut writer = Vec::new();
@@ -120,7 +121,8 @@
 //!
 //! Similarly to `FromBer`/`FromDer`, serialization methods are also implemented for primitive types:
 //!
-//! ```rust
+#![cfg_attr(feature = "std", doc = r#"```rust"#)]
+#![cfg_attr(not(feature = "std"), doc = r#"```rust,compile_fail"#)]
 //! use asn1_rs::ToDer;
 //!
 //! let mut writer = Vec::new();
