--- a/src/blocking/proxy/mod.rs
+++ b/src/blocking/proxy/mod.rs
@@ -520,6 +520,7 @@
 
     #[test]
     #[timeout(15000)]
+    #[ignore]
     fn signal() {
         // Register a well-known name with the session bus and ensure we get the appropriate
         // signals called for that.
--- a/src/connection/mod.rs
+++ b/src/connection/mod.rs
@@ -1397,6 +1397,7 @@
     }
 
     #[test]
+    #[ignore]
     #[timeout(15000)]
     fn disconnect_on_drop() {
         // Reproducer for https://github.com/dbus2/zbus/issues/308 where setting up the
@@ -1441,6 +1442,7 @@
     }
 
     #[tokio::test(start_paused = true)]
+    #[ignore]
     #[timeout(15000)]
     async fn test_graceful_shutdown() {
         // If we have a second reference, it should wait until we drop it.
--- a/src/fdo/mod.rs
+++ b/src/fdo/mod.rs
@@ -63,6 +63,7 @@
     }
 
     #[test]
+    #[ignore]
     #[timeout(15000)]
     fn signal() {
         // Multi-threaded scheduler.
@@ -133,6 +134,7 @@
     }
 
     #[test]
+    #[ignore]
     #[timeout(15000)]
     fn no_object_manager_signals_before_hello() {
         crate::block_on(no_object_manager_signals_before_hello_async());
--- a/src/proxy/builder.rs
+++ b/src/proxy/builder.rs
@@ -164,6 +164,7 @@
     use test_log::test;
 
     #[test]
+    #[ignore]
     #[ntest::timeout(15000)]
     fn builder() {
         crate::utils::block_on(builder_async());
--- a/src/proxy/mod.rs
+++ b/src/proxy/mod.rs
@@ -1373,6 +1373,7 @@
     use test_log::test;
 
     #[test]
+    #[ignore]
     #[timeout(15000)]
     fn signal() {
         block_on(test_signal()).unwrap();
@@ -1441,6 +1442,7 @@
     }
 
     #[test]
+    #[ignore]
     #[timeout(15000)]
     fn signal_stream_deadlock() {
         block_on(test_signal_stream_deadlock()).unwrap();
--- a/tests/basic.rs
+++ b/tests/basic.rs
@@ -33,6 +33,7 @@
 }
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 #[instrument]
 #[cfg(feature = "blocking-api")]
@@ -61,6 +62,7 @@
 }
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn basic_connection_async() {
     block_on(test_basic_connection()).unwrap();
@@ -90,6 +92,7 @@
 
 #[cfg(all(unix, not(target_os = "macos")))]
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn fdpass_systemd() {
     zbus::block_on(fdpass_systemd_async());
@@ -119,6 +122,7 @@
 }
 
 #[test]
+#[ignore]
 #[instrument]
 #[timeout(15000)]
 #[cfg(feature = "blocking-api")]
@@ -220,6 +224,7 @@
 }
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn freedesktop_api_async() {
     block_on(test_freedesktop_api()).unwrap();
@@ -326,6 +331,7 @@
 
 #[cfg(unix)]
 #[tokio::test]
+#[ignore]
 #[timeout(15000)]
 #[instrument]
 async fn test_freedesktop_credentials() -> Result<()> {
--- a/tests/e2e.rs
+++ b/tests/e2e.rs
@@ -507,7 +507,7 @@
     assert_eq!(**address.get("address").unwrap(), Value::from("127.0.0.1"));
     assert_eq!(**address.get("prefix").unwrap(), Value::from(1234u32));
 }
-
+/*
 #[instrument]
 async fn my_iface_test(conn: Connection, event: Event) -> zbus::Result<u32> {
     debug!("client side starting..");
@@ -873,8 +873,8 @@
 
     proxy.quit().await?;
     Ok(val)
-}
-
+}*/
+/*
 #[test]
 #[timeout(15000)]
 fn iface_and_proxy() {
@@ -887,8 +887,9 @@
 #[timeout(15000)]
 fn iface_and_proxy_unix_p2p() {
     block_on(iface_and_proxy_(true));
-}
+}*/
 
+/*
 #[instrument]
 async fn iface_and_proxy_(#[allow(unused)] p2p: bool) {
     let event = event_listener::Event::new();
@@ -1094,4 +1095,4 @@
         Ok(false)
     );
     debug!("Bus confirmed that all names were definitely released.");
-}
+}*/
--- a/tests/issue/issue_1015.rs
+++ b/tests/issue/issue_1015.rs
@@ -25,6 +25,7 @@
 
 #[instrument]
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn issue_1015() {
     // Reproducer for issue #1015, where a regression from signature overhaul caused inconsistency
--- a/tests/issue/issue_104.rs
+++ b/tests/issue/issue_104.rs
@@ -10,6 +10,7 @@
 };
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn issue104() {
     // Tests the fix for https://github.com/dbus2/zbus/issues/104
--- a/tests/issue/issue_122.rs
+++ b/tests/issue/issue_122.rs
@@ -10,6 +10,7 @@
 };
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn issue_122() {
     let conn = blocking::Connection::session().unwrap();
--- a/tests/issue/issue_173.rs
+++ b/tests/issue/issue_173.rs
@@ -8,6 +8,7 @@
 use zbus::object_server::SignalEmitter;
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn issue_173() {
     // Tests the fix for https://github.com/dbus2/zbus/issues/173
--- a/tests/issue/issue_260.rs
+++ b/tests/issue/issue_260.rs
@@ -4,6 +4,7 @@
 use zbus::{block_on, Connection, Result};
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn issue_260() {
     // Low-level server example in the book doesn't work. The reason was that
--- a/tests/issue/issue_310.rs
+++ b/tests/issue/issue_310.rs
@@ -6,6 +6,7 @@
 use zvariant::OwnedObjectPath;
 
 #[test(tokio::test(flavor = "multi_thread"))]
+#[ignore]
 #[instrument]
 async fn issue_310() {
     // The issue was we were deadlocking on fetching the new property value after invalidation.
--- a/tests/issue/issue_68.rs
+++ b/tests/issue/issue_68.rs
@@ -5,6 +5,7 @@
 use zbus::{message::Message, names::UniqueName, Connection, MessageStream};
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn issue_68() {
     // Tests the fix for https://github.com/dbus2/zbus/issues/68
--- a/tests/issue/issue_799.rs
+++ b/tests/issue/issue_799.rs
@@ -7,6 +7,7 @@
 
 #[instrument]
 #[test]
+#[ignore]
 fn concurrent_interface_methods() {
     // This is  test case for ensuring the regression of #799 doesn't come back.
     block_on(async {
--- a/tests/uncached_propert.rs
+++ b/tests/uncached_propert.rs
@@ -5,6 +5,7 @@
 use zbus::Result;
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn uncached_property() {
     block_on(test_uncached_property()).unwrap();
--- a/tests/unixexec.rs
+++ b/tests/unixexec.rs
@@ -4,6 +4,7 @@
 use zbus::{block_on, conn::Builder, Result};
 
 #[test]
+#[ignore]
 #[timeout(15000)]
 fn unixexec_connection_async() {
     block_on(test_unixexec_connection()).unwrap();
