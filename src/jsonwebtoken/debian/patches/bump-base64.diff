From 968a10a84d359e6b30ba6a61ab4efce173c1cc45 Mon Sep 17 00:00:00 2001
From: Alexey <Alexey.N.Chernyshov@gmail.com>
Date: Sat, 21 Jan 2023 22:58:17 +0300
Subject: [PATCH] Update base64 to 0.21.0 (#278)

* chore: update base64 to 0.21.0
---
 Cargo.toml           | 2 +-
 src/decoding.rs      | 3 ++-
 src/encoding.rs      | 3 ++-
 src/header.rs        | 5 ++++-
 src/jwk.rs           | 4 ++--
 src/serialization.rs | 5 +++--
 tests/header/mod.rs  | 3 ++-
 7 files changed, 16 insertions(+), 9 deletions(-)

Index: jsonwebtoken/Cargo.toml
===================================================================
--- jsonwebtoken.orig/Cargo.toml
+++ jsonwebtoken/Cargo.toml
@@ -39,7 +39,7 @@ name = "jwt"
 harness = false
 
 [dependencies.base64]
-version = "0.13"
+version = "0.21"
 
 [dependencies.pem]
 version = "1"
Index: jsonwebtoken/src/decoding.rs
===================================================================
--- jsonwebtoken.orig/src/decoding.rs
+++ jsonwebtoken/src/decoding.rs
@@ -1,3 +1,4 @@
+use base64::{engine::general_purpose::STANDARD, Engine};
 use serde::de::DeserializeOwned;
 
 use crate::algorithms::AlgorithmFamily;
@@ -56,7 +57,7 @@ impl DecodingKey {
 
     /// If you're using HMAC with a base64 encoded secret, use this.
     pub fn from_base64_secret(secret: &str) -> Result<Self> {
-        let out = base64::decode(secret)?;
+        let out = STANDARD.decode(secret)?;
         Ok(DecodingKey { family: AlgorithmFamily::Hmac, kind: DecodingKeyKind::SecretOrDer(out) })
     }
 
Index: jsonwebtoken/src/encoding.rs
===================================================================
--- jsonwebtoken.orig/src/encoding.rs
+++ jsonwebtoken/src/encoding.rs
@@ -1,3 +1,4 @@
+use base64::{engine::general_purpose::STANDARD, Engine};
 use serde::ser::Serialize;
 
 use crate::algorithms::AlgorithmFamily;
@@ -24,7 +25,7 @@ impl EncodingKey {
 
     /// If you have a base64 HMAC secret, use that.
     pub fn from_base64_secret(secret: &str) -> Result<Self> {
-        let out = base64::decode(secret)?;
+        let out = STANDARD.decode(secret)?;
         Ok(EncodingKey { family: AlgorithmFamily::Hmac, content: out })
     }
 
Index: jsonwebtoken/src/header.rs
===================================================================
--- jsonwebtoken.orig/src/header.rs
+++ jsonwebtoken/src/header.rs
@@ -1,5 +1,6 @@
 use std::result;
 
+use base64::{engine::general_purpose::STANDARD, Engine};
 use serde::{Deserialize, Serialize};
 
 use crate::algorithms::Algorithm;
@@ -93,7 +94,9 @@ impl Header {
         Ok(self
             .x5c
             .as_ref()
-            .map(|b64_certs| b64_certs.iter().map(base64::decode).collect::<result::Result<_, _>>())
+            .map(|b64_certs| {
+                b64_certs.iter().map(|x| STANDARD.decode(x)).collect::<result::Result<_, _>>()
+            })
             .transpose()?)
     }
 }
Index: jsonwebtoken/src/jwk.rs
===================================================================
--- jsonwebtoken.orig/src/jwk.rs
+++ jsonwebtoken/src/jwk.rs
@@ -370,13 +370,13 @@ impl JwkSet {
 #[cfg(test)]
 mod tests {
     use crate::jwk::{AlgorithmParameters, JwkSet, OctetKeyType};
+    use crate::serialization::b64_encode;
     use crate::Algorithm;
     use serde_json::json;
 
     #[test]
     fn check_hs256() {
-        let key =
-            base64::encode_config("abcdefghijklmnopqrstuvwxyz012345", base64::URL_SAFE_NO_PAD);
+        let key = b64_encode("abcdefghijklmnopqrstuvwxyz012345");
         let jwks_json = json!({
             "keys": [
                 {
Index: jsonwebtoken/src/serialization.rs
===================================================================
--- jsonwebtoken.orig/src/serialization.rs
+++ jsonwebtoken/src/serialization.rs
@@ -1,13 +1,14 @@
+use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};
 use serde::{Deserialize, Serialize};
 
 use crate::errors::Result;
 
 pub(crate) fn b64_encode<T: AsRef<[u8]>>(input: T) -> String {
-    base64::encode_config(input, base64::URL_SAFE_NO_PAD)
+    URL_SAFE_NO_PAD.encode(input)
 }
 
 pub(crate) fn b64_decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>> {
-    base64::decode_config(input, base64::URL_SAFE_NO_PAD).map_err(|e| e.into())
+    URL_SAFE_NO_PAD.decode(input).map_err(|e| e.into())
 }
 
 /// Serializes a struct to JSON and encodes it in base64
Index: jsonwebtoken/tests/header/mod.rs
===================================================================
--- jsonwebtoken.orig/tests/header/mod.rs
+++ jsonwebtoken/tests/header/mod.rs
@@ -1,3 +1,4 @@
+use base64::{engine::general_purpose::STANDARD, Engine};
 use jsonwebtoken::Header;
 
 static CERT_CHAIN: [&str; 3] = include!("cert_chain.json");
@@ -14,7 +15,7 @@ fn x5c_der_empty_chain() {
 #[test]
 fn x5c_der_valid_chain() {
     let der_chain: Vec<Vec<u8>> =
-        CERT_CHAIN.iter().map(base64::decode).collect::<Result<_, _>>().unwrap();
+        CERT_CHAIN.iter().map(|x| STANDARD.decode(x)).collect::<Result<_, _>>().unwrap();
 
     let x5c = Some(CERT_CHAIN.iter().map(ToString::to_string).collect());
     let header = Header { x5c, ..Default::default() };
