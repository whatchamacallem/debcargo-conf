diff --git a/Cargo.toml b/Cargo.toml
index fe69893..72d084b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -27,9 +27,6 @@ resolver = "2"
 name = "lsd"
 path = "src/main.rs"
 
-[dependencies.bitflags]
-version = "=1.2.1"
-
 [dependencies.chrono]
 version = "0.4.*"
 
@@ -37,7 +34,7 @@ version = "0.4.*"
 version = "0.1.*"
 
 [dependencies.clap]
-version = "2.33.*"
+version = "3.2.16"
 features = [
     "suggestions",
     "color",
@@ -45,7 +42,7 @@ features = [
 ]
 
 [dependencies.crossterm]
-version = "0.21.0"
+version = "0.24.0"
 features = ["serde"]
 
 [dependencies.dirs]
@@ -107,7 +104,10 @@ version = "0.5"
 version = "3"
 
 [build-dependencies.clap]
-version = "2.33.*"
+version = "3.2.16"
+
+[build-dependencies.clap_complete]
+version = "3.2.4"
 
 [build-dependencies.version_check]
 version = "0.9.*"
diff --git a/build.rs b/build.rs
index c72b4db..918f457 100644
--- a/build.rs
+++ b/build.rs
@@ -6,37 +6,34 @@
 // notice may not be copied, modified, or distributed except
 // according to those terms.
 
-#[macro_use]
 extern crate clap;
 extern crate version_check;
 
-use clap::Shell;
+use clap_complete::generate_to;
+use clap_complete::shells::*;
 use std::fs;
-use std::io::{self, Write};
 use std::process::exit;
 
 include!("src/app.rs");
 
 fn main() {
-    match version_check::is_min_version("1.43.1") {
-        Some(true) => {}
-        // rustc version too small or can't figure it out
-        _ => {
-            writeln!(&mut io::stderr(), "'lsd' requires rustc >= 1.43.1").unwrap();
-            exit(1);
-        }
+    // rustc version too small or can't figure it out
+    if version_check::is_min_version("1.62.0") != Some(true) {
+        eprintln!("'lsd' requires rustc >= 1.62.0");
+        exit(1);
     }
 
-    let var = std::env::var_os("SHELL_COMPLETIONS_DIR").or_else(|| std::env::var_os("OUT_DIR"));
-    let outdir = match var {
-        None => return,
-        Some(outdir) => outdir,
-    };
+    let outdir = std::env::var_os("SHELL_COMPLETIONS_DIR")
+        .or_else(|| std::env::var_os("OUT_DIR"))
+        .unwrap_or_else(|| exit(0));
+
     fs::create_dir_all(&outdir).unwrap();
 
     let mut app = build();
-    app.gen_completions("lsd", Shell::Bash, &outdir);
-    app.gen_completions("lsd", Shell::Fish, &outdir);
-    app.gen_completions("lsd", Shell::Zsh, &outdir);
-    app.gen_completions("lsd", Shell::PowerShell, &outdir);
+    let bin_name = "lsd";
+    generate_to(Bash, &mut app, bin_name, &outdir).expect("Failed to generate Bash completions");
+    generate_to(Fish, &mut app, bin_name, &outdir).expect("Failed to generate Fish completions");
+    generate_to(Zsh, &mut app, bin_name, &outdir).expect("Failed to generate Zsh completions");
+    generate_to(PowerShell, &mut app, bin_name, &outdir)
+        .expect("Failed to generate PowerShell completions");
 }
diff --git a/src/app.rs b/src/app.rs
index ddfcbc0..29909eb 100644
--- a/src/app.rs
+++ b/src/app.rs
@@ -1,24 +1,24 @@
 use clap::{App, Arg};
 
-pub fn build() -> App<'static, 'static> {
+pub fn build() -> App<'static> {
     App::new("lsd")
-        .version(crate_version!())
-        .about(crate_description!())
+        .version(env!("CARGO_PKG_VERSION"))
+        .about(env!("CARGO_PKG_DESCRIPTION"))
         .arg(Arg::with_name("FILE").multiple(true).default_value("."))
         .arg(
             Arg::with_name("all")
-                .short("a")
+                .short('a')
                 .overrides_with("almost-all")
                 .long("all")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Do not ignore entries starting with ."),
         )
         .arg(
             Arg::with_name("almost-all")
-                .short("A")
+                .short('A')
                 .overrides_with("all")
                 .long("almost-all")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Do not list implied . and .."),
         )
         .arg(
@@ -28,7 +28,8 @@ pub fn build() -> App<'static, 'static> {
                 .possible_value("auto")
                 .possible_value("never")
                 .default_value("auto")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("When to use terminal colours"),
         )
@@ -39,7 +40,8 @@ pub fn build() -> App<'static, 'static> {
                 .possible_value("auto")
                 .possible_value("never")
                 .default_value("auto")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("When to print the icons"),
         )
@@ -49,22 +51,23 @@ pub fn build() -> App<'static, 'static> {
                 .possible_value("fancy")
                 .possible_value("unicode")
                 .default_value("fancy")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("Whether to use fancy or unicode icons"),
         )
         .arg(
             Arg::with_name("indicators")
-                .short("F")
+                .short('F')
                 .long("classify")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Append indicator (one of */=>@|) at the end of the file names"),
         )
         .arg(
             Arg::with_name("long")
-                .short("l")
+                .short('l')
                 .long("long")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Display extended file metadata as a table"),
         )
         .arg(
@@ -81,44 +84,44 @@ pub fn build() -> App<'static, 'static> {
         )
         .arg(
             Arg::with_name("oneline")
-                .short("1")
+                .short('1')
                 .long("oneline")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Display one entry per line"),
         )
         .arg(
             Arg::with_name("recursive")
-                .short("R")
+                .short('R')
                 .long("recursive")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .conflicts_with("tree")
                 .help("Recurse into directories"),
         )
         .arg(
             Arg::with_name("human_readable")
-                .short("h")
+                .short('h')
                 .long("human-readable")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("For ls compatibility purposes ONLY, currently set by default"),
         )
         .arg(
             Arg::with_name("tree")
                 .long("tree")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .conflicts_with("recursive")
                 .help("Recurse into directories and present the result as a tree"),
         )
         .arg(
             Arg::with_name("depth")
                 .long("depth")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .takes_value(true)
                 .value_name("num")
                 .help("Stop recursing into directories after reaching specified depth"),
         )
         .arg(
             Arg::with_name("directory-only")
-                .short("d")
+                .short('d')
                 .long("directory-only")
                 .conflicts_with("depth")
                 .conflicts_with("recursive")
@@ -130,7 +133,8 @@ pub fn build() -> App<'static, 'static> {
                 .default_value("rwx")
                 .possible_value("rwx")
                 .possible_value("octal")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("How to display permissions"),
         )
@@ -141,14 +145,15 @@ pub fn build() -> App<'static, 'static> {
                 .possible_value("short")
                 .possible_value("bytes")
                 .default_value("default")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("How to display size"),
         )
         .arg(
             Arg::with_name("total-size")
                 .long("total-size")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Display the total size of directories"),
         )
         .arg(
@@ -156,51 +161,52 @@ pub fn build() -> App<'static, 'static> {
                 .long("date")
                 .validator(validate_date_argument)
                 .default_value("date")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("How to display date [possible values: date, relative, +date-time-format]"),
         )
         .arg(
             Arg::with_name("timesort")
-                .short("t")
+                .short('t')
                 .long("timesort")
                 .overrides_with("sizesort")
                 .overrides_with("extensionsort")
                 .overrides_with("versionsort")
                 .overrides_with("sort")
                 .overrides_with("no-sort")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Sort by time modified"),
         )
         .arg(
             Arg::with_name("sizesort")
-                .short("S")
+                .short('S')
                 .long("sizesort")
                 .overrides_with("timesort")
                 .overrides_with("extensionsort")
                 .overrides_with("versionsort")
                 .overrides_with("sort")
                 .overrides_with("no-sort")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Sort by size"),
         )
         .arg(
             Arg::with_name("extensionsort")
-                .short("X")
+                .short('X')
                 .long("extensionsort")
                 .overrides_with("sizesort")
                 .overrides_with("timesort")
                 .overrides_with("versionsort")
                 .overrides_with("sort")
                 .overrides_with("no-sort")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Sort by file extension"),
         )
         .arg(
             Arg::with_name("versionsort")
-                .short("v")
+                .short('v')
                 .long("versionsort")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .overrides_with("timesort")
                 .overrides_with("sizesort")
                 .overrides_with("extensionsort")
@@ -211,7 +217,7 @@ pub fn build() -> App<'static, 'static> {
         .arg(
             Arg::with_name("sort")
                 .long("sort")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .possible_values(&["size", "time", "version", "extension", "none"])
                 .takes_value(true)
                 .value_name("WORD")
@@ -224,9 +230,9 @@ pub fn build() -> App<'static, 'static> {
         )
         .arg(
             Arg::with_name("no-sort")
-            .short("U")
+            .short('U')
             .long("no-sort")
-            .multiple(true)
+            .multiple_occurrences(true)
             .overrides_with("timesort")
             .overrides_with("sizesort")
             .overrides_with("extensionsort")
@@ -236,9 +242,9 @@ pub fn build() -> App<'static, 'static> {
         )
         .arg(
             Arg::with_name("reverse")
-                .short("r")
+                .short('r')
                 .long("reverse")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Reverse the order of the sort"),
         )
         .arg(
@@ -247,7 +253,7 @@ pub fn build() -> App<'static, 'static> {
                 .possible_value("none")
                 .possible_value("first")
                 .possible_value("last")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .number_of_values(1)
                 .help("Sort the directories then the files"),
         )
@@ -259,8 +265,10 @@ pub fn build() -> App<'static, 'static> {
         .arg(
             Arg::with_name("blocks")
                 .long("blocks")
-                .multiple(true)
-                .number_of_values(1)
+                .multiple_occurrences(true)
+                .multiple_values(true)
+                .takes_value(true)
+                .use_value_delimiter(true)
                 .require_delimiter(true)
                 .possible_values(&[
                     "permission",
@@ -283,14 +291,14 @@ pub fn build() -> App<'static, 'static> {
         .arg(
             Arg::with_name("no-symlink")
                 .long("no-symlink")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Do not display symlink target"),
         )
         .arg(
             Arg::with_name("ignore-glob")
-                .short("I")
+                .short('I')
                 .long("ignore-glob")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .number_of_values(1)
                 .value_name("pattern")
                 .default_value("")
@@ -298,21 +306,21 @@ pub fn build() -> App<'static, 'static> {
         )
         .arg(
             Arg::with_name("inode")
-                .short("i")
+                .short('i')
                 .long("inode")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("Display the index number of each file"),
         )
         .arg(
             Arg::with_name("dereference")
-                .short("L")
+                .short('L')
                 .long("dereference")
-                .multiple(true)
+                .multiple_occurrences(true)
                 .help("When showing file information for a symbolic link, show information for the file the link references rather than for the link itself"),
         )
         .arg(
             Arg::with_name("context")
-                .short("Z")
+                .short('Z')
                 .long("context")
                 .required(false)
                 .takes_value(false)
@@ -325,7 +333,8 @@ pub fn build() -> App<'static, 'static> {
                 .possible_value("auto")
                 .possible_value("never")
                 .default_value("never")
-                .multiple(true)
+                .multiple_occurrences(true)
+                .takes_value(true)
                 .number_of_values(1)
                 .help("Attach hyperlink to filenames"),
         )
@@ -336,10 +345,10 @@ pub fn build() -> App<'static, 'static> {
         )
 }
 
-fn validate_date_argument(arg: String) -> Result<(), String> {
+fn validate_date_argument(arg: &str) -> Result<(), String> {
     if arg.starts_with('+') {
-        validate_time_format(&arg)
-    } else if &arg == "date" || &arg == "relative" {
+        validate_time_format(arg)
+    } else if arg == "date" || arg == "relative" {
         Result::Ok(())
     } else {
         Result::Err("possible values: date, relative, +date-time-format".to_owned())
@@ -353,7 +362,7 @@ pub fn validate_time_format(formatter: &str) -> Result<(), String> {
             Some('%') => match chars.next() {
                 Some('.') => match chars.next() {
                     Some('f') => (),
-                    Some(n @ '3') | Some(n @ '6') | Some(n @ '9') => match chars.next() {
+                    Some(n @ ('3' | '6' | '9')) => match chars.next() {
                         Some('f') => (),
                         Some(c) => return Err(format!("invalid format specifier: %.{}{}", n, c)),
                         None => return Err("missing format specifier".to_owned()),
@@ -361,28 +370,26 @@ pub fn validate_time_format(formatter: &str) -> Result<(), String> {
                     Some(c) => return Err(format!("invalid format specifier: %.{}", c)),
                     None => return Err("missing format specifier".to_owned()),
                 },
-                Some(n @ ':') | Some(n @ '#') => match chars.next() {
+                Some(n @ (':' | '#')) => match chars.next() {
                     Some('z') => (),
                     Some(c) => return Err(format!("invalid format specifier: %{}{}", n, c)),
                     None => return Err("missing format specifier".to_owned()),
                 },
-                Some(n @ '-') | Some(n @ '_') | Some(n @ '0') => match chars.next() {
-                    Some('C') | Some('d') | Some('e') | Some('f') | Some('G') | Some('g')
-                    | Some('H') | Some('I') | Some('j') | Some('k') | Some('l') | Some('M')
-                    | Some('m') | Some('S') | Some('s') | Some('U') | Some('u') | Some('V')
-                    | Some('W') | Some('w') | Some('Y') | Some('y') => (),
+                Some(n @ ('-' | '_' | '0')) => match chars.next() {
+                    Some(
+                        'C' | 'd' | 'e' | 'f' | 'G' | 'g' | 'H' | 'I' | 'j' | 'k' | 'l' | 'M' | 'm'
+                        | 'S' | 's' | 'U' | 'u' | 'V' | 'W' | 'w' | 'Y' | 'y',
+                    ) => (),
                     Some(c) => return Err(format!("invalid format specifier: %{}{}", n, c)),
                     None => return Err("missing format specifier".to_owned()),
                 },
-                Some('A') | Some('a') | Some('B') | Some('b') | Some('C') | Some('c')
-                | Some('D') | Some('d') | Some('e') | Some('F') | Some('f') | Some('G')
-                | Some('g') | Some('H') | Some('h') | Some('I') | Some('j') | Some('k')
-                | Some('l') | Some('M') | Some('m') | Some('n') | Some('P') | Some('p')
-                | Some('R') | Some('r') | Some('S') | Some('s') | Some('T') | Some('t')
-                | Some('U') | Some('u') | Some('V') | Some('v') | Some('W') | Some('w')
-                | Some('X') | Some('x') | Some('Y') | Some('y') | Some('Z') | Some('z')
-                | Some('+') | Some('%') => (),
-                Some(n @ '3') | Some(n @ '6') | Some(n @ '9') => match chars.next() {
+                Some(
+                    'A' | 'a' | 'B' | 'b' | 'C' | 'c' | 'D' | 'd' | 'e' | 'F' | 'f' | 'G' | 'g'
+                    | 'H' | 'h' | 'I' | 'j' | 'k' | 'l' | 'M' | 'm' | 'n' | 'P' | 'p' | 'R' | 'r'
+                    | 'S' | 's' | 'T' | 't' | 'U' | 'u' | 'V' | 'v' | 'W' | 'w' | 'X' | 'x' | 'Y'
+                    | 'y' | 'Z' | 'z' | '+' | '%',
+                ) => (),
+                Some(n @ ('3' | '6' | '9')) => match chars.next() {
                     Some('f') => (),
                     Some(c) => return Err(format!("invalid format specifier: %{}{}", n, c)),
                     None => return Err("missing format specifier".to_owned()),
diff --git a/src/color.rs b/src/color.rs
index 6d8639f..c3bd938 100644
--- a/src/color.rs
+++ b/src/color.rs
@@ -67,11 +67,11 @@ pub enum Elem {
 }
 
 impl Elem {
-    pub fn has_suid(&self) -> bool {
+    fn has_suid(&self) -> bool {
         matches!(self, Elem::Dir { uid: true } | Elem::File { uid: true, .. })
     }
 
-    pub fn get_color(&self, theme: &theme::Theme) -> Color {
+    fn get_color(&self, theme: &theme::Theme) -> Color {
         match self {
             Elem::File {
                 exec: true,
@@ -139,21 +139,21 @@ impl Colors {
     pub fn new(t: ThemeOption) -> Self {
         let theme = match t {
             ThemeOption::NoColor => None,
-            ThemeOption::Default => Some(Theme::default()),
-            ThemeOption::NoLscolors => Some(Theme::default()),
+            ThemeOption::Default | ThemeOption::NoLscolors => Some(Theme::default()),
             ThemeOption::Custom(ref file) => Some(Theme::from_path(file).unwrap_or_default()),
         };
         let lscolors = match t {
-            ThemeOption::Default => Some(LsColors::from_env().unwrap_or_default()),
-            ThemeOption::Custom(_) => Some(LsColors::from_env().unwrap_or_default()),
+            ThemeOption::Default | ThemeOption::Custom(_) => {
+                Some(LsColors::from_env().unwrap_or_default())
+            }
             _ => None,
         };
 
         Self { theme, lscolors }
     }
 
-    pub fn colorize(&self, input: String, elem: &Elem) -> ColoredString {
-        self.style(elem).apply(input)
+    pub fn colorize<S: Into<String>>(&self, input: S, elem: &Elem) -> ColoredString {
+        self.style(elem).apply(input.into())
     }
 
     pub fn colorize_using_path(&self, input: String, path: &Path, elem: &Elem) -> ColoredString {
@@ -222,11 +222,7 @@ impl Colors {
             Elem::CharDevice => Some("cd"),
             Elem::BrokenSymLink => Some("or"),
             Elem::MissingSymLinkTarget => Some("mi"),
-            Elem::INode { valid } => match valid {
-                true => Some("so"),
-                false => Some("no"),
-            },
-            Elem::Links { valid } => match valid {
+            Elem::INode { valid } | Elem::Links { valid } => match valid {
                 true => Some("so"),
                 false => Some("no"),
             },
diff --git a/src/color/theme.rs b/src/color/theme.rs
index a63fd67..148753b 100644
--- a/src/color/theme.rs
+++ b/src/color/theme.rs
@@ -5,8 +5,82 @@ use crate::print_error;
 
 use crossterm::style::Color;
 use serde::Deserialize;
-use std::fs;
 use std::path::Path;
+use std::{fmt, fs};
+
+// Custom color deserialize
+fn deserialize_color<'de, D>(deserializer: D) -> Result<Color, D::Error>
+where
+    D: serde::de::Deserializer<'de>,
+{
+    struct ColorVisitor;
+    impl<'de> serde::de::Visitor<'de> for ColorVisitor {
+        type Value = Color;
+
+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+            formatter.write_str(
+                    "`black`, `blue`, `dark_blue`, `cyan`, `dark_cyan`, `green`, `dark_green`, `grey`, `dark_grey`, `magenta`, `dark_magenta`, `red`, `dark_red`, `white`, `yellow`, `dark_yellow`, `u8`, or `3 u8 array`",
+                )
+        }
+
+        fn visit_str<E>(self, value: &str) -> Result<Color, E>
+        where
+            E: serde::de::Error,
+        {
+            Color::try_from(value)
+                .map_err(|_| E::invalid_value(serde::de::Unexpected::Str(value), &self))
+        }
+
+        fn visit_u64<E>(self, value: u64) -> Result<Color, E>
+        where
+            E: serde::de::Error,
+        {
+            if value > 255 {
+                return Err(E::invalid_value(
+                    serde::de::Unexpected::Unsigned(value),
+                    &self,
+                ));
+            }
+            Ok(Color::AnsiValue(value as u8))
+        }
+
+        fn visit_seq<M>(self, mut seq: M) -> Result<Color, M::Error>
+        where
+            M: serde::de::SeqAccess<'de>,
+        {
+            let mut values = Vec::new();
+            if let Some(size) = seq.size_hint() {
+                if size != 3 {
+                    return Err(serde::de::Error::invalid_length(
+                        size,
+                        &"a list of size 3(RGB)",
+                    ));
+                }
+            }
+            loop {
+                match seq.next_element::<u8>() {
+                    Ok(Some(x)) => {
+                        values.push(x);
+                    }
+                    Ok(None) => break,
+                    Err(e) => {
+                        return Err(e);
+                    }
+                }
+            }
+            // recheck as size_hint sometimes not working
+            if values.len() != 3 {
+                return Err(serde::de::Error::invalid_length(
+                    values.len(),
+                    &"a list of size 3(RGB)",
+                ));
+            }
+            Ok(Color::from((values[0], values[1], values[2])))
+        }
+    }
+
+    deserializer.deserialize_any(ColorVisitor)
+}
 
 /// A struct holding the theme configuration
 /// Color table: https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.avg
@@ -15,12 +89,15 @@ use std::path::Path;
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Theme {
+    #[serde(deserialize_with = "deserialize_color")]
     pub user: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub group: Color,
     pub permission: Permission,
     pub date: Date,
     pub size: Size,
     pub inode: INode,
+    #[serde(deserialize_with = "deserialize_color")]
     pub tree_edge: Color,
     pub links: Links,
 
@@ -33,13 +110,21 @@ pub struct Theme {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Permission {
+    #[serde(deserialize_with = "deserialize_color")]
     pub read: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub write: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub exec: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub exec_sticky: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub no_access: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub octal: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub acl: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub context: Color,
 }
 
@@ -50,11 +135,16 @@ pub struct Permission {
 pub struct FileType {
     pub file: File,
     pub dir: Dir,
+    #[serde(deserialize_with = "deserialize_color")]
     pub pipe: Color,
     pub symlink: Symlink,
+    #[serde(deserialize_with = "deserialize_color")]
     pub block_device: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub char_device: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub socket: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub special: Color,
 }
 
@@ -63,9 +153,13 @@ pub struct FileType {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct File {
+    #[serde(deserialize_with = "deserialize_color")]
     pub exec_uid: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub uid_no_exec: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub exec_no_uid: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub no_exec_no_uid: Color,
 }
 
@@ -74,7 +168,9 @@ pub struct File {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Dir {
+    #[serde(deserialize_with = "deserialize_color")]
     pub uid: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub no_uid: Color,
 }
 
@@ -83,8 +179,11 @@ pub struct Dir {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Symlink {
+    #[serde(deserialize_with = "deserialize_color")]
     pub default: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub broken: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub missing_target: Color,
 }
 
@@ -93,8 +192,11 @@ pub struct Symlink {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Date {
+    #[serde(deserialize_with = "deserialize_color")]
     pub hour_old: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub day_old: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub older: Color,
 }
 
@@ -103,9 +205,13 @@ pub struct Date {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Size {
+    #[serde(deserialize_with = "deserialize_color")]
     pub none: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub small: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub medium: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub large: Color,
 }
 
@@ -114,7 +220,9 @@ pub struct Size {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct INode {
+    #[serde(deserialize_with = "deserialize_color")]
     pub valid: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub invalid: Color,
 }
 
@@ -123,7 +231,9 @@ pub struct INode {
 #[serde(deny_unknown_fields)]
 #[serde(default)]
 pub struct Links {
+    #[serde(deserialize_with = "deserialize_color")]
     pub valid: Color,
+    #[serde(deserialize_with = "deserialize_color")]
     pub invalid: Color,
 }
 
@@ -351,7 +461,7 @@ mod tests {
     fn test_empty_theme_return_default() {
         // Must contain one field at least
         // ref https://github.com/dtolnay/serde-yaml/issues/86
-        let empty_theme = Theme::with_yaml("user: 230".into()).unwrap(); // 230 is the default value
+        let empty_theme = Theme::with_yaml("user: 230").unwrap(); // 230 is the default value
         let default_theme = Theme::default_dark();
         assert_eq!(empty_theme, default_theme);
     }
@@ -360,7 +470,7 @@ mod tests {
     fn test_first_level_theme_return_default_but_changed() {
         // Must contain one field at least
         // ref https://github.com/dtolnay/serde-yaml/issues/86
-        let empty_theme = Theme::with_yaml("user: 130".into()).unwrap();
+        let empty_theme = Theme::with_yaml("user: 130").unwrap();
         let mut theme = Theme::default_dark();
         use crossterm::style::Color;
         theme.user = Color::AnsiValue(130);
@@ -374,8 +484,7 @@ mod tests {
         let empty_theme = Theme::with_yaml(
             r#"---
 permission:
-  read: 130"#
-                .into(),
+  read: 130"#,
         )
         .unwrap();
         let mut theme = Theme::default_dark();
diff --git a/src/config_file.rs b/src/config_file.rs
index fd661c5..b20c81f 100644
--- a/src/config_file.rs
+++ b/src/config_file.rs
@@ -15,10 +15,10 @@ use std::path::{Path, PathBuf};
 use serde::Deserialize;
 
 use std::fs;
+use std::io;
 
 const CONF_DIR: &str = "lsd";
-const CONF_FILE_NAME: &str = "config";
-const YAML_LONG_EXT: &str = "yaml";
+const CONF_FILE_NAME: &str = "config.yaml";
 
 /// A struct to hold an optional configuration items, and provides methods
 /// around error handling in a config file.
@@ -100,21 +100,29 @@ impl Config {
         }
     }
 
-    /// This constructs a Config struct with a passed file path [String].
-    pub fn from_file(file: String) -> Option<Self> {
-        match fs::read(&file) {
+    /// This constructs a Config struct with a passed file path.
+    pub fn from_file<P: AsRef<Path>>(file: P) -> Option<Self> {
+        let file = file.as_ref();
+        match fs::read(file) {
             Ok(f) => match Self::from_yaml(&String::from_utf8_lossy(&f)) {
                 Ok(c) => Some(c),
                 Err(e) => {
-                    print_error!("Configuration file {} format error, {}.", &file, e);
+                    print_error!(
+                        "Configuration file {} format error, {}.",
+                        file.to_string_lossy(),
+                        e
+                    );
                     None
                 }
             },
             Err(e) => {
-                match e.kind() {
-                    std::io::ErrorKind::NotFound => {}
-                    _ => print_error!("Can not open config file {}: {}.", &file, e),
-                };
+                if e.kind() != io::ErrorKind::NotFound {
+                    print_error!(
+                        "Can not open config file {}: {}.",
+                        file.to_string_lossy(),
+                        e
+                    );
+                }
                 None
             }
         }
@@ -132,22 +140,19 @@ impl Config {
     pub fn config_file_path() -> Option<PathBuf> {
         use xdg::BaseDirectories;
         match BaseDirectories::with_prefix(CONF_DIR) {
-            Ok(p) => {
-                return Some(p.get_config_home());
+            Ok(p) => Some(p.get_config_home()),
+            Err(e) => {
+                print_error!("Can not open config file: {}.", e);
+                None
             }
-            Err(e) => print_error!("Can not open config file: {}.", e),
         }
-        None
     }
 
     /// This provides the path for a configuration file, inside the %APPDATA% directory.
     /// return None if error like PermissionDenied
     #[cfg(windows)]
     pub fn config_file_path() -> Option<PathBuf> {
-        if let Some(p) = dirs::config_dir() {
-            return Some(p.join(CONF_DIR));
-        }
-        None
+        dirs::config_dir().map(|x| x.join(CONF_DIR))
     }
 
     /// This expand the `~` in path to HOME dir
@@ -179,11 +184,7 @@ impl Config {
 impl Default for Config {
     fn default() -> Self {
         if let Some(p) = Self::config_file_path() {
-            if let Some(c) = Self::from_file(
-                p.join([CONF_FILE_NAME, YAML_LONG_EXT].join("."))
-                    .to_string_lossy()
-                    .to_string(),
-            ) {
+            if let Some(c) = Self::from_file(p.join(CONF_FILE_NAME)) {
                 return c;
             }
         }
@@ -407,7 +408,7 @@ mod tests {
 
     #[test]
     fn test_read_config_file_not_found() {
-        let c = Config::from_file("not-existed".to_string());
+        let c = Config::from_file("not-existed");
         assert!(c.is_none())
     }
 
diff --git a/src/display.rs b/src/display.rs
index c64ec8b..472bf26 100644
--- a/src/display.rs
+++ b/src/display.rs
@@ -36,7 +36,7 @@ pub fn tree(metas: &[Meta], flags: &Flags, colors: &Colors, icons: &Icons) -> St
     let padding_rules = get_padding_rules(metas, flags);
     let mut index = 0;
     for (i, block) in flags.blocks.0.iter().enumerate() {
-        if let Block::Name = block {
+        if block == &Block::Name {
             index = i;
             break;
         }
@@ -100,14 +100,9 @@ fn inner_display_grid(
         );
 
         for block in blocks {
-            let block_str = block.to_string();
-
             cells.push(Cell {
-                width: get_visible_width(
-                    &block_str,
-                    matches!(flags.hyperlink, HyperlinkOption::Always),
-                ),
-                contents: block_str,
+                width: get_visible_width(&block, flags.hyperlink == HyperlinkOption::Always),
+                contents: block,
             });
         }
     }
@@ -142,7 +137,7 @@ fn inner_display_grid(
 
     // print the folder content
     for meta in metas {
-        if meta.content.is_some() {
+        if let Some(content) = &meta.content {
             if should_display_folder_path {
                 output += &display_folder_path(meta);
             }
@@ -153,7 +148,7 @@ fn inner_display_grid(
 
             output += &inner_display_grid(
                 &display_option,
-                meta.content.as_ref().unwrap(),
+                content,
                 flags,
                 colors,
                 icons,
@@ -173,12 +168,7 @@ fn add_header(flags: &Flags, cells: &[Cell], grid: &mut Grid) {
         .blocks
         .0
         .iter()
-        .map(|b| {
-            get_visible_width(
-                &b.get_header(),
-                matches!(flags.hyperlink, HyperlinkOption::Always),
-            )
-        })
+        .map(|b| get_visible_width(b.get_header(), flags.hyperlink == HyperlinkOption::Always))
         .collect::<Vec<usize>>();
 
     // find max widths of each column
@@ -235,18 +225,13 @@ fn inner_display_tree(
             padding_rules,
             (tree_index, &current_prefix),
         ) {
-            let block_str = block.to_string();
-
             cells.push(Cell {
-                width: get_visible_width(
-                    &block_str,
-                    matches!(flags.hyperlink, HyperlinkOption::Always),
-                ),
-                contents: block_str,
+                width: get_visible_width(&block, flags.hyperlink == HyperlinkOption::Always),
+                contents: block,
             });
         }
 
-        if meta.content.is_some() {
+        if let Some(content) = &meta.content {
             let new_prefix = if tree_depth_prefix.0 > 0 {
                 if idx + 1 != last_idx {
                     // is last folder elem
@@ -259,7 +244,7 @@ fn inner_display_tree(
             };
 
             cells.extend(inner_display_tree(
-                meta.content.as_ref().unwrap(),
+                content,
                 flags,
                 colors,
                 icons,
@@ -291,27 +276,22 @@ fn should_display_folder_path(depth: usize, metas: &[Meta], flags: &Flags) -> bo
 }
 
 fn display_folder_path(meta: &Meta) -> String {
-    let mut output = String::new();
-    output.push('\n');
-    output += &meta.path.to_string_lossy();
-    output += ":\n";
-
-    output
+    format!("\n{}:\n", meta.path.to_string_lossy())
 }
 
-fn get_output<'a>(
-    meta: &'a Meta,
-    colors: &'a Colors,
-    icons: &'a Icons,
-    flags: &'a Flags,
+fn get_output(
+    meta: &Meta,
+    colors: &Colors,
+    icons: &Icons,
+    flags: &Flags,
     display_option: &DisplayOption,
     padding_rules: &HashMap<Block, usize>,
-    tree: (usize, &'a str),
+    tree: (usize, &str),
 ) -> Vec<String> {
     let mut strings: Vec<String> = Vec::new();
     for (i, block) in flags.blocks.0.iter().enumerate() {
         let mut block_vec = if Layout::Tree == flags.layout && tree.0 == i {
-            vec![colors.colorize(tree.1.to_string(), &Elem::TreeEdge)]
+            vec![colors.colorize(tree.1, &Elem::TreeEdge)]
         } else {
             Vec::new()
         };
@@ -320,7 +300,7 @@ fn get_output<'a>(
             Block::INode => block_vec.push(meta.inode.render(colors)),
             Block::Links => block_vec.push(meta.links.render(colors)),
             Block::Permission => {
-                block_vec.extend(vec![
+                block_vec.extend([
                     meta.file_type.render(colors),
                     meta.permissions.render(colors, flags),
                     meta.access_control.render_method(colors),
@@ -340,7 +320,7 @@ fn get_output<'a>(
             Block::SizeValue => block_vec.push(meta.size.render_value(colors, flags)),
             Block::Date => block_vec.push(meta.date.render(colors, flags)),
             Block::Name => {
-                block_vec.extend(vec![
+                block_vec.extend([
                     meta.name
                         .render(colors, icons, display_option, flags.hyperlink),
                     meta.indicator.render(flags),
@@ -438,7 +418,7 @@ mod tests {
 
     #[test]
     fn test_display_get_visible_width_without_icons() {
-        for (s, l) in &[
+        for (s, l) in [
             ("Ｈｅｌｌｏ,ｗｏｒｌｄ!", 22),
             ("ASCII1234-_", 11),
             ("制作样本。", 10),
@@ -449,7 +429,7 @@ mod tests {
         ] {
             let path = Path::new(s);
             let name = Name::new(
-                &path,
+                path,
                 FileType::File {
                     exec: false,
                     uid: false,
@@ -464,13 +444,13 @@ mod tests {
                 )
                 .to_string();
 
-            assert_eq!(get_visible_width(&output, false), *l);
+            assert_eq!(get_visible_width(&output, false), l);
         }
     }
 
     #[test]
     fn test_display_get_visible_width_with_icons() {
-        for (s, l) in &[
+        for (s, l) in [
             // Add 3 characters for the icons.
             ("Ｈｅｌｌｏ,ｗｏｒｌｄ!", 24),
             ("ASCII1234-_", 13),
@@ -483,7 +463,7 @@ mod tests {
         ] {
             let path = Path::new(s);
             let name = Name::new(
-                &path,
+                path,
                 FileType::File {
                     exec: false,
                     uid: false,
@@ -498,13 +478,13 @@ mod tests {
                 )
                 .to_string();
 
-            assert_eq!(get_visible_width(&output, false), *l);
+            assert_eq!(get_visible_width(&output, false), l);
         }
     }
 
     #[test]
     fn test_display_get_visible_width_with_colors() {
-        for (s, l) in &[
+        for (s, l) in [
             ("Ｈｅｌｌｏ,ｗｏｒｌｄ!", 22),
             ("ASCII1234-_", 11),
             ("File with space", 15),
@@ -516,7 +496,7 @@ mod tests {
         ] {
             let path = Path::new(s);
             let name = Name::new(
-                &path,
+                path,
                 FileType::File {
                     exec: false,
                     uid: false,
@@ -532,21 +512,20 @@ mod tests {
                 .to_string();
 
             // check if the color is present.
-            assert_eq!(
-                true,
+            assert!(
                 output.starts_with("\u{1b}[38;5;"),
                 "{:?} should start with color",
                 output,
             );
-            assert_eq!(true, output.ends_with("[39m"), "reset foreground color");
+            assert!(output.ends_with("[39m"), "reset foreground color");
 
-            assert_eq!(get_visible_width(&output, false), *l, "visible match");
+            assert_eq!(get_visible_width(&output, false), l, "visible match");
         }
     }
 
     #[test]
     fn test_display_get_visible_width_without_colors() {
-        for (s, l) in &[
+        for (s, l) in [
             ("Ｈｅｌｌｏ,ｗｏｒｌｄ!", 22),
             ("ASCII1234-_", 11),
             ("File with space", 15),
@@ -558,7 +537,7 @@ mod tests {
         ] {
             let path = Path::new(s);
             let name = Name::new(
-                &path,
+                path,
                 FileType::File {
                     exec: false,
                     uid: false,
@@ -574,16 +553,16 @@ mod tests {
                 .to_string();
 
             // check if the color is present.
-            assert_eq!(false, output.starts_with("\u{1b}[38;5;"));
-            assert_eq!(false, output.ends_with("[0m"));
+            assert!(!output.starts_with("\u{1b}[38;5;"));
+            assert!(!output.ends_with("[0m"));
 
-            assert_eq!(get_visible_width(&output, false), *l);
+            assert_eq!(get_visible_width(&output, false), l);
         }
     }
 
     #[test]
     fn test_display_get_visible_width_hypelink_simple() {
-        for (s, l) in &[
+        for (s, l) in [
             ("Ｈｅｌｌｏ,ｗｏｒｌｄ!", 22),
             ("ASCII1234-_", 11),
             ("File with space", 15),
@@ -595,7 +574,7 @@ mod tests {
         ] {
             // rending name require actual file, so we are mocking that
             let output = format!("\x1B]8;;{}\x1B\x5C{}\x1B]8;;\x1B\x5C", "url://fake-url", s);
-            assert_eq!(get_visible_width(&output, true), *l);
+            assert_eq!(get_visible_width(&output, true), l);
         }
     }
 
@@ -611,7 +590,7 @@ mod tests {
 
     #[test]
     fn test_display_tree_with_all() {
-        let argv = vec!["lsd", "--tree", "--all"];
+        let argv = ["lsd", "--tree", "--all"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let flags = Flags::configure_from(&matches, &Config::with_none()).unwrap();
 
@@ -643,7 +622,7 @@ mod tests {
     /// `---blocks size,name` can help us for this case
     #[test]
     fn test_tree_align_subfolder() {
-        let argv = vec!["lsd", "--tree", "--blocks", "size,name"];
+        let argv = ["lsd", "--tree", "--blocks", "size,name"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let flags = Flags::configure_from(&matches, &Config::with_none()).unwrap();
 
@@ -668,21 +647,21 @@ mod tests {
                 .nth(i)
                 .unwrap()
                 .split(|c| c == 'K' || c == 'B')
-                .nth(0)
+                .next()
                 .unwrap()
                 .len()
         };
         assert_eq!(length_before_b(0), length_before_b(1));
         assert_eq!(
-            output.lines().nth(0).unwrap().find("d"),
-            output.lines().nth(1).unwrap().find("└")
+            output.lines().next().unwrap().find('d'),
+            output.lines().nth(1).unwrap().find('└')
         );
     }
 
     #[test]
     #[cfg(unix)]
     fn test_tree_size_first_without_name() {
-        let argv = vec!["lsd", "--tree", "--blocks", "size,permission"];
+        let argv = ["lsd", "--tree", "--blocks", "size,permission"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let flags = Flags::configure_from(&matches, &Config::with_none()).unwrap();
 
@@ -701,11 +680,11 @@ mod tests {
             &Icons::new(icon::Theme::NoIcon, " ".to_string()),
         );
 
-        assert_eq!(output.lines().nth(1).unwrap().chars().nth(0).unwrap(), '└');
+        assert_eq!(output.lines().nth(1).unwrap().chars().next().unwrap(), '└');
         assert_eq!(
             output
                 .lines()
-                .nth(0)
+                .next()
                 .unwrap()
                 .chars()
                 .position(|x| x == 'd'),
@@ -720,7 +699,7 @@ mod tests {
 
     #[test]
     fn test_tree_edge_before_name() {
-        let argv = vec!["lsd", "--tree", "--long"];
+        let argv = ["lsd", "--tree", "--long"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let flags = Flags::configure_from(&matches, &Config::with_none()).unwrap();
 
@@ -744,7 +723,7 @@ mod tests {
 
     #[test]
     fn test_grid_all_block_headers() {
-        let argv = vec![
+        let argv = [
             "lsd",
             "--header",
             "--blocks",
@@ -782,7 +761,7 @@ mod tests {
 
     #[test]
     fn test_grid_no_header_with_empty_meta() {
-        let argv = vec!["lsd", "--header", "-l"];
+        let argv = ["lsd", "--header", "-l"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let flags = Flags::configure_from(&matches, &Config::with_none()).unwrap();
 
diff --git a/src/flags.rs b/src/flags.rs
index 59db6bf..17788c2 100644
--- a/src/flags.rs
+++ b/src/flags.rs
@@ -83,7 +83,7 @@ impl Flags {
     /// the recursion depth parameter fails.
     pub fn configure_from(matches: &ArgMatches, config: &Config) -> Result<Self, Error> {
         Ok(Self {
-            blocks: Blocks::configure_from(matches, config)?,
+            blocks: Blocks::configure_from(matches, config),
             color: Color::configure_from(matches, config),
             date: DateFlag::configure_from(matches, config),
             dereference: Dereference::configure_from(matches, config),
diff --git a/src/flags/blocks.rs b/src/flags/blocks.rs
index cef5a90..11e1893 100644
--- a/src/flags/blocks.rs
+++ b/src/flags/blocks.rs
@@ -1,18 +1,75 @@
 //! This module defines the [Blocks] struct. To set it up from [ArgMatches], a [Config] and its
 //! [Default] value, use its [configure_from](Blocks::configure_from) method.
 
+use super::Configurable;
 use crate::config_file::Config;
 use crate::print_error;
 
 use std::convert::TryFrom;
 
-use clap::{ArgMatches, Error, ErrorKind};
+use clap::ArgMatches;
 
 /// A struct to hold a [Vec] of [Block]s and to provide methods to create it.
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct Blocks(pub Vec<Block>);
 
 impl Blocks {
+    /// This returns a Blocks struct for the long format.
+    ///
+    /// It contains the [Block]s [Permission](Block::Permission), [User](Block::User),
+    /// [Group](Block::Group), [Size](Block::Size), [Date](Block::Date) and [Name](Block::Name).
+    fn long() -> Self {
+        Self(vec![
+            Block::Permission,
+            Block::User,
+            Block::Group,
+            Block::Size,
+            Block::Date,
+            Block::Name,
+        ])
+    }
+
+    /// Checks whether `self` already contains a [Block] of variant [INode](Block::INode).
+    fn contains_inode(&self) -> bool {
+        self.0.contains(&Block::INode)
+    }
+
+    /// Prepends a [Block] of variant [INode](Block::INode) to `self`.
+    fn prepend_inode(&mut self) {
+        self.0.insert(0, Block::INode);
+    }
+
+    /// Prepends a [Block] of variant [INode](Block::INode), if `self` does not already contain a
+    /// Block of that variant.
+    fn optional_prepend_inode(&mut self) {
+        if !self.contains_inode() {
+            self.prepend_inode()
+        }
+    }
+
+    pub fn displays_size(&self) -> bool {
+        self.0.contains(&Block::Size)
+    }
+
+    /// Inserts a [Block] of variant [INode](Block::Context), if `self` does not already contain a
+    /// [Block] of that variant. The positioning will be best-effort approximation of coreutils
+    /// ls position for a security context
+    fn optional_insert_context(&mut self) {
+        if self.0.contains(&Block::Context) {
+            return;
+        }
+        let mut pos = self.0.iter().position(|elem| *elem == Block::Group);
+        if pos.is_none() {
+            pos = self.0.iter().position(|elem| *elem == Block::User);
+        }
+        match pos {
+            Some(pos) => self.0.insert(pos + 1, Block::Context),
+            None => self.0.insert(0, Block::Context),
+        }
+    }
+}
+
+impl Configurable<Self> for Blocks {
     /// Returns a value from either [ArgMatches], a [Config] or a default value.
     /// Unless the "long" argument is passed, this returns [Default::default]. Otherwise the first
     /// value, that is not [None], is used. The order of precedence for the value used is:
@@ -23,41 +80,31 @@ impl Blocks {
     /// No matter if the "long" argument was passed, if the "inode" argument is passed and the
     /// `Blocks` does not contain a [Block] of variant [INode](Block::INode) yet, one is prepended
     /// to the returned value.
-    ///
-    /// # Errors
-    ///
-    /// This errors if any of the [ArgMatches] parameter arguments causes [Block]'s implementation
-    /// of [TryFrom::try_from] to return an [Err].
-    pub fn configure_from(matches: &ArgMatches, config: &Config) -> Result<Self, Error> {
-        let mut result: Result<Self, Error> = if matches.is_present("long") {
-            Ok(Self::long())
+    fn configure_from(matches: &ArgMatches, config: &Config) -> Self {
+        let mut blocks = if matches.is_present("long") {
+            Self::long()
         } else {
-            Ok(Default::default())
+            Default::default()
         };
 
         if matches.is_present("long") && !matches.is_present("ignore-config") {
             if let Some(value) = Self::from_config(config) {
-                result = Ok(value);
+                blocks = value;
             }
         }
 
         if let Some(value) = Self::from_arg_matches(matches) {
-            result = value;
+            blocks = value;
         }
 
         if matches.is_present("context") {
-            if let Ok(blocks) = result.as_mut() {
-                blocks.optional_insert_context();
-            }
+            blocks.optional_insert_context();
         }
-
         if matches.is_present("inode") {
-            if let Ok(blocks) = result.as_mut() {
-                blocks.optional_prepend_inode();
-            }
+            blocks.optional_prepend_inode();
         }
 
-        result
+        blocks
     }
 
     /// Get a potential `Blocks` struct from [ArgMatches].
@@ -65,30 +112,20 @@ impl Blocks {
     /// If the "blocks" argument is passed, then this returns a `Blocks` containing the parameter
     /// values in a [Some]. Otherwise if the "long" argument is passed, this returns
     /// [Blocks::long]. Finally if none of the previous happened, this returns [None].
-    ///
-    /// # Errors
-    ///
-    /// This errors if any of the parameter arguments causes [Block]'s implementation of
-    /// [TryFrom::try_from] to return an [Err].
-    fn from_arg_matches(matches: &ArgMatches) -> Option<Result<Self, Error>> {
-        if matches.occurrences_of("blocks") > 0 {
-            if let Some(values) = matches.values_of("blocks") {
-                let mut blocks: Vec<Block> = vec![];
-                for value in values {
-                    match Block::try_from(value) {
-                        Ok(block) => blocks.push(block),
-                        Err(message) => {
-                            return Some(Err(Error::with_description(
-                                &message,
-                                ErrorKind::ValueValidation,
-                            )))
-                        }
-                    }
-                }
-                Some(Ok(Self(blocks)))
-            } else {
-                None
+    fn from_arg_matches(matches: &ArgMatches) -> Option<Self> {
+        if matches.occurrences_of("blocks") == 0 {
+            return None;
+        }
+
+        if let Some(values) = matches.values_of("blocks") {
+            let mut blocks: Vec<Block> = Vec::with_capacity(values.len());
+            for value in values {
+                blocks.push(Block::try_from(value).unwrap_or_else(|_| {
+                    // Invalid value should be handled by `clap` when building an `ArgMatches`
+                    unreachable!("Invalid value '{value}' for 'blocks'")
+                }));
             }
+            Some(Self(blocks))
         } else {
             None
         }
@@ -117,60 +154,6 @@ impl Blocks {
             None
         }
     }
-
-    /// This returns a Blocks struct for the long format.
-    ///
-    /// It contains the [Block]s [Permission](Block::Permission), [User](Block::User),
-    /// [Group](Block::Group), [Size](Block::Size), [Date](Block::Date) and [Name](Block::Name).
-    fn long() -> Self {
-        Self(vec![
-            Block::Permission,
-            Block::User,
-            Block::Group,
-            Block::Size,
-            Block::Date,
-            Block::Name,
-        ])
-    }
-
-    /// Checks whether `self` already contains a [Block] of variant [INode](Block::INode).
-    fn contains_inode(&self) -> bool {
-        self.0.contains(&Block::INode)
-    }
-
-    /// Prepends a [Block] of variant [INode](Block::INode) to `self`.
-    fn prepend_inode(&mut self) {
-        self.0.insert(0, Block::INode);
-    }
-
-    /// Prepends a [Block] of variant [INode](Block::INode), if `self` does not already contain a
-    /// Block of that variant.
-    fn optional_prepend_inode(&mut self) {
-        if !self.contains_inode() {
-            self.prepend_inode()
-        }
-    }
-
-    pub fn displays_size(&self) -> bool {
-        self.0.contains(&Block::Size)
-    }
-
-    /// Tnserts a [Block] of variant [INode](Block::Context), if `self` does not already contain a
-    /// [Block] of that variant. The positioning will be best-effort approximation of coreutils
-    /// ls position for a security context
-    fn optional_insert_context(&mut self) {
-        if self.0.contains(&Block::Context) {
-            return;
-        }
-        let mut pos = self.0.iter().position(|elem| *elem == Block::Group);
-        if pos.is_none() {
-            pos = self.0.iter().position(|elem| *elem == Block::User);
-        }
-        match pos {
-            Some(pos) => self.0.insert(pos + 1, Block::Context),
-            None => self.0.insert(0, Block::Context),
-        }
-    }
 }
 
 /// The default value for `Blocks` contains a [Vec] of [Name](Block::Name).
@@ -196,18 +179,18 @@ pub enum Block {
 }
 
 impl Block {
-    pub fn get_header(&self) -> String {
+    pub fn get_header(&self) -> &'static str {
         match self {
-            Block::INode => String::from("INode"),
-            Block::Links => String::from("Links"),
-            Block::Permission => String::from("Permissions"),
-            Block::User => String::from("User"),
-            Block::Group => String::from("Group"),
-            Block::Context => String::from("Context"),
-            Block::Size => String::from("Size"),
-            Block::SizeValue => String::from("SizeValue"),
-            Block::Date => String::from("Date Modified"),
-            Block::Name => String::from("Name"),
+            Block::INode => "INode",
+            Block::Links => "Links",
+            Block::Permission => "Permissions",
+            Block::User => "User",
+            Block::Group => "Group",
+            Block::Context => "Context",
+            Block::Size => "Size",
+            Block::SizeValue => "SizeValue",
+            Block::Date => "Date Modified",
+            Block::Name => "Name",
         }
     }
 }
@@ -227,7 +210,7 @@ impl TryFrom<&str> for Block {
             "name" => Ok(Self::Name),
             "inode" => Ok(Self::INode),
             "links" => Ok(Self::Links),
-            _ => Err(format!("Not a valid block name: {}", &string)),
+            _ => Err(format!("Not a valid block name: {string}")),
         }
     }
 }
@@ -239,178 +222,141 @@ mod test_blocks {
 
     use crate::app;
     use crate::config_file::Config;
-
-    use clap::Error;
-
-    // The following tests are implemented using match expressions instead of the assert_eq macro,
-    // because clap::Error does not implement PartialEq.
-
-    macro_rules! assert_eq_ok {
-        ($left:expr, $right:expr) => {
-            assert!(
-                match &$left {
-                    Ok(inner) if inner == $right.as_ref().unwrap() => true,
-                    _ => false,
-                },
-                "\nComparison failed:\nWas:       {:?}\nShould be: {:?}\n",
-                &$left,
-                &$right
-            )
-        };
-    }
+    use crate::flags::Configurable;
 
     #[test]
     fn test_configure_from_without_long() {
-        let argv = vec!["lsd"];
-        let target = Ok::<_, Error>(Blocks::default());
+        let argv = ["lsd"];
+        let target = Blocks::default();
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_with_long() {
-        let argv = vec!["lsd", "--long"];
-        let target = Ok::<_, Error>(Blocks::long());
+        let argv = ["lsd", "--long"];
+        let target = Blocks::long();
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_with_blocks_and_without_long() {
-        let argv = vec!["lsd", "--blocks", "permission"];
-        let target = Ok::<_, Error>(Blocks(vec![Block::Permission]));
+        let argv = ["lsd", "--blocks", "permission"];
+        let target = Blocks(vec![Block::Permission]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_with_blocks_and_long() {
-        let argv = vec!["lsd", "--long", "--blocks", "permission"];
-        let target = Ok::<_, Error>(Blocks(vec![Block::Permission]));
+        let argv = ["lsd", "--long", "--blocks", "permission"];
+        let target = Blocks(vec![Block::Permission]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_with_inode() {
-        let argv = vec!["lsd", "--inode"];
-
-        let mut target_blocks = Blocks::default();
-        target_blocks.0.insert(0, Block::INode);
-        let target = Ok::<_, Error>(target_blocks);
+        let argv = ["lsd", "--inode"];
+        let target = Blocks(vec![Block::INode, Block::Name]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_prepend_inode_without_long() {
-        let argv = vec!["lsd", "--blocks", "permission", "--inode"];
-
-        let mut target_blocks = Blocks(vec![Block::Permission]);
-        target_blocks.0.insert(0, Block::INode);
-        let target = Ok::<_, Error>(target_blocks);
+        let argv = ["lsd", "--blocks", "permission", "--inode"];
+        let target = Blocks(vec![Block::INode, Block::Permission]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_prepend_inode_with_long() {
-        let argv = vec!["lsd", "--long", "--blocks", "permission", "--inode"];
-        let target = Ok::<_, Error>(Blocks(vec![Block::INode, Block::Permission]));
+        let argv = ["lsd", "--long", "--blocks", "permission", "--inode"];
+        let target = Blocks(vec![Block::INode, Block::Permission]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_ignore_prepend_inode_without_long() {
-        let argv = vec!["lsd", "--blocks", "permission,inode", "--inode"];
-
-        let target = Ok::<_, Error>(Blocks(vec![Block::Permission, Block::INode]));
+        let argv = ["lsd", "--blocks", "permission,inode", "--inode"];
+        let target = Blocks(vec![Block::Permission, Block::INode]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_configure_from_ignore_prepend_inode_with_long() {
-        let argv = vec!["lsd", "--long", "--blocks", "permission,inode", "--inode"];
-        let target = Ok::<_, Error>(Blocks(vec![Block::Permission, Block::INode]));
+        let argv = ["lsd", "--long", "--blocks", "permission,inode", "--inode"];
+        let target = Blocks(vec![Block::Permission, Block::INode]);
 
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let result = Blocks::configure_from(&matches, &Config::with_none());
 
-        assert_eq_ok!(result, target);
+        assert_eq!(result, target);
     }
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match Blocks::from_arg_matches(&matches) {
-            None => true,
-            _ => false,
-        });
+        assert!(matches!(Blocks::from_arg_matches(&matches), None));
     }
 
     #[test]
     fn test_from_arg_matches_one() {
-        let argv = vec!["lsd", "--blocks", "permission"];
+        let argv = ["lsd", "--blocks", "permission"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let test_blocks = Blocks(vec![Block::Permission]);
-        assert!(match Blocks::from_arg_matches(&matches) {
-            Some(Ok(blocks)) if blocks == test_blocks => true,
-            _ => false,
-        });
+        assert_eq!(Blocks::from_arg_matches(&matches), Some(test_blocks));
     }
 
     #[test]
     fn test_from_arg_matches_multi_occurences() {
-        let argv = vec!["lsd", "--blocks", "permission", "--blocks", "name"];
+        let argv = ["lsd", "--blocks", "permission", "--blocks", "name"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let test_blocks = Blocks(vec![Block::Permission, Block::Name]);
-        assert!(match Blocks::from_arg_matches(&matches) {
-            Some(Ok(blocks)) if blocks == test_blocks => true,
-            _ => false,
-        });
+        assert_eq!(Blocks::from_arg_matches(&matches), Some(test_blocks));
     }
 
     #[test]
     fn test_from_arg_matches_multi_values() {
-        let argv = vec!["lsd", "--blocks", "permission,name"];
+        let argv = ["lsd", "--blocks", "permission,name"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let test_blocks = Blocks(vec![Block::Permission, Block::Name]);
-        assert!(match Blocks::from_arg_matches(&matches) {
-            Some(Ok(blocks)) if blocks == test_blocks => true,
-            _ => false,
-        });
+        assert_eq!(Blocks::from_arg_matches(&matches), Some(test_blocks));
     }
 
     #[test]
     fn test_from_arg_matches_reversed_default() {
-        let argv = vec!["lsd", "--blocks", "name,date,size,group,user,permission"];
+        let argv = ["lsd", "--blocks", "name,date,size,group,user,permission"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let test_blocks = Blocks(vec![
             Block::Name,
@@ -420,21 +366,15 @@ mod test_blocks {
             Block::User,
             Block::Permission,
         ]);
-        assert!(match Blocks::from_arg_matches(&matches) {
-            Some(Ok(blocks)) if blocks == test_blocks => true,
-            _ => false,
-        });
+        assert_eq!(Blocks::from_arg_matches(&matches), Some(test_blocks));
     }
 
     #[test]
     fn test_from_arg_matches_every_second_one() {
-        let argv = vec!["lsd", "--blocks", "permission,group,date"];
+        let argv = ["lsd", "--blocks", "permission,group,date"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let test_blocks = Blocks(vec![Block::Permission, Block::Group, Block::Date]);
-        assert!(match Blocks::from_arg_matches(&matches) {
-            Some(Ok(blocks)) if blocks == test_blocks => true,
-            _ => false,
-        });
+        assert_eq!(Blocks::from_arg_matches(&matches), Some(test_blocks));
     }
 
     #[test]
@@ -445,7 +385,7 @@ mod test_blocks {
     #[test]
     fn test_from_config_one() {
         let mut c = Config::with_none();
-        c.blocks = Some(vec!["permission".into()].into());
+        c.blocks = Some(vec!["permission".into()]);
 
         let blocks = Blocks(vec![Block::Permission]);
         assert_eq!(Some(blocks), Blocks::from_config(&c));
@@ -462,17 +402,14 @@ mod test_blocks {
             Block::Permission,
         ]);
         let mut c = Config::with_none();
-        c.blocks = Some(
-            vec![
-                "name".into(),
-                "date".into(),
-                "size".into(),
-                "group".into(),
-                "user".into(),
-                "permission".into(),
-            ]
-            .into(),
-        );
+        c.blocks = Some(vec![
+            "name".into(),
+            "date".into(),
+            "size".into(),
+            "group".into(),
+            "user".into(),
+            "permission".into(),
+        ]);
 
         assert_eq!(Some(target), Blocks::from_config(&c));
     }
@@ -480,7 +417,7 @@ mod test_blocks {
     #[test]
     fn test_from_config_every_second_one() {
         let mut c = Config::with_none();
-        c.blocks = Some(vec!["permission".into(), "group".into(), "date".into()].into());
+        c.blocks = Some(vec!["permission".into(), "group".into(), "date".into()]);
         let blocks = Blocks(vec![Block::Permission, Block::Group, Block::Date]);
         assert_eq!(Some(blocks), Blocks::from_config(&c));
     }
@@ -488,32 +425,32 @@ mod test_blocks {
     #[test]
     fn test_from_config_invalid_is_ignored() {
         let mut c = Config::with_none();
-        c.blocks = Some(vec!["permission".into(), "foo".into(), "date".into()].into());
+        c.blocks = Some(vec!["permission".into(), "foo".into(), "date".into()]);
         let blocks = Blocks(vec![Block::Permission, Block::Date]);
         assert_eq!(Some(blocks), Blocks::from_config(&c));
     }
 
     #[test]
     fn test_context_not_present_on_cli() {
-        let argv = vec!["lsd", "--long"];
+        let argv = ["lsd", "--long"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        let parsed_blocks = Blocks::configure_from(&matches, &Config::with_none()).unwrap();
+        let parsed_blocks = Blocks::configure_from(&matches, &Config::with_none());
         let it = parsed_blocks.0.iter();
         assert_eq!(it.filter(|&x| *x == Block::Context).count(), 0);
     }
 
     #[test]
     fn test_context_present_if_context_on() {
-        let argv = vec!["lsd", "--context"];
+        let argv = ["lsd", "--context"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        let parsed_blocks = Blocks::configure_from(&matches, &Config::with_none()).unwrap();
+        let parsed_blocks = Blocks::configure_from(&matches, &Config::with_none());
         let it = parsed_blocks.0.iter();
         assert_eq!(it.filter(|&x| *x == Block::Context).count(), 1);
     }
 
     #[test]
     fn test_only_one_context_no_other_blocks_affected() {
-        let argv = vec![
+        let argv = [
             "lsd",
             "--context",
             "--blocks",
@@ -529,7 +466,7 @@ mod test_blocks {
             Block::User,
             Block::Permission,
         ]);
-        let parsed_blocks = Blocks::from_arg_matches(&matches).unwrap().unwrap();
+        let parsed_blocks = Blocks::from_arg_matches(&matches).unwrap();
         assert_eq!(test_blocks, parsed_blocks);
     }
 }
@@ -600,15 +537,15 @@ mod test_block {
 
     #[test]
     fn test_block_headers() {
-        assert_eq!(Block::INode.get_header(), String::from("INode"));
-        assert_eq!(Block::Links.get_header(), String::from("Links"));
-        assert_eq!(Block::Permission.get_header(), String::from("Permissions"));
-        assert_eq!(Block::User.get_header(), String::from("User"));
-        assert_eq!(Block::Group.get_header(), String::from("Group"));
-        assert_eq!(Block::Context.get_header(), String::from("Context"));
-        assert_eq!(Block::Size.get_header(), String::from("Size"));
-        assert_eq!(Block::SizeValue.get_header(), String::from("SizeValue"));
-        assert_eq!(Block::Date.get_header(), String::from("Date Modified"));
-        assert_eq!(Block::Name.get_header(), String::from("Name"));
+        assert_eq!(Block::INode.get_header(), "INode");
+        assert_eq!(Block::Links.get_header(), "Links");
+        assert_eq!(Block::Permission.get_header(), "Permissions");
+        assert_eq!(Block::User.get_header(), "User");
+        assert_eq!(Block::Group.get_header(), "Group");
+        assert_eq!(Block::Context.get_header(), "Context");
+        assert_eq!(Block::Size.get_header(), "Size");
+        assert_eq!(Block::SizeValue.get_header(), "SizeValue");
+        assert_eq!(Block::Date.get_header(), "Date Modified");
+        assert_eq!(Block::Name.get_header(), "Name");
     }
 }
diff --git a/src/flags/color.rs b/src/flags/color.rs
index 4d07baa..3e7a127 100644
--- a/src/flags/color.rs
+++ b/src/flags/color.rs
@@ -4,7 +4,6 @@
 use super::Configurable;
 
 use crate::config_file::Config;
-use crate::print_error;
 
 use clap::ArgMatches;
 use serde::de::{self, Deserializer, Visitor};
@@ -34,9 +33,10 @@ impl Color {
 /// ThemeOption could be one of the following:
 /// Custom(*.yaml): use the YAML theme file as theme file
 /// if error happened, use the default theme
-#[derive(PartialEq, Eq, Debug, Clone)]
+#[derive(PartialEq, Eq, Debug, Clone, Default)]
 pub enum ThemeOption {
     NoColor,
+    #[default]
     Default,
     #[allow(dead_code)]
     NoLscolors,
@@ -45,24 +45,15 @@ pub enum ThemeOption {
 
 impl ThemeOption {
     fn from_config(config: &Config) -> ThemeOption {
-        if let Some(classic) = config.classic {
-            if classic {
-                return ThemeOption::NoColor;
-            }
-        }
-        if let Some(c) = &config.color {
-            if let Some(t) = &c.theme {
-                return t.clone();
-            }
+        if config.classic == Some(true) {
+            ThemeOption::NoColor
+        } else {
+            config
+                .color
+                .as_ref()
+                .and_then(|c| c.theme.clone())
+                .unwrap_or_default()
         }
-
-        ThemeOption::default()
-    }
-}
-
-impl Default for ThemeOption {
-    fn default() -> Self {
-        ThemeOption::Default
     }
 }
 
@@ -96,28 +87,23 @@ impl<'de> de::Deserialize<'de> for ThemeOption {
 }
 
 /// The flag showing when to use colors in the output.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum ColorOption {
     Always,
+    #[default]
     Auto,
     Never,
 }
 
 impl ColorOption {
-    /// Get a Color value from a [String].
-    fn from_str(value: &str) -> Option<Self> {
+    fn from_arg_str(value: &str) -> Self {
         match value {
-            "always" => Some(Self::Always),
-            "auto" => Some(Self::Auto),
-            "never" => Some(Self::Never),
-            _ => {
-                print_error!(
-                    "Config color.when could only be one of auto, always and never, got {}.",
-                    &value
-                );
-                None
-            }
+            "always" => Self::Always,
+            "auto" => Self::Auto,
+            "never" => Self::Never,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'color'"),
         }
     }
 }
@@ -132,11 +118,7 @@ impl Configurable<Self> for ColorOption {
         if matches.is_present("classic") {
             Some(Self::Never)
         } else if matches.occurrences_of("color") > 0 {
-            if let Some(color) = matches.values_of("color")?.last() {
-                Self::from_str(color)
-            } else {
-                panic!("Bad color args. This should not be reachable!");
-            }
+            matches.values_of("color")?.last().map(Self::from_arg_str)
         } else {
             None
         }
@@ -148,14 +130,10 @@ impl Configurable<Self> for ColorOption {
     /// Otherwise if the `Config::color::when` has value and is one of "always", "auto" or "never"
     /// this returns its corresponding variant in a [Some]. Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = config.classic {
-            return Some(Self::Never);
-        }
-
-        if let Some(c) = &config.color {
-            c.when
+        if config.classic == Some(true) {
+            Some(Self::Never)
         } else {
-            None
+            config.color.as_ref().and_then(|c| c.when)
         }
     }
 
@@ -168,13 +146,6 @@ impl Configurable<Self> for ColorOption {
     }
 }
 
-/// The default value for `ColorOption` is [ColorOption::Auto].
-impl Default for ColorOption {
-    fn default() -> Self {
-        Self::Auto
-    }
-}
-
 #[cfg(test)]
 mod test_color_option {
     use super::ColorOption;
@@ -187,14 +158,14 @@ mod test_color_option {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, ColorOption::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_always() {
-        let argv = vec!["lsd", "--color", "always"];
+        let argv = ["lsd", "--color", "always"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(ColorOption::Always),
@@ -204,7 +175,7 @@ mod test_color_option {
 
     #[test]
     fn test_from_arg_matches_auto() {
-        let argv = vec!["lsd", "--color", "auto"];
+        let argv = ["lsd", "--color", "auto"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(ColorOption::Auto),
@@ -214,7 +185,7 @@ mod test_color_option {
 
     #[test]
     fn test_from_arg_matches_never() {
-        let argv = vec!["lsd", "--color", "never"];
+        let argv = ["lsd", "--color", "never"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(ColorOption::Never),
@@ -230,7 +201,7 @@ mod test_color_option {
 
     #[test]
     fn test_from_arg_matches_classic_mode() {
-        let argv = vec!["lsd", "--color", "always", "--classic"];
+        let argv = ["lsd", "--color", "always", "--classic"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(ColorOption::Never),
@@ -240,7 +211,7 @@ mod test_color_option {
 
     #[test]
     fn test_from_arg_matches_color_multiple() {
-        let argv = vec!["lsd", "--color", "always", "--color", "never"];
+        let argv = ["lsd", "--color", "always", "--color", "never"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(ColorOption::Never),
diff --git a/src/flags/date.rs b/src/flags/date.rs
index 2f1195d..e4e0a8e 100644
--- a/src/flags/date.rs
+++ b/src/flags/date.rs
@@ -10,8 +10,9 @@ use crate::print_error;
 use clap::ArgMatches;
 
 /// The flag showing which kind of time stamps to display.
-#[derive(Clone, Debug, PartialEq, Eq)]
+#[derive(Clone, Debug, PartialEq, Eq, Default)]
 pub enum DateFlag {
+    #[default]
     Date,
     Relative,
     Iso,
@@ -21,17 +22,17 @@ pub enum DateFlag {
 impl DateFlag {
     /// Get a value from a date format string
     fn from_format_string(value: &str) -> Option<Self> {
-        match app::validate_time_format(value) {
-            Ok(()) => Some(Self::Formatted(value[1..].to_string())),
-            _ => {
-                print_error!("Not a valid date format: {}.", value);
-                None
-            }
+        if app::validate_time_format(value).is_ok() {
+            Some(Self::Formatted(value[1..].to_string()))
+        } else {
+            print_error!("Not a valid date format: {}.", value);
+            None
         }
     }
 
     /// Get a value from a str.
-    fn from_str(value: &str) -> Option<Self> {
+    fn from_str<S: AsRef<str>>(value: S) -> Option<Self> {
+        let value = value.as_ref();
         match value {
             "date" => Some(Self::Date),
             "relative" => Some(Self::Relative),
@@ -54,14 +55,7 @@ impl Configurable<Self> for DateFlag {
         if matches.is_present("classic") {
             Some(Self::Date)
         } else if matches.occurrences_of("date") > 0 {
-            match matches.values_of("date")?.last() {
-                Some("date") => Some(Self::Date),
-                Some("relative") => Some(Self::Relative),
-                Some(format) if format.starts_with('+') => {
-                    Some(Self::Formatted(format[1..].to_owned()))
-                }
-                _ => panic!("This should not be reachable!"),
-            }
+            matches.values_of("date")?.last().and_then(Self::from_str)
         } else {
             None
         }
@@ -74,14 +68,10 @@ impl Configurable<Self> for DateFlag {
     /// this returns its corresponding variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = &config.classic {
-            return Some(Self::Date);
-        }
-
-        if let Some(date) = &config.date {
-            Self::from_str(date)
+        if config.classic == Some(true) {
+            Some(Self::Date)
         } else {
-            None
+            config.date.as_ref().and_then(Self::from_str)
         }
     }
 
@@ -104,13 +94,6 @@ impl Configurable<Self> for DateFlag {
     }
 }
 
-/// The default value for `DateFlag` is [DateFlag::Date].
-impl Default for DateFlag {
-    fn default() -> Self {
-        Self::Date
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::DateFlag;
@@ -121,21 +104,21 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, DateFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_date() {
-        let argv = vec!["lsd", "--date", "date"];
+        let argv = ["lsd", "--date", "date"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(DateFlag::Date), DateFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_relative() {
-        let argv = vec!["lsd", "--date", "relative"];
+        let argv = ["lsd", "--date", "relative"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DateFlag::Relative),
@@ -145,7 +128,7 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_format() {
-        let argv = vec!["lsd", "--date", "+%F"];
+        let argv = ["lsd", "--date", "+%F"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DateFlag::Formatted("%F".to_string())),
@@ -156,21 +139,21 @@ mod test {
     #[test]
     #[should_panic(expected = "invalid format specifier: %J")]
     fn test_from_arg_matches_format_invalid() {
-        let argv = vec!["lsd", "--date", "+%J"];
+        let argv = ["lsd", "--date", "+%J"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         DateFlag::from_arg_matches(&matches);
     }
 
     #[test]
     fn test_from_arg_matches_classic_mode() {
-        let argv = vec!["lsd", "--date", "date", "--classic"];
+        let argv = ["lsd", "--date", "date", "--classic"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(DateFlag::Date), DateFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_date_multi() {
-        let argv = vec!["lsd", "--date", "relative", "--date", "date"];
+        let argv = ["lsd", "--date", "relative", "--date", "date"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(DateFlag::Date), DateFlag::from_arg_matches(&matches));
     }
@@ -268,7 +251,7 @@ mod test {
     #[serial_test::serial]
     fn test_parsing_order_arg() {
         std::env::set_var("TIME_STYLE", "+%R");
-        let argv = vec!["lsd", "--date", "+%F"];
+        let argv = ["lsd", "--date", "+%F"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let mut config = Config::with_none();
         config.date = Some("+%c".into());
@@ -282,7 +265,7 @@ mod test {
     #[serial_test::serial]
     fn test_parsing_order_env() {
         std::env::set_var("TIME_STYLE", "+%R");
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let mut config = Config::with_none();
         config.date = Some("+%c".into());
@@ -296,7 +279,7 @@ mod test {
     #[serial_test::serial]
     fn test_parsing_order_config() {
         std::env::set_var("TIME_STYLE", "");
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let mut config = Config::with_none();
         config.date = Some("+%c".into());
diff --git a/src/flags/dereference.rs b/src/flags/dereference.rs
index 8c87ef9..7e6de97 100644
--- a/src/flags/dereference.rs
+++ b/src/flags/dereference.rs
@@ -29,7 +29,7 @@ impl Configurable<Self> for Dereference {
     /// If the `Config::dereference` has value, this returns its value
     /// as the value of the `Dereference`, in a [Some], Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        config.dereference.as_ref().map(|deref| Self(*deref))
+        config.dereference.map(Self)
     }
 }
 
@@ -43,14 +43,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, Dereference::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_true() {
-        let argv = vec!["lsd", "--dereference"];
+        let argv = ["lsd", "--dereference"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(Dereference(true)),
diff --git a/src/flags/display.rs b/src/flags/display.rs
index f159b8e..96850db 100644
--- a/src/flags/display.rs
+++ b/src/flags/display.rs
@@ -9,12 +9,13 @@ use clap::ArgMatches;
 use serde::Deserialize;
 
 /// The flag showing which file system nodes to display.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum Display {
     All,
     AlmostAll,
     DirectoryOnly,
+    #[default]
     VisibleOnly,
 }
 
@@ -47,13 +48,6 @@ impl Configurable<Self> for Display {
     }
 }
 
-/// The default value for `Display` is [Display::VisibleOnly].
-impl Default for Display {
-    fn default() -> Self {
-        Display::VisibleOnly
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::Display;
@@ -64,21 +58,21 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, Display::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_all() {
-        let argv = vec!["lsd", "--all"];
+        let argv = ["lsd", "--all"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(Display::All), Display::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_almost_all() {
-        let argv = vec!["lsd", "--almost-all"];
+        let argv = ["lsd", "--almost-all"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(Display::AlmostAll),
@@ -88,7 +82,7 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_directory_only() {
-        let argv = vec!["lsd", "--directory-only"];
+        let argv = ["lsd", "--directory-only"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(Display::DirectoryOnly),
diff --git a/src/flags/header.rs b/src/flags/header.rs
index 845033a..2991df4 100644
--- a/src/flags/header.rs
+++ b/src/flags/header.rs
@@ -44,14 +44,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, Header::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_true() {
-        let argv = vec!["lsd", "--header"];
+        let argv = ["lsd", "--header"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(Header(true)), Header::from_arg_matches(&matches));
     }
diff --git a/src/flags/hyperlink.rs b/src/flags/hyperlink.rs
index b5abba6..bee8ad7 100644
--- a/src/flags/hyperlink.rs
+++ b/src/flags/hyperlink.rs
@@ -9,14 +9,27 @@ use clap::ArgMatches;
 use serde::Deserialize;
 
 /// The flag showing when to use hyperlink in the output.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum HyperlinkOption {
     Always,
     Auto,
+    #[default]
     Never,
 }
 
+impl HyperlinkOption {
+    fn from_arg_str(value: &str) -> Self {
+        match value {
+            "always" => Self::Always,
+            "auto" => Self::Auto,
+            "never" => Self::Never,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'hyperlink'"),
+        }
+    }
+}
+
 impl Configurable<Self> for HyperlinkOption {
     /// Get a potential `HyperlinkOption` variant from [ArgMatches].
     ///
@@ -27,12 +40,10 @@ impl Configurable<Self> for HyperlinkOption {
         if matches.is_present("classic") {
             Some(Self::Never)
         } else if matches.occurrences_of("hyperlink") > 0 {
-            match matches.values_of("hyperlink")?.last() {
-                Some("always") => Some(Self::Always),
-                Some("auto") => Some(Self::Auto),
-                Some("never") => Some(Self::Never),
-                _ => panic!("This should not be reachable!"),
-            }
+            matches
+                .values_of("hyperlink")?
+                .last()
+                .map(Self::from_arg_str)
         } else {
             None
         }
@@ -45,18 +56,11 @@ impl Configurable<Self> for HyperlinkOption {
     /// this returns its corresponding variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = &config.classic {
-            return Some(Self::Never);
+        if config.classic == Some(true) {
+            Some(Self::Never)
+        } else {
+            config.hyperlink
         }
-
-        config.hyperlink
-    }
-}
-
-/// The default value for the `HyperlinkOption` is [HyperlinkOption::Auto].
-impl Default for HyperlinkOption {
-    fn default() -> Self {
-        Self::Never
     }
 }
 
@@ -70,14 +74,14 @@ mod test_hyperlink_option {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, HyperlinkOption::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_always() {
-        let argv = vec!["lsd", "--hyperlink", "always"];
+        let argv = ["lsd", "--hyperlink", "always"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(HyperlinkOption::Always),
@@ -87,7 +91,7 @@ mod test_hyperlink_option {
 
     #[test]
     fn test_from_arg_matches_autp() {
-        let argv = vec!["lsd", "--hyperlink", "auto"];
+        let argv = ["lsd", "--hyperlink", "auto"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(HyperlinkOption::Auto),
@@ -97,7 +101,7 @@ mod test_hyperlink_option {
 
     #[test]
     fn test_from_arg_matches_never() {
-        let argv = vec!["lsd", "--hyperlink", "never"];
+        let argv = ["lsd", "--hyperlink", "never"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(HyperlinkOption::Never),
@@ -107,7 +111,7 @@ mod test_hyperlink_option {
 
     #[test]
     fn test_from_arg_matches_classic_mode() {
-        let argv = vec!["lsd", "--hyperlink", "always", "--classic"];
+        let argv = ["lsd", "--hyperlink", "always", "--classic"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(HyperlinkOption::Never),
@@ -117,7 +121,7 @@ mod test_hyperlink_option {
 
     #[test]
     fn test_from_arg_matches_hyperlink_when_multi() {
-        let argv = vec!["lsd", "--hyperlink", "always", "--hyperlink", "never"];
+        let argv = ["lsd", "--hyperlink", "always", "--hyperlink", "never"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(HyperlinkOption::Never),
diff --git a/src/flags/icons.rs b/src/flags/icons.rs
index 78d0fc6..481d374 100644
--- a/src/flags/icons.rs
+++ b/src/flags/icons.rs
@@ -37,14 +37,27 @@ impl Icons {
 }
 
 /// The flag showing when to use icons in the output.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum IconOption {
     Always,
+    #[default]
     Auto,
     Never,
 }
 
+impl IconOption {
+    fn from_arg_str(value: &str) -> Self {
+        match value {
+            "always" => Self::Always,
+            "auto" => Self::Auto,
+            "never" => Self::Never,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'icon'"),
+        }
+    }
+}
+
 impl Configurable<Self> for IconOption {
     /// Get a potential `IconOption` variant from [ArgMatches].
     ///
@@ -55,12 +68,7 @@ impl Configurable<Self> for IconOption {
         if matches.is_present("classic") {
             Some(Self::Never)
         } else if matches.occurrences_of("icon") > 0 {
-            match matches.values_of("icon")?.last() {
-                Some("always") => Some(Self::Always),
-                Some("auto") => Some(Self::Auto),
-                Some("never") => Some(Self::Never),
-                _ => panic!("This should not be reachable!"),
-            }
+            matches.values_of("icon")?.last().map(Self::from_arg_str)
         } else {
             None
         }
@@ -73,33 +81,34 @@ impl Configurable<Self> for IconOption {
     /// this returns its corresponding variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = &config.classic {
-            return Some(Self::Never);
-        }
-
-        if let Some(icon) = &config.icons {
-            icon.when
+        if config.classic == Some(true) {
+            Some(Self::Never)
         } else {
-            None
+            config.icons.as_ref().and_then(|icon| icon.when)
         }
     }
 }
 
-/// The default value for the `IconOption` is [IconOption::Auto].
-impl Default for IconOption {
-    fn default() -> Self {
-        Self::Auto
-    }
-}
-
 /// The flag showing which icon theme to use.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum IconTheme {
     Unicode,
+    #[default]
     Fancy,
 }
 
+impl IconTheme {
+    fn from_arg_str(value: &str) -> Self {
+        match value {
+            "fancy" => Self::Fancy,
+            "unicode" => Self::Unicode,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'icon-theme'"),
+        }
+    }
+}
+
 impl Configurable<Self> for IconTheme {
     /// Get a potential `IconTheme` variant from [ArgMatches].
     ///
@@ -107,11 +116,10 @@ impl Configurable<Self> for IconTheme {
     /// [Some]. Otherwise this returns [None].
     fn from_arg_matches(matches: &ArgMatches) -> Option<Self> {
         if matches.occurrences_of("icon-theme") > 0 {
-            match matches.values_of("icon-theme")?.last() {
-                Some("fancy") => Some(Self::Fancy),
-                Some("unicode") => Some(Self::Unicode),
-                _ => panic!("This should not be reachable!"),
-            }
+            matches
+                .values_of("icon-theme")?
+                .last()
+                .map(Self::from_arg_str)
         } else {
             None
         }
@@ -123,19 +131,7 @@ impl Configurable<Self> for IconTheme {
     /// this returns its corresponding variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(icon) = &config.icons {
-            if let Some(theme) = icon.theme {
-                return Some(theme);
-            }
-        }
-        None
-    }
-}
-
-/// The default value for `IconTheme` is [IconTheme::Fancy].
-impl Default for IconTheme {
-    fn default() -> Self {
-        Self::Fancy
+        config.icons.as_ref().and_then(|icon| icon.theme)
     }
 }
 
@@ -183,14 +179,14 @@ mod test_icon_option {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, IconOption::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_always() {
-        let argv = vec!["lsd", "--icon", "always"];
+        let argv = ["lsd", "--icon", "always"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconOption::Always),
@@ -200,7 +196,7 @@ mod test_icon_option {
 
     #[test]
     fn test_from_arg_matches_autp() {
-        let argv = vec!["lsd", "--icon", "auto"];
+        let argv = ["lsd", "--icon", "auto"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconOption::Auto),
@@ -210,7 +206,7 @@ mod test_icon_option {
 
     #[test]
     fn test_from_arg_matches_never() {
-        let argv = vec!["lsd", "--icon", "never"];
+        let argv = ["lsd", "--icon", "never"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconOption::Never),
@@ -220,7 +216,7 @@ mod test_icon_option {
 
     #[test]
     fn test_from_arg_matches_classic_mode() {
-        let argv = vec!["lsd", "--icon", "always", "--classic"];
+        let argv = ["lsd", "--icon", "always", "--classic"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconOption::Never),
@@ -230,7 +226,7 @@ mod test_icon_option {
 
     #[test]
     fn test_from_arg_matches_icon_when_multi() {
-        let argv = vec!["lsd", "--icon", "always", "--icon", "never"];
+        let argv = ["lsd", "--icon", "always", "--icon", "never"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconOption::Never),
@@ -299,14 +295,14 @@ mod test_icon_theme {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, IconTheme::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_fancy() {
-        let argv = vec!["lsd", "--icon-theme", "fancy"];
+        let argv = ["lsd", "--icon-theme", "fancy"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconTheme::Fancy),
@@ -316,7 +312,7 @@ mod test_icon_theme {
 
     #[test]
     fn test_from_arg_matches_unicode() {
-        let argv = vec!["lsd", "--icon-theme", "unicode"];
+        let argv = ["lsd", "--icon-theme", "unicode"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconTheme::Unicode),
@@ -326,7 +322,7 @@ mod test_icon_theme {
 
     #[test]
     fn test_from_arg_matches_icon_multi() {
-        let argv = vec!["lsd", "--icon-theme", "fancy", "--icon-theme", "unicode"];
+        let argv = ["lsd", "--icon-theme", "fancy", "--icon-theme", "unicode"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(IconTheme::Unicode),
diff --git a/src/flags/ignore_globs.rs b/src/flags/ignore_globs.rs
index 6207b8a..46c6c78 100644
--- a/src/flags/ignore_globs.rs
+++ b/src/flags/ignore_globs.rs
@@ -98,10 +98,7 @@ impl IgnoreGlobs {
     fn create_glob(pattern: &str) -> Result<Glob, Error> {
         match Glob::new(pattern) {
             Ok(glob) => Ok(glob),
-            Err(err) => Err(Error::with_description(
-                &err.to_string(),
-                ErrorKind::ValueValidation,
-            )),
+            Err(err) => Err(Error::raw(ErrorKind::ValueValidation, err)),
         }
     }
 
@@ -111,10 +108,7 @@ impl IgnoreGlobs {
     fn create_glob_set(builder: &GlobSetBuilder) -> Result<GlobSet, Error> {
         match builder.build() {
             Ok(glob_set) => Ok(glob_set),
-            Err(err) => Err(Error::with_description(
-                &err.to_string(),
-                ErrorKind::ValueValidation,
-            )),
+            Err(err) => Err(Error::raw(ErrorKind::ValueValidation, err)),
         }
     }
 }
@@ -141,55 +135,45 @@ mod test {
 
     #[test]
     fn test_configuration_from_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(
-            match IgnoreGlobs::configure_from(&matches, &Config::with_none()) {
-                Ok(_) => true,
-                _ => false,
-            }
-        );
+        assert!(matches!(
+            IgnoreGlobs::configure_from(&matches, &Config::with_none()),
+            Ok(..)
+        ));
     }
 
     #[test]
     fn test_configuration_from_args() {
-        let argv = vec!["lsd", "--ignore-glob", ".git"];
+        let argv = ["lsd", "--ignore-glob", ".git"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(
-            match IgnoreGlobs::configure_from(&matches, &Config::with_none()) {
-                Ok(_) => true,
-                _ => false,
-            }
-        );
+        assert!(matches!(
+            IgnoreGlobs::configure_from(&matches, &Config::with_none()),
+            Ok(..)
+        ));
     }
 
     #[test]
     fn test_configuration_from_config() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         let mut c = Config::with_none();
-        c.ignore_globs = Some(vec![".git".into()].into());
-        assert!(match IgnoreGlobs::configure_from(&matches, &c) {
-            Ok(_) => true,
-            _ => false,
-        });
+        c.ignore_globs = Some(vec![".git".into()]);
+        assert!(matches!(IgnoreGlobs::configure_from(&matches, &c), Ok(..)));
     }
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match IgnoreGlobs::from_arg_matches(&matches) {
-            None => true,
-            _ => false,
-        });
+        assert!(matches!(IgnoreGlobs::from_arg_matches(&matches), None));
     }
 
     #[test]
     fn test_from_config_none() {
-        assert!(match IgnoreGlobs::from_config(&Config::with_none()) {
-            None => true,
-            _ => false,
-        });
+        assert!(matches!(
+            IgnoreGlobs::from_config(&Config::with_none()),
+            None
+        ));
     }
 }
diff --git a/src/flags/indicators.rs b/src/flags/indicators.rs
index 21df617..f07cd2e 100644
--- a/src/flags/indicators.rs
+++ b/src/flags/indicators.rs
@@ -44,14 +44,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, Indicators::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_true() {
-        let argv = vec!["lsd", "--classify"];
+        let argv = ["lsd", "--classify"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(Indicators(true)),
diff --git a/src/flags/layout.rs b/src/flags/layout.rs
index 1e0da49..ecddb93 100644
--- a/src/flags/layout.rs
+++ b/src/flags/layout.rs
@@ -9,9 +9,10 @@ use clap::ArgMatches;
 use serde::Deserialize;
 
 /// The flag showing which output layout to print.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "lowercase")]
 pub enum Layout {
+    #[default]
     Grid,
     Tree,
     OneLine,
@@ -50,13 +51,6 @@ impl Configurable<Layout> for Layout {
     }
 }
 
-/// The default value for `Layout` is [Layout::Grid].
-impl Default for Layout {
-    fn default() -> Self {
-        Self::Grid
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::Layout;
@@ -67,35 +61,35 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, Layout::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_tree() {
-        let argv = vec!["lsd", "--tree"];
+        let argv = ["lsd", "--tree"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(Layout::Tree), Layout::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_oneline() {
-        let argv = vec!["lsd", "--oneline"];
+        let argv = ["lsd", "--oneline"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(Layout::OneLine), Layout::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_oneline_through_long() {
-        let argv = vec!["lsd", "--long"];
+        let argv = ["lsd", "--long"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(Layout::OneLine), Layout::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_oneline_through_blocks() {
-        let argv = vec!["lsd", "--blocks", "permission,name"];
+        let argv = ["lsd", "--blocks", "permission,name"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(Layout::OneLine), Layout::from_arg_matches(&matches));
     }
diff --git a/src/flags/permission.rs b/src/flags/permission.rs
index 978dea5..26333d7 100644
--- a/src/flags/permission.rs
+++ b/src/flags/permission.rs
@@ -9,26 +9,23 @@ use clap::ArgMatches;
 use serde::Deserialize;
 
 /// The flag showing which file permissions units to use.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum PermissionFlag {
     /// The variant to show file permissions in rwx format
+    #[default]
     Rwx,
     /// The variant to show file permissions in octal format
     Octal,
 }
 
 impl PermissionFlag {
-    fn from_str(value: &str) -> Option<Self> {
+    fn from_arg_str(value: &str) -> Self {
         match value {
-            "rwx" => Some(Self::Rwx),
-            "octal" => Some(Self::Octal),
-            _ => {
-                panic!(
-                    "Permissions can only be one of rwx or octal, but got {}.",
-                    value
-                );
-            }
+            "rwx" => Self::Rwx,
+            "octal" => Self::Octal,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'permission'"),
         }
     }
 }
@@ -42,13 +39,15 @@ impl Configurable<Self> for PermissionFlag {
     /// Sets permissions to rwx if classic flag is enabled.
     fn from_arg_matches(matches: &ArgMatches) -> Option<Self> {
         if matches.is_present("classic") {
-            return Some(Self::Rwx);
+            Some(Self::Rwx)
         } else if matches.occurrences_of("permission") > 0 {
-            if let Some(permissions) = matches.values_of("permission")?.last() {
-                return Self::from_str(permissions);
-            }
+            matches
+                .values_of("permission")?
+                .last()
+                .map(Self::from_arg_str)
+        } else {
+            None
         }
-        None
     }
 
     /// Get a potential `PermissionFlag` variant from a [Config].
@@ -58,7 +57,7 @@ impl Configurable<Self> for PermissionFlag {
     /// Otherwise this returns [None].
     /// Sets permissions to rwx if classic flag is enabled.
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = config.classic {
+        if config.classic == Some(true) {
             Some(Self::Rwx)
         } else {
             config.permission
@@ -66,13 +65,6 @@ impl Configurable<Self> for PermissionFlag {
     }
 }
 
-/// The default value for `PermissionFlag` is [PermissionFlag::Default].
-impl Default for PermissionFlag {
-    fn default() -> Self {
-        Self::Rwx
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::PermissionFlag;
@@ -88,14 +80,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, PermissionFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_default() {
-        let argv = vec!["lsd", "--permission", "rwx"];
+        let argv = ["lsd", "--permission", "rwx"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(PermissionFlag::Rwx),
@@ -105,8 +97,8 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_short() {
-        let args = vec!["lsd", "--permission", "octal"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--permission", "octal"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(PermissionFlag::Octal),
             PermissionFlag::from_arg_matches(&matches)
@@ -116,13 +108,13 @@ mod test {
     #[test]
     #[should_panic]
     fn test_from_arg_matches_unknown() {
-        let args = vec!["lsd", "--permission", "unknown"];
-        let _ = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--permission", "unknown"];
+        let _ = app::build().get_matches_from_safe(argv).unwrap();
     }
     #[test]
     fn test_from_arg_matches_permissions_multi() {
-        let args = vec!["lsd", "--permission", "octal", "--permission", "rwx"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--permission", "octal", "--permission", "rwx"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(PermissionFlag::Rwx),
             PermissionFlag::from_arg_matches(&matches)
@@ -131,8 +123,8 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_permissions_classic() {
-        let args = vec!["lsd", "--permission", "rwx", "--classic"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--permission", "rwx", "--classic"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(PermissionFlag::Rwx),
             PermissionFlag::from_arg_matches(&matches)
diff --git a/src/flags/recursion.rs b/src/flags/recursion.rs
index 0120be7..27b0311 100644
--- a/src/flags/recursion.rs
+++ b/src/flags/recursion.rs
@@ -84,7 +84,7 @@ impl Recursion {
             }
         }
 
-        Ok(usize::max_value())
+        Ok(usize::MAX)
     }
 
     /// Get a potential "depth" value from [ArgMatches].
@@ -106,9 +106,9 @@ impl Recursion {
             match str.parse::<usize>() {
                 Ok(value) => return Some(Ok(value)),
                 Err(_) => {
-                    return Some(Err(Error::with_description(
-                        "The argument '--depth' requires a valid positive number.",
+                    return Some(Err(Error::raw(
                         ErrorKind::ValueValidation,
+                        "The argument '--depth' requires a valid positive number.",
                     )))
                 }
             }
@@ -121,7 +121,7 @@ impl Recursion {
 impl Default for Recursion {
     fn default() -> Self {
         Self {
-            depth: usize::max_value(),
+            depth: usize::MAX,
             enabled: false,
         }
     }
@@ -138,56 +138,53 @@ mod test {
 
     #[test]
     fn test_enabled_from_arg_matches_empty() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, Recursion::enabled_from_arg_matches(&matches));
     }
 
     #[test]
     fn test_enabled_from_arg_matches_true() {
-        let argv = vec!["lsd", "--recursive"];
+        let argv = ["lsd", "--recursive"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(true), Recursion::enabled_from_arg_matches(&matches));
     }
 
     #[test]
     fn test_enabled_from_empty_matches_and_config() {
-        let argv = vec!["lsd"];
-        assert_eq!(
-            false,
-            Recursion::enabled_from(
-                &app::build().get_matches_from_safe(argv).unwrap(),
-                &Config::with_none()
-            )
-        );
+        let argv = ["lsd"];
+        assert!(!Recursion::enabled_from(
+            &app::build().get_matches_from_safe(argv).unwrap(),
+            &Config::with_none()
+        ));
     }
 
     #[test]
     fn test_enabled_from_matches_empty_and_config_true() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let mut c = Config::with_none();
         c.recursion = Some(config_file::Recursion {
             enabled: Some(true),
             depth: None,
         });
-        assert_eq!(
-            true,
-            Recursion::enabled_from(&app::build().get_matches_from_safe(argv).unwrap(), &c)
-        );
+        assert!(Recursion::enabled_from(
+            &app::build().get_matches_from_safe(argv).unwrap(),
+            &c
+        ));
     }
 
     #[test]
     fn test_enabled_from_matches_empty_and_config_false() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let mut c = Config::with_none();
         c.recursion = Some(config_file::Recursion {
             enabled: Some(false),
             depth: None,
         });
-        assert_eq!(
-            false,
-            Recursion::enabled_from(&app::build().get_matches_from_safe(argv).unwrap(), &c)
-        );
+        assert!(!Recursion::enabled_from(
+            &app::build().get_matches_from_safe(argv).unwrap(),
+            &c
+        ));
     }
 
     // The following depth_from_arg_matches tests are implemented using match expressions instead
@@ -195,79 +192,52 @@ mod test {
 
     #[test]
     fn test_depth_from_arg_matches_empty() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match Recursion::depth_from_arg_matches(&matches) {
-            None => true,
-            _ => false,
-        });
+        assert!(matches!(Recursion::depth_from_arg_matches(&matches), None));
     }
 
     #[test]
     fn test_depth_from_arg_matches_integer() {
-        let argv = vec!["lsd", "--depth", "42"];
+        let argv = ["lsd", "--depth", "42"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match Recursion::depth_from_arg_matches(&matches) {
-            None => false,
-            Some(result) => {
-                match result {
-                    Ok(value) => value == 42,
-                    Err(_) => false,
-                }
-            }
-        });
+        assert!(
+            matches!(Recursion::depth_from_arg_matches(&matches), Some(Ok(value)) if value == 42)
+        );
     }
 
     #[test]
     fn test_depth_from_arg_matches_depth_multi() {
-        let argv = vec!["lsd", "--depth", "4", "--depth", "2"];
+        let argv = ["lsd", "--depth", "4", "--depth", "2"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match Recursion::depth_from_arg_matches(&matches) {
-            None => false,
-            Some(result) => {
-                match result {
-                    Ok(value) => value == 2,
-                    Err(_) => false,
-                }
-            }
-        });
+        assert!(
+            matches!(Recursion::depth_from_arg_matches(&matches), Some(Ok(value)) if value == 2)
+        );
     }
 
     #[test]
     fn test_depth_from_arg_matches_neg_int() {
-        let argv = vec!["lsd", "--depth", "\\-42"];
+        let argv = ["lsd", "--depth", "\\-42"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match Recursion::depth_from_arg_matches(&matches) {
-            None => false,
-            Some(result) => {
-                match result {
-                    Ok(_) => false,
-                    Err(error) => error.kind == ErrorKind::ValueValidation,
-                }
-            }
-        });
+        assert!(
+            matches!(Recursion::depth_from_arg_matches(&matches), Some(Err(e)) if e.kind == ErrorKind::ValueValidation)
+        );
     }
 
     #[test]
     fn test_depth_from_arg_matches_non_int() {
-        let argv = vec!["lsd", "--depth", "foo"];
+        let argv = ["lsd", "--depth", "foo"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
-        assert!(match Recursion::depth_from_arg_matches(&matches) {
-            None => false,
-            Some(result) => {
-                match result {
-                    Ok(_) => false,
-                    Err(error) => error.kind == ErrorKind::ValueValidation,
-                }
-            }
-        });
+        assert!(
+            matches!(Recursion::depth_from_arg_matches(&matches), Some(Err(e)) if e.kind == ErrorKind::ValueValidation)
+        );
     }
 
     #[test]
     fn test_depth_from_config_none_max() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         assert_eq!(
-            usize::max_value(),
+            usize::MAX,
             Recursion::depth_from(
                 &app::build().get_matches_from_safe(argv).unwrap(),
                 &Config::with_none()
@@ -278,7 +248,7 @@ mod test {
 
     #[test]
     fn test_depth_from_config_pos_integer() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let mut c = Config::with_none();
         c.recursion = Some(config_file::Recursion {
             enabled: None,
diff --git a/src/flags/size.rs b/src/flags/size.rs
index 9f40d6a..caa45a8 100644
--- a/src/flags/size.rs
+++ b/src/flags/size.rs
@@ -9,10 +9,11 @@ use clap::ArgMatches;
 use serde::Deserialize;
 
 /// The flag showing which file size units to use.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum SizeFlag {
     /// The variant to show file size with SI unit prefix and a B for bytes.
+    #[default]
     Default,
     /// The variant to show file size with only the SI unit prefix.
     Short,
@@ -21,17 +22,13 @@ pub enum SizeFlag {
 }
 
 impl SizeFlag {
-    fn from_str(value: &str) -> Option<Self> {
+    fn from_arg_str(value: &str) -> Self {
         match value {
-            "default" => Some(Self::Default),
-            "short" => Some(Self::Short),
-            "bytes" => Some(Self::Bytes),
-            _ => {
-                panic!(
-                    "Size can only be one of default, short or bytes, but got {}.",
-                    value
-                );
-            }
+            "default" => Self::Default,
+            "short" => Self::Short,
+            "bytes" => Self::Bytes,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'size'"),
         }
     }
 }
@@ -44,13 +41,12 @@ impl Configurable<Self> for SizeFlag {
     /// [None].
     fn from_arg_matches(matches: &ArgMatches) -> Option<Self> {
         if matches.is_present("classic") {
-            return Some(Self::Bytes);
+            Some(Self::Bytes)
         } else if matches.occurrences_of("size") > 0 {
-            if let Some(size) = matches.values_of("size")?.last() {
-                return Self::from_str(size);
-            }
+            matches.values_of("size")?.last().map(Self::from_arg_str)
+        } else {
+            None
         }
-        None
     }
 
     /// Get a potential `SizeFlag` variant from a [Config].
@@ -59,7 +55,7 @@ impl Configurable<Self> for SizeFlag {
     /// this returns the corresponding `SizeFlag` variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = config.classic {
+        if config.classic == Some(true) {
             Some(Self::Bytes)
         } else {
             config.size
@@ -67,13 +63,6 @@ impl Configurable<Self> for SizeFlag {
     }
 }
 
-/// The default value for `SizeFlag` is [SizeFlag::Default].
-impl Default for SizeFlag {
-    fn default() -> Self {
-        Self::Default
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::SizeFlag;
@@ -89,14 +78,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, SizeFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_default() {
-        let argv = vec!["lsd", "--size", "default"];
+        let argv = ["lsd", "--size", "default"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SizeFlag::Default),
@@ -106,35 +95,35 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_short() {
-        let args = vec!["lsd", "--size", "short"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--size", "short"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(SizeFlag::Short), SizeFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_bytes() {
-        let args = vec!["lsd", "--size", "bytes"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--size", "bytes"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(SizeFlag::Bytes), SizeFlag::from_arg_matches(&matches));
     }
 
     #[test]
     #[should_panic]
     fn test_from_arg_matches_unknonwn() {
-        let args = vec!["lsd", "--size", "unknown"];
-        let _ = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--size", "unknown"];
+        let _ = app::build().get_matches_from_safe(argv).unwrap();
     }
     #[test]
     fn test_from_arg_matches_size_multi() {
-        let args = vec!["lsd", "--size", "bytes", "--size", "short"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--size", "bytes", "--size", "short"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(SizeFlag::Short), SizeFlag::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_size_classic() {
-        let args = vec!["lsd", "--size", "short", "--classic"];
-        let matches = app::build().get_matches_from_safe(args).unwrap();
+        let argv = ["lsd", "--size", "short", "--classic"];
+        let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(SizeFlag::Bytes), SizeFlag::from_arg_matches(&matches));
     }
 
diff --git a/src/flags/sorting.rs b/src/flags/sorting.rs
index a791f93..76b0b47 100644
--- a/src/flags/sorting.rs
+++ b/src/flags/sorting.rs
@@ -34,11 +34,12 @@ impl Sorting {
 }
 
 /// The flag showing which column to use for sorting.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum SortColumn {
     None,
     Extension,
+    #[default]
     Name,
     Time,
     Size,
@@ -51,10 +52,8 @@ impl Configurable<Self> for SortColumn {
     /// If either the "timesort" or "sizesort" arguments are passed, this returns the corresponding
     /// `SortColumn` variant in a [Some]. Otherwise this returns [None].
     fn from_arg_matches(matches: &ArgMatches) -> Option<Self> {
-        let sort = match matches.values_of("sort") {
-            Some(s) => s.last(),
-            None => None,
-        };
+        let sort = matches.values_of("sort").and_then(|s| s.last());
+
         if matches.is_present("timesort") || sort == Some("time") {
             Some(Self::Time)
         } else if matches.is_present("sizesort") || sort == Some("size") {
@@ -76,24 +75,14 @@ impl Configurable<Self> for SortColumn {
     /// this returns the corresponding variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(sort) = &config.sorting {
-            sort.column
-        } else {
-            None
-        }
-    }
-}
-
-/// The default value for `SortColumn` is [SortColumn::Name].
-impl Default for SortColumn {
-    fn default() -> Self {
-        Self::Name
+        config.sorting.as_ref().and_then(|s| s.column)
     }
 }
 
 /// The flag showing which sort order to use.
-#[derive(Clone, Debug, Copy, PartialEq, Eq)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Default)]
 pub enum SortOrder {
+    #[default]
     Default,
     Reverse,
 }
@@ -118,48 +107,32 @@ impl Configurable<Self> for SortOrder {
     /// Otherwise [None] is returned.
     /// A `true` maps to [SortOrder::Reverse] while `false` maps to [SortOrder::Default].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(sort) = &config.sorting {
-            if let Some(reverse) = sort.reverse {
-                if reverse {
-                    Some(Self::Reverse)
-                } else {
-                    Some(Self::Default)
-                }
-            } else {
-                None
-            }
-        } else {
-            None
-        }
-    }
-}
-
-/// The default value for `SortOrder` is [SortOrder::Default].
-impl Default for SortOrder {
-    fn default() -> Self {
-        Self::Default
+        config.sorting.as_ref().and_then(|s| match s.reverse {
+            Some(true) => Some(Self::Reverse),
+            Some(false) => Some(Self::Default),
+            None => None,
+        })
     }
 }
 
 /// The flag showing where to place directories.
-#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize)]
+#[derive(Clone, Debug, Copy, PartialEq, Eq, Deserialize, Default)]
 #[serde(rename_all = "kebab-case")]
 pub enum DirGrouping {
+    #[default]
     None,
     First,
     Last,
 }
 
 impl DirGrouping {
-    fn from_str(value: &str) -> Option<Self> {
+    fn from_arg_str(value: &str) -> Self {
         match value {
-            "first" => Some(Self::First),
-            "last" => Some(Self::Last),
-            "none" => Some(Self::None),
-            _ => panic!(
-                "Group Dir can only be one of first, last or none, but got {}.",
-                value
-            ),
+            "first" => Self::First,
+            "last" => Self::Last,
+            "none" => Self::None,
+            // Invalid value should be handled by `clap` when building an `ArgMatches`
+            other => unreachable!("Invalid value '{other}' for 'group-dirs'"),
         }
     }
 }
@@ -179,10 +152,12 @@ impl Configurable<Self> for DirGrouping {
         }
 
         if matches.occurrences_of("group-dirs") > 0 {
-            if let Some(group_dirs) = matches.values_of("group-dirs")?.last() {
-                return Self::from_str(group_dirs);
-            }
+            return matches
+                .values_of("group-dirs")?
+                .last()
+                .map(Self::from_arg_str);
         }
+
         None
     }
 
@@ -194,20 +169,11 @@ impl Configurable<Self> for DirGrouping {
     /// is one of "first", "last" or "none", this returns its corresponding variant in a [Some].
     /// Otherwise this returns [None].
     fn from_config(config: &Config) -> Option<Self> {
-        if let Some(true) = config.classic {
-            return Some(Self::None);
-        }
-        if let Some(sort) = &config.sorting {
-            return sort.dir_grouping;
+        if config.classic == Some(true) {
+            Some(Self::None)
+        } else {
+            config.sorting.as_ref().and_then(|s| s.dir_grouping)
         }
-        None
-    }
-}
-
-/// The default value for `DirGrouping` is [DirGrouping::None].
-impl Default for DirGrouping {
-    fn default() -> Self {
-        Self::None
     }
 }
 
@@ -221,14 +187,14 @@ mod test_sort_column {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, SortColumn::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_extension() {
-        let argv = vec!["lsd", "--extensionsort"];
+        let argv = ["lsd", "--extensionsort"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Extension),
@@ -238,7 +204,7 @@ mod test_sort_column {
 
     #[test]
     fn test_from_arg_matches_time() {
-        let argv = vec!["lsd", "--timesort"];
+        let argv = ["lsd", "--timesort"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Time),
@@ -248,7 +214,7 @@ mod test_sort_column {
 
     #[test]
     fn test_from_arg_matches_size() {
-        let argv = vec!["lsd", "--sizesort"];
+        let argv = ["lsd", "--sizesort"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Size),
@@ -258,7 +224,7 @@ mod test_sort_column {
 
     #[test]
     fn test_from_arg_matches_version() {
-        let argv = vec!["lsd", "--versionsort"];
+        let argv = ["lsd", "--versionsort"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Version),
@@ -268,7 +234,7 @@ mod test_sort_column {
 
     #[test]
     fn test_from_arg_matches_no_sort() {
-        let argv = vec!["lsd", "--no-sort"];
+        let argv = ["lsd", "--no-sort"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::None),
@@ -278,35 +244,35 @@ mod test_sort_column {
 
     #[test]
     fn test_from_arg_matches_sort() {
-        let argv = vec!["lsd", "--sort", "time"];
+        let argv = ["lsd", "--sort", "time"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Time),
             SortColumn::from_arg_matches(&matches)
         );
 
-        let argv = vec!["lsd", "--sort", "size"];
+        let argv = ["lsd", "--sort", "size"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Size),
             SortColumn::from_arg_matches(&matches)
         );
 
-        let argv = vec!["lsd", "--sort", "extension"];
+        let argv = ["lsd", "--sort", "extension"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Extension),
             SortColumn::from_arg_matches(&matches)
         );
 
-        let argv = vec!["lsd", "--sort", "version"];
+        let argv = ["lsd", "--sort", "version"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Version),
             SortColumn::from_arg_matches(&matches)
         );
 
-        let argv = vec!["lsd", "--sort", "none"];
+        let argv = ["lsd", "--sort", "none"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::None),
@@ -316,7 +282,7 @@ mod test_sort_column {
 
     #[test]
     fn test_multi_sort() {
-        let argv = vec!["lsd", "--sort", "size", "--sort", "time"];
+        let argv = ["lsd", "--sort", "size", "--sort", "time"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Time),
@@ -326,7 +292,7 @@ mod test_sort_column {
 
     #[test]
     fn test_multi_sort_use_last() {
-        let argv = vec!["lsd", "--sort", "size", "-t", "-S", "-X", "--sort", "time"];
+        let argv = ["lsd", "--sort", "size", "-t", "-S", "-X", "--sort", "time"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortColumn::Time),
@@ -417,14 +383,14 @@ mod test_sort_order {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, SortOrder::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_reverse() {
-        let argv = vec!["lsd", "--reverse"];
+        let argv = ["lsd", "--reverse"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(SortOrder::Reverse),
@@ -488,23 +454,21 @@ mod test_dir_grouping {
     use crate::flags::Configurable;
 
     #[test]
-    #[should_panic(
-        expected = "Group Dir can only be one of first, last or none, but got bad value."
-    )]
+    #[should_panic]
     fn test_from_str_bad_value() {
-        assert_eq!(None, DirGrouping::from_str("bad value"));
+        DirGrouping::from_arg_str("bad value");
     }
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, DirGrouping::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_first() {
-        let argv = vec!["lsd", "--group-dirs", "first"];
+        let argv = ["lsd", "--group-dirs", "first"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DirGrouping::First),
@@ -514,7 +478,7 @@ mod test_dir_grouping {
 
     #[test]
     fn test_from_arg_matches_last() {
-        let argv = vec!["lsd", "--group-dirs", "last"];
+        let argv = ["lsd", "--group-dirs", "last"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DirGrouping::Last),
@@ -524,7 +488,7 @@ mod test_dir_grouping {
 
     #[test]
     fn test_from_arg_matches_explicit_none() {
-        let argv = vec!["lsd", "--group-dirs", "none"];
+        let argv = ["lsd", "--group-dirs", "none"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DirGrouping::None),
@@ -534,7 +498,7 @@ mod test_dir_grouping {
 
     #[test]
     fn test_from_arg_matches_classic_mode() {
-        let argv = vec!["lsd", "--group-dirs", "first", "--classic"];
+        let argv = ["lsd", "--group-dirs", "first", "--classic"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DirGrouping::None),
@@ -544,7 +508,7 @@ mod test_dir_grouping {
 
     #[test]
     fn test_from_arg_matches_group_dirs_multi() {
-        let argv = vec!["lsd", "--group-dirs", "first", "--group-dirs", "last"];
+        let argv = ["lsd", "--group-dirs", "first", "--group-dirs", "last"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DirGrouping::Last),
@@ -554,7 +518,7 @@ mod test_dir_grouping {
 
     #[test]
     fn test_from_arg_matches_group_directories_first() {
-        let argv = vec!["lsd", "--group-directories-first"];
+        let argv = ["lsd", "--group-directories-first"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             Some(DirGrouping::First),
diff --git a/src/flags/symlinks.rs b/src/flags/symlinks.rs
index c2960a8..6afc5c4 100644
--- a/src/flags/symlinks.rs
+++ b/src/flags/symlinks.rs
@@ -44,14 +44,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, NoSymlink::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_true() {
-        let argv = vec!["lsd", "--no-symlink"];
+        let argv = ["lsd", "--no-symlink"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(NoSymlink(true)), NoSymlink::from_arg_matches(&matches));
     }
diff --git a/src/flags/total_size.rs b/src/flags/total_size.rs
index 3b5ab6f..7637052 100644
--- a/src/flags/total_size.rs
+++ b/src/flags/total_size.rs
@@ -44,14 +44,14 @@ mod test {
 
     #[test]
     fn test_from_arg_matches_none() {
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(None, TotalSize::from_arg_matches(&matches));
     }
 
     #[test]
     fn test_from_arg_matches_true() {
-        let argv = vec!["lsd", "--total-size"];
+        let argv = ["lsd", "--total-size"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(Some(TotalSize(true)), TotalSize::from_arg_matches(&matches));
     }
diff --git a/src/icon.rs b/src/icon.rs
index db1b510..d7323d0 100644
--- a/src/icon.rs
+++ b/src/icon.rs
@@ -23,7 +23,7 @@ pub enum Theme {
 // s#\\u[0-9a-f]*#\=eval('"'.submatch(0).'"')#
 impl Icons {
     pub fn new(theme: Theme, icon_separator: String) -> Self {
-        let display_icons = theme == Theme::Fancy || theme == Theme::Unicode;
+        let display_icons = matches!(theme, Theme::Fancy | Theme::Unicode);
         let (icons_by_name, icons_by_extension, default_file_icon, default_folder_icon) =
             if theme == Theme::Fancy {
                 (
@@ -58,437 +58,427 @@ impl Icons {
 
         // Check file types
         let file_type: FileType = name.file_type();
-
-        let icon = if let FileType::SymLink { is_dir: true } = file_type {
-            "\u{f482}" // ""
-        } else if let FileType::SymLink { is_dir: false } = file_type {
-            "\u{f481}" // ""
-        } else if let FileType::Socket = file_type {
-            "\u{f6a7}" // ""
-        } else if let FileType::Pipe = file_type {
-            "\u{f731}" // ""
-        } else if let FileType::CharDevice = file_type {
-            "\u{e601}" // ""
-        } else if let FileType::BlockDevice = file_type {
-            "\u{fc29}" // "ﰩ"
-        } else if let FileType::Special = file_type {
-            "\u{f2dc}" // ""
-        } else if let Some(icon) = self
-            .icons_by_name
-            .get(name.file_name().to_lowercase().as_str())
-        {
-            // Use the known names.
-            icon
-        } else if let Some(icon) = name.extension().and_then(|extension| {
-            self.icons_by_extension
-                .get(extension.to_lowercase().as_str())
-        }) {
-            // Use the known extensions.
-            icon
-        } else if let FileType::Directory { .. } = file_type {
-            self.default_folder_icon
-        } else if let FileType::File { exec: true, .. } = file_type {
-            // If file has no extension and is executable
-            if cfg!(windows) {
-                // Windows marks everything as executable
-                self.default_file_icon // 
-            } else {
-                "\u{f489}" // ""
+        let icon = match file_type {
+            FileType::SymLink { is_dir: true } => "\u{f482}", // ""
+            FileType::SymLink { is_dir: false } => "\u{f481}", // ""
+            FileType::Socket => "\u{f6a7}",                   // ""
+            FileType::Pipe => "\u{f731}",                     // ""
+            FileType::CharDevice => "\u{e601}",               // ""
+            FileType::BlockDevice => "\u{fc29}",              // "ﰩ"
+            FileType::Special => "\u{f2dc}",                  // ""
+            _ => {
+                // Use the known names
+                if let Some(icon) = self
+                    .icons_by_name
+                    .get(name.file_name().to_lowercase().as_str())
+                {
+                    icon
+                }
+                // Use the known extensions
+                else if let Some(icon) = name.extension().and_then(|extension| {
+                    self.icons_by_extension
+                        .get(extension.to_lowercase().as_str())
+                }) {
+                    icon
+                } else {
+                    match file_type {
+                        FileType::Directory { .. } => self.default_folder_icon,
+                        // If a file has no extension and is executable, show an icon.
+                        // Except for Windows, it marks everything as an executable.
+                        #[cfg(not(windows))]
+                        FileType::File { exec: true, .. } => "\u{f489}", // ""
+                        _ => self.default_file_icon,
+                    }
+                }
             }
-        } else {
-            // Use the default icons.
-            self.default_file_icon
         };
 
         format!("{}{}", icon, self.icon_separator)
     }
 
     fn get_default_icons_by_name() -> HashMap<&'static str, &'static str> {
-        let mut m = HashMap::new();
-
         // Note: filenames must be lower-case
-
-        m.insert(".trash", "\u{f1f8}"); // ""
-        m.insert(".atom", "\u{e764}"); // ""
-        m.insert(".bash_profile", "\u{e615}"); // ""
-        m.insert(".bash_logout", "\u{e615}");
-        m.insert(".bashrc", "\u{f489}"); // ""
-        m.insert(".cargo", "\u{e7a8}"); // ""
-        m.insert(".clang-format", "\u{e615}"); // ""
-        m.insert(".config", "\u{e5fc}"); // ""
-        m.insert(".emacs.d", "\u{e779}"); // ""
-        m.insert(".doom.d", "\u{e779}"); // ""
-        m.insert(".git", "\u{e5fb}"); // ""
-        m.insert(".gitattributes", "\u{f1d3}"); // ""
-        m.insert(".gitconfig", "\u{f1d3}"); // ""
-        m.insert(".github", "\u{e5fd}"); // ""
-        m.insert(".gitignore", "\u{f1d3}"); // ""
-        m.insert(".gitlab-ci.yml", "\u{f296}"); // ""
-        m.insert(".gitmodules", "\u{f1d3}"); // ""
-        m.insert(".htaccess", "\u{e615}"); // ""
-        m.insert(".htpasswd", "\u{e615}"); // ""
-        m.insert(".inputrc", "\u{e615}"); // ""
-        m.insert(".node_repl_history", "\u{e718}"); // ""
-        m.insert(".npm", "\u{e5fa}"); // ""
-        m.insert(".python_history", "\u{e606}"); // ""
-        m.insert(".release.toml", "\u{e7a8}"); // ""
-        m.insert(".rvm", "\u{e21e}"); // ""
-        m.insert(".ssh", "\u{f023}"); // ""
-        m.insert(".vim", "\u{e62b}"); // ""
-        m.insert(".vimrc", "\u{e62b}"); // ""
-        m.insert(".viminfo", "\u{e62b}");
-        m.insert(".vscode", "\u{e70c}"); // ""
-        m.insert(".xauthority", "\u{e615}"); // ""
-        m.insert(".xinitrc", "\u{e615}"); // ""
-        m.insert(".xresources", "\u{e615}"); // ""
-        m.insert(".zshrc", "\u{f489}"); // ""
-        m.insert(".zsh_history", "\u{e615}"); // ""
-        m.insert("a.out", "\u{f489}"); // ""
-        m.insert("authorized_keys", "\u{e60a}"); // ""
-        m.insert("bin", "\u{e5fc}"); // ""
-        m.insert("bspwmrc", "\u{e615}"); // ""
-        m.insert("cargo.toml", "\u{e7a8}"); // ""
-        m.insert("cargo.lock", "\u{e7a8}"); // ""
-        m.insert("changelog", "\u{e609}"); // ""
-        m.insert("composer.json", "\u{e608}"); // ""
-        m.insert("config", "\u{e5fc}"); // ""
-        m.insert("config.ac", "\u{e615}"); // ""
-        m.insert("config.mk", "\u{e615}"); // ""
-        m.insert("config.el", "\u{e779}"); // ""
-        m.insert("custom.el", "\u{e779}"); // ""
-        m.insert("contributing", "\u{e60a}"); // ""
-        m.insert("cron.d", "\u{e5fc}"); // ""
-        m.insert("cron.daily", "\u{e5fc}"); // ""
-        m.insert("cron.hourly", "\u{e5fc}"); // ""
-        m.insert("cron.weekly", "\u{e5fc}"); // ""
-        m.insert("cron.monthly", "\u{e5fc}"); // ""
-        m.insert("crontab", "\u{e615}"); // ""
-        m.insert("crypttab", "\u{e615}"); // ""
-        m.insert("desktop", "\u{f108}"); // ""
-        m.insert("downloads", "\u{f498}"); // ""
-        m.insert("docker-compose.yml", "\u{f308}"); // ""
-        m.insert("dockerfile", "\u{f308}"); // ""
-        m.insert("documents", "\u{f02d}"); // ""
-        m.insert(".ds_store", "\u{f179}"); // ""
-        m.insert("etc", "\u{e5fc}"); // ""
-        m.insert("favicon.ico", "\u{f005}"); // ""
-        m.insert("fstab", "\u{f1c0}"); // ""
-        m.insert("gitignore_global", "\u{f1d3}"); // ""
-        m.insert("gradle", "\u{e70e}"); // ""
-        m.insert("group", "\u{e615}"); // ""
-        m.insert("gruntfile.coffee", "\u{e611}"); // ""
-        m.insert("gruntfile.js", "\u{e611}"); // ""
-        m.insert("gruntfile.ls", "\u{e611}"); // ""
-        m.insert("gshadow", "\u{e615}"); // ""
-        m.insert("gulpfile.coffee", "\u{e610}"); // ""
-        m.insert("gulpfile.js", "\u{e610}"); // ""
-        m.insert("gulpfile.ls", "\u{e610}"); // ""
-        m.insert("hidden", "\u{f023}"); // ""
-        m.insert("hosts", "\u{f502}"); // ""
-        m.insert("htoprc", "\u{e615}"); // ""
-        m.insert("include", "\u{e5fc}"); // ""
-        m.insert("init.el", "\u{e779}"); // ""
-        m.insert("known_hosts", "\u{e60a}"); // ""
-        m.insert("lib", "\u{f121}"); // ""
-        m.insert("license", "\u{e60a}"); // ""
-        m.insert("license.md", "\u{e60a}"); // ""
-        m.insert("license.txt", "\u{e60a}"); // ""
-        m.insert("localized", "\u{f179}"); // ""
-        m.insert("mail", "\u{f6ef}"); // ""
-        m.insert("makefile", "\u{e615}"); // ""
-        m.insert("makefile.ac", "\u{e615}"); // ""
-        m.insert("music", "\u{f025}"); // ""
-        m.insert("muttrc", "\u{e615}"); // ""
-        m.insert("node_modules", "\u{e5fa}"); // ""
-        m.insert("npmignore", "\u{e71e}"); // ""
-        m.insert("package.json", "\u{e718}"); // ""
-        m.insert("packages.el", "\u{e779}"); // ""
-        m.insert("package-lock.json", "\u{e718}"); // ""
-        m.insert("passwd", "\u{f023}"); // ""
-        m.insert("pictures", "\u{f03e}"); // ""
-        m.insert("profile", "\u{e615}"); // ""
-        m.insert("readme", "\u{e609}"); // ""
-        m.insert("rc.lua", "\u{e615}"); // ""
-        m.insert("rubydoc", "\u{e73b}"); // ""
-        m.insert("robots.txt", "\u{fba7}"); // "ﮧ"
-        m.insert("root", "\u{f023}"); // ""
-        m.insert("shadow", "\u{e615}"); // ""
-        m.insert("shells", "\u{e615}"); // ""
-        m.insert("sudoers", "\u{f023}"); // ""
-        m.insert("sxhkdrc", "\u{e615}"); // ""
-        m.insert("tigrc", "\u{e615}"); // ""
-        m.insert("vagrantfile", "\u{e615}"); // ""
-        m.insert("videos", "\u{f03d}"); // ""
-        m.insert("hostname", "\u{e615}");
-        m.insert("webpack.config.js", "\u{fc29}"); // "ﰩ"
-        m.insert("xmonad.hs", "\u{e615}"); // ""
-        m.insert("xorg.conf.d", "\u{e5fc}"); // ""
-        m.insert("xbps.d", "\u{e5fc}"); // ""
-
-        m
+        HashMap::from([
+            (".trash", "\u{f1f8}"),             // ""
+            (".atom", "\u{e764}"),              // ""
+            (".bash_profile", "\u{e615}"),      // ""
+            (".bash_logout", "\u{e615}"),       // ""
+            (".bashrc", "\u{f489}"),            // ""
+            (".cargo", "\u{e7a8}"),             // ""
+            (".clang-format", "\u{e615}"),      // ""
+            (".config", "\u{e5fc}"),            // ""
+            (".emacs.d", "\u{e779}"),           // ""
+            (".doom.d", "\u{e779}"),            // ""
+            (".git", "\u{e5fb}"),               // ""
+            (".git-credentials", "\u{e60a}"),   // ""
+            (".gitattributes", "\u{f1d3}"),     // ""
+            (".gitconfig", "\u{f1d3}"),         // ""
+            (".github", "\u{e5fd}"),            // ""
+            (".gitignore", "\u{f1d3}"),         // ""
+            (".gitlab-ci.yml", "\u{f296}"),     // ""
+            (".gitmodules", "\u{f1d3}"),        // ""
+            (".htaccess", "\u{e615}"),          // ""
+            (".htpasswd", "\u{e615}"),          // ""
+            (".inputrc", "\u{e615}"),           // ""
+            (".node_repl_history", "\u{e718}"), // ""
+            (".npm", "\u{e5fa}"),               // ""
+            (".profile", "\u{f68c}"),           // ""
+            (".python_history", "\u{e606}"),    // ""
+            (".release.toml", "\u{e7a8}"),      // ""
+            (".rvm", "\u{e21e}"),               // ""
+            (".ssh", "\u{f023}"),               // ""
+            (".vim", "\u{e62b}"),               // ""
+            (".vimrc", "\u{e62b}"),             // ""
+            (".viminfo", "\u{e62b}"),           // ""
+            (".vscode", "\u{e70c}"),            // ""
+            (".xauthority", "\u{e615}"),        // ""
+            (".xinitrc", "\u{e615}"),           // ""
+            (".xresources", "\u{e615}"),        // ""
+            (".zshrc", "\u{f489}"),             // ""
+            (".zsh_history", "\u{e615}"),       // ""
+            ("a.out", "\u{f489}"),              // ""
+            ("authorized_keys", "\u{e60a}"),    // ""
+            ("bin", "\u{e5fc}"),                // ""
+            ("bspwmrc", "\u{e615}"),            // ""
+            ("cargo.toml", "\u{e7a8}"),         // ""
+            ("cargo.lock", "\u{e7a8}"),         // ""
+            ("changelog", "\u{e609}"),          // ""
+            ("composer.json", "\u{e608}"),      // ""
+            ("config", "\u{e5fc}"),             // ""
+            ("config.ac", "\u{e615}"),          // ""
+            ("config.mk", "\u{e615}"),          // ""
+            ("config.el", "\u{e779}"),          // ""
+            ("custom.el", "\u{e779}"),          // ""
+            ("contributing", "\u{e60a}"),       // ""
+            ("cron.d", "\u{e5fc}"),             // ""
+            ("cron.daily", "\u{e5fc}"),         // ""
+            ("cron.hourly", "\u{e5fc}"),        // ""
+            ("cron.weekly", "\u{e5fc}"),        // ""
+            ("cron.monthly", "\u{e5fc}"),       // ""
+            ("crontab", "\u{e615}"),            // ""
+            ("crypttab", "\u{e615}"),           // ""
+            ("desktop", "\u{f108}"),            // ""
+            ("downloads", "\u{f498}"),          // ""
+            ("docker-compose.yml", "\u{f308}"), // ""
+            ("dockerfile", "\u{f308}"),         // ""
+            ("documents", "\u{f02d}"),          // ""
+            (".ds_store", "\u{f179}"),          // ""
+            ("etc", "\u{e5fc}"),                // ""
+            ("favicon.ico", "\u{f005}"),        // ""
+            ("fstab", "\u{f1c0}"),              // ""
+            ("gitignore_global", "\u{f1d3}"),   // ""
+            ("gradle", "\u{e70e}"),             // ""
+            ("group", "\u{e615}"),              // ""
+            ("gruntfile.coffee", "\u{e611}"),   // ""
+            ("gruntfile.js", "\u{e611}"),       // ""
+            ("gruntfile.ls", "\u{e611}"),       // ""
+            ("gshadow", "\u{e615}"),            // ""
+            ("gulpfile.coffee", "\u{e610}"),    // ""
+            ("gulpfile.js", "\u{e610}"),        // ""
+            ("gulpfile.ls", "\u{e610}"),        // ""
+            ("hidden", "\u{f023}"),             // ""
+            ("hosts", "\u{f502}"),              // ""
+            ("htoprc", "\u{e615}"),             // ""
+            ("include", "\u{e5fc}"),            // ""
+            ("init.el", "\u{e779}"),            // ""
+            ("known_hosts", "\u{e60a}"),        // ""
+            ("lib", "\u{f121}"),                // ""
+            ("license", "\u{e60a}"),            // ""
+            ("license.md", "\u{e60a}"),         // ""
+            ("license.txt", "\u{e60a}"),        // ""
+            ("localized", "\u{f179}"),          // ""
+            ("mail", "\u{f6ef}"),               // ""
+            ("makefile", "\u{e615}"),           // ""
+            ("makefile.ac", "\u{e615}"),        // ""
+            ("music", "\u{f025}"),              // ""
+            ("muttrc", "\u{e615}"),             // ""
+            ("node_modules", "\u{e5fa}"),       // ""
+            ("npmignore", "\u{e71e}"),          // ""
+            ("package.json", "\u{e718}"),       // ""
+            ("packages.el", "\u{e779}"),        // ""
+            ("package-lock.json", "\u{e718}"),  // ""
+            ("passwd", "\u{f023}"),             // ""
+            ("pictures", "\u{f03e}"),           // ""
+            ("profile", "\u{e615}"),            // ""
+            ("readme", "\u{e609}"),             // ""
+            ("rc.lua", "\u{e615}"),             // ""
+            ("rubydoc", "\u{e73b}"),            // ""
+            ("robots.txt", "\u{fba7}"),         // "ﮧ"
+            ("root", "\u{f023}"),               // ""
+            ("shadow", "\u{e615}"),             // ""
+            ("shells", "\u{e615}"),             // ""
+            ("sudoers", "\u{f023}"),            // ""
+            ("sxhkdrc", "\u{e615}"),            // ""
+            ("tigrc", "\u{e615}"),              // ""
+            ("vagrantfile", "\u{e615}"),        // ""
+            ("videos", "\u{f03d}"),             // ""
+            ("hostname", "\u{e615}"),           // ""
+            ("webpack.config.js", "\u{fc29}"),  // "ﰩ"
+            ("xmonad.hs", "\u{e615}"),          // ""
+            ("xorg.conf.d", "\u{e5fc}"),        // ""
+            ("xbps.d", "\u{e5fc}"),             // ""
+        ])
     }
 
     fn get_default_icons_by_extension() -> HashMap<&'static str, &'static str> {
-        let mut m = HashMap::new();
-
         // Note: extensions must be lower-case
-
-        m.insert("1", "\u{f02d}"); // ""
-        m.insert("7z", "\u{f410}"); // ""
-        m.insert("a", "\u{e624}"); // ""
-        m.insert("ai", "\u{e7b4}"); // ""
-        m.insert("ape", "\u{f001}"); // ""
-        m.insert("apk", "\u{e70e}"); // ""
-        m.insert("asc", "\u{f023}"); // ""
-        m.insert("asm", "\u{e614}"); // ""
-        m.insert("asp", "\u{f121}"); // ""
-        m.insert("avi", "\u{f008}"); // ""
-        m.insert("avro", "\u{e60b}"); // ""
-        m.insert("awk", "\u{f489}"); // ""
-        m.insert("bash", "\u{f489}"); // ""
-        m.insert("bash_history", "\u{f489}"); // ""
-        m.insert("bash_profile", "\u{f489}"); // ""
-        m.insert("bashrc", "\u{f489}"); // ""
-        m.insert("bat", "\u{f17a}"); // ""
-        m.insert("bin", "\u{f489}"); // ""
-        m.insert("bio", "\u{f910}"); // "蘿"
-        m.insert("bmp", "\u{f1c5}"); // ""
-        m.insert("bz2", "\u{f410}"); // ""
-        m.insert("c", "\u{e61e}"); // ""
-        m.insert("c++", "\u{e61d}"); // ""
-        m.insert("cc", "\u{e61d}"); // ""
-        m.insert("cfg", "\u{e615}"); // ""
-        m.insert("cl", "\u{f671}"); // ""
-        m.insert("class", "\u{e738}"); // ""
-        m.insert("clj", "\u{e768}"); // ""
-        m.insert("cljs", "\u{e76a}"); // ""
-        m.insert("cls", "\u{e600}"); // ""
-        m.insert("coffee", "\u{f0f4}"); // ""
-        m.insert("conf", "\u{e615}"); // ""
-        m.insert("cp", "\u{e61d}"); // ""
-        m.insert("cpp", "\u{e61d}"); // ""
-        m.insert("cs", "\u{f81a}"); // ""
-        m.insert("cshtml", "\u{f1fa}"); // ""
-        m.insert("csproj", "\u{f81a}"); // ""
-        m.insert("csx", "\u{f81a}"); // ""
-        m.insert("csh", "\u{f489}"); // ""
-        m.insert("css", "\u{e749}"); // ""
-        m.insert("csv", "\u{f1c3}"); // ""
-        m.insert("cue", "\u{f001}"); // ""
-        m.insert("cxx", "\u{e61d}"); // ""
-        m.insert("dart", "\u{e798}"); // ""
-        m.insert("db", "\u{f1c0}"); // ""
-        m.insert("deb", "\u{f187}"); // ""
-        m.insert("desktop", "\u{f108}"); // ""
-        m.insert("diff", "\u{e728}"); // ""
-        m.insert("dll", "\u{f17a}"); // ""
-        m.insert("doc", "\u{f1c2}"); // ""
-        m.insert("dockerfile", "\u{f308}"); // ""
-        m.insert("docx", "\u{f1c2}"); // ""
-        m.insert("ds_store", "\u{f179}"); // ""
-        m.insert("dump", "\u{f1c0}"); // ""
-        m.insert("ebook", "\u{e28b}"); // ""
-        m.insert("editorconfig", "\u{e615}"); // ""
-        m.insert("ejs", "\u{e618}"); // ""
-        m.insert("el", "\u{f671}"); // ""
-        m.insert("elc", "\u{f671}"); // ""
-        m.insert("elf", "\u{f489}"); // ""
-        m.insert("elm", "\u{e62c}"); // ""
-        m.insert("env", "\u{f462}"); // ""
-        m.insert("eot", "\u{f031}"); // ""
-        m.insert("epub", "\u{e28a}"); // ""
-        m.insert("erb", "\u{e73b}"); // ""
-        m.insert("erl", "\u{e7b1}"); // ""
-        m.insert("exe", "\u{f17a}"); // ""
-        m.insert("ex", "\u{e62d}"); // ""
-        m.insert("exs", "\u{e62d}"); // ""
-        m.insert("fish", "\u{f489}"); // ""
-        m.insert("flac", "\u{f001}"); // ""
-        m.insert("flv", "\u{f008}"); // ""
-        m.insert("font", "\u{f031}"); // ""
-        m.insert("fpl", "\u{f910}"); // "蘿"
-        m.insert("fs", "\u{e7a7}"); // ""
-        m.insert("fsx", "\u{e7a7}"); // ""
-        m.insert("fsi", "\u{e7a7}"); // ""
-        m.insert("gdoc", "\u{f1c2}"); // ""
-        m.insert("gemfile", "\u{e21e}"); // ""
-        m.insert("gemspec", "\u{e21e}"); // ""
-        m.insert("gform", "\u{f298}"); // ""
-        m.insert("gif", "\u{f1c5}"); // ""
-        m.insert("git", "\u{f1d3}"); // ""
-        m.insert("go", "\u{e627}"); // ""
-        m.insert("gradle", "\u{e70e}"); // ""
-        m.insert("gsheet", "\u{f1c3}"); // ""
-        m.insert("gslides", "\u{f1c4}"); // ""
-        m.insert("guardfile", "\u{e21e}"); // ""
-        m.insert("gz", "\u{f410}"); // ""
-        m.insert("h", "\u{f0fd}"); // ""
-        m.insert("hbs", "\u{e60f}"); // ""
-        m.insert("heic", "\u{f1c5}"); // ""
-        m.insert("heif", "\u{f1c5}"); // ""
-        m.insert("heix", "\u{f1c5}"); // ""
-        m.insert("hpp", "\u{f0fd}"); // ""
-        m.insert("hs", "\u{e777}"); // ""
-        m.insert("htm", "\u{f13b}"); // ""
-        m.insert("html", "\u{f13b}"); // ""
-        m.insert("hxx", "\u{f0fd}"); // ""
-        m.insert("ico", "\u{f1c5}"); // ""
-        m.insert("image", "\u{f1c5}"); // ""
-        m.insert("img", "\u{f1c0}"); // ""
-        m.insert("iml", "\u{e7b5}"); // ""
-        m.insert("ini", "\u{e615}"); // ""
-        m.insert("ipynb", "\u{e606}"); // ""
-        m.insert("iso", "\u{f1c0}"); // ""
-        m.insert("jar", "\u{e738}"); // ""
-        m.insert("java", "\u{e738}"); // ""
-        m.insert("jpeg", "\u{f1c5}"); // ""
-        m.insert("jpg", "\u{f1c5}"); // ""
-        m.insert("js", "\u{e74e}"); // ""
-        m.insert("json", "\u{e60b}"); // ""
-        m.insert("jsx", "\u{e7ba}"); // ""
-        m.insert("jl", "\u{e624}"); // ""
-        m.insert("key", "\u{e60a}"); // ""
-        m.insert("ksh", "\u{f489}"); // ""
-        m.insert("ld", "\u{e624}"); // ""
-        m.insert("ldb", "\u{f1c0}"); // ""
-        m.insert("less", "\u{e758}"); // ""
-        m.insert("lhs", "\u{e777}"); // ""
-        m.insert("license", "\u{e60a}"); // ""
-        m.insert("lisp", "\u{f671}"); // ""
-        m.insert("localized", "\u{f179}"); // ""
-        m.insert("lock", "\u{f023}"); // ""
-        m.insert("log", "\u{f18d}"); // ""
-        m.insert("lua", "\u{e620}"); // ""
-        m.insert("lz", "\u{f410}"); // ""
-        m.insert("m3u", "\u{f910}"); // "蘿"
-        m.insert("m3u8", "\u{f910}"); // "蘿"
-        m.insert("m4a", "\u{f001}"); // ""
-        m.insert("m4v", "\u{f008}"); // ""
-        m.insert("magnet", "\u{f076}"); // ""
-        m.insert("markdown", "\u{e609}"); // ""
-        m.insert("md", "\u{e609}"); // ""
-        m.insert("mjs", "\u{e74e}"); // ""
-        m.insert("mkd", "\u{e609}"); // ""
-        m.insert("mkv", "\u{f008}"); // ""
-        m.insert("mobi", "\u{e28b}"); // ""
-        m.insert("mov", "\u{f008}"); // ""
-        m.insert("mp3", "\u{f001}"); // ""
-        m.insert("mp4", "\u{f008}"); // ""
-        m.insert("msi", "\u{f17a}"); // ""
-        m.insert("mustache", "\u{e60f}"); // ""
-        m.insert("nix", "\u{f313}"); // ""
-        m.insert("npmignore", "\u{e71e}"); // ""
-        m.insert("o", "\u{e624}"); // ""
-        m.insert("opus", "\u{f001}"); // ""
-        m.insert("ogg", "\u{f001}"); // ""
-        m.insert("ogv", "\u{f008}"); // ""
-        m.insert("otf", "\u{f031}"); // ""
-        m.insert("pdf", "\u{f1c1}"); // ""
-        m.insert("pem", "\u{f805}"); // ""
-        m.insert("phar", "\u{e608}"); // ""
-        m.insert("php", "\u{e608}"); // ""
-        m.insert("pkg", "\u{f187}"); // ""
-        m.insert("pl", "\u{e769}"); // ""
-        m.insert("plist", "\u{f302}"); // ""
-        m.insert("pls", "\u{f910}"); // "蘿"
-        m.insert("pm", "\u{e769}"); // ""
-        m.insert("png", "\u{f1c5}"); // ""
-        m.insert("ppt", "\u{f1c4}"); // ""
-        m.insert("pptx", "\u{f1c4}"); // ""
-        m.insert("procfile", "\u{e21e}"); // ""
-        m.insert("properties", "\u{e60b}"); // ""
-        m.insert("ps1", "\u{f489}"); // ""
-        m.insert("psd", "\u{e7b8}"); // ""
-        m.insert("pub", "\u{e60a}"); // ""
-        m.insert("pxm", "\u{f1c5}"); // ""
-        m.insert("py", "\u{e606}"); // ""
-        m.insert("pyc", "\u{e606}"); // ""
-        m.insert("r", "\u{fcd2}"); // "ﳒ"
-        m.insert("rakefile", "\u{e21e}"); // ""
-        m.insert("rar", "\u{f410}"); // ""
-        m.insert("razor", "\u{f1fa}"); // ""
-        m.insert("rb", "\u{e21e}"); // ""
-        m.insert("rdata", "\u{fcd2}"); // "ﳒ"
-        m.insert("rdb", "\u{e76d}"); // ""
-        m.insert("rdoc", "\u{e609}"); // ""
-        m.insert("rds", "\u{fcd2}"); // "ﳒ"
-        m.insert("readme", "\u{e609}"); // ""
-        m.insert("rlib", "\u{e7a8}"); // ""
-        m.insert("rmd", "\u{e609}"); // ""
-        m.insert("rpm", "\u{f187}"); // ""
-        m.insert("rproj", "\u{fac5}"); // "鉶"
-        m.insert("rs", "\u{e7a8}"); // ""
-        m.insert("rspec", "\u{e21e}"); // ""
-        m.insert("rspec_parallel", "\u{e21e}"); // ""
-        m.insert("rspec_status", "\u{e21e}"); // ""
-        m.insert("rss", "\u{f09e}"); // ""
-        m.insert("rtf", "\u{f15c}"); // ""
-        m.insert("ru", "\u{e21e}"); // ""
-        m.insert("rubydoc", "\u{e73b}"); // ""
-        m.insert("s", "\u{e614}"); // ""
-        m.insert("sass", "\u{e603}"); // ""
-        m.insert("scala", "\u{e737}"); // ""
-        m.insert("scpt", "\u{f302}"); // ""
-        m.insert("scss", "\u{e603}"); // ""
-        m.insert("sh", "\u{f489}"); // ""
-        m.insert("shell", "\u{f489}"); // ""
-        m.insert("sig", "\u{e60a}"); // ""
-        m.insert("slim", "\u{e73b}"); // ""
-        m.insert("sln", "\u{e70c}"); // ""
-        m.insert("so", "\u{e624}"); // ""
-        m.insert("sql", "\u{f1c0}"); // ""
-        m.insert("sqlite3", "\u{e7c4}"); // ""
-        m.insert("srt", "\u{f02d}"); // ""
-        m.insert("styl", "\u{e600}"); // ""
-        m.insert("stylus", "\u{e600}"); // ""
-        m.insert("sub", "\u{f02d}"); // ""
-        m.insert("sublime-package", "\u{e7aa}"); // ""
-        m.insert("sublime-session", "\u{e7aa}"); // ""
-        m.insert("svg", "\u{f1c5}"); // ""
-        m.insert("swift", "\u{e755}"); // ""
-        m.insert("swp", "\u{e62b}"); // ""
-        m.insert("sym", "\u{e624}"); // ""
-        m.insert("t", "\u{e769}"); // ""
-        m.insert("tar", "\u{f410}"); // ""
-        m.insert("tex", "\u{e600}"); // ""
-        m.insert("tgz", "\u{f410}"); // ""
-        m.insert("tiff", "\u{f1c5}"); // ""
-        m.insert("toml", "\u{e60b}"); // ""
-        m.insert("torrent", "\u{f98c}"); // "歷"
-        m.insert("ts", "\u{e628}"); // ""
-        m.insert("tsx", "\u{e7ba}"); // ""
-        m.insert("ttc", "\u{f031}"); // ""
-        m.insert("ttf", "\u{f031}"); // ""
-        m.insert("twig", "\u{e61c}"); // ""
-        m.insert("txt", "\u{f15c}"); // ""
-        m.insert("video", "\u{f008}"); // ""
-        m.insert("vim", "\u{e62b}"); // ""
-        m.insert("vlc", "\u{f910}"); // "蘿"
-        m.insert("vue", "\u{fd42}"); // "﵂"
-        m.insert("wav", "\u{f001}"); // ""
-        m.insert("webm", "\u{f008}"); // ""
-        m.insert("webp", "\u{f1c5}"); // ""
-        m.insert("windows", "\u{f17a}"); // ""
-        m.insert("wma", "\u{f001}"); // ""
-        m.insert("wmv", "\u{f008}"); // ""
-        m.insert("wpl", "\u{f910}"); // "蘿"
-        m.insert("woff", "\u{f031}"); // ""
-        m.insert("woff2", "\u{f031}"); // ""
-        m.insert("xbps", "\u{f187}"); // ""
-        m.insert("xcf", "\u{f1c5}"); // ""
-        m.insert("xls", "\u{f1c3}"); // ""
-        m.insert("xlsx", "\u{f1c3}"); // ""
-        m.insert("xml", "\u{f121}"); // ""
-        m.insert("xul", "\u{f269}"); // ""
-        m.insert("xz", "\u{f410}"); // ""
-        m.insert("yaml", "\u{e60b}"); // ""
-        m.insert("yml", "\u{e60b}"); // ""
-        m.insert("zip", "\u{f410}"); // ""
-        m.insert("zsh", "\u{f489}"); // ""
-        m.insert("zsh-theme", "\u{f489}"); // ""
-        m.insert("zshrc", "\u{f489}"); // ""
-
-        m
+        HashMap::from([
+            ("1", "\u{f02d}"),               // ""
+            ("7z", "\u{f410}"),              // ""
+            ("a", "\u{e624}"),               // ""
+            ("ai", "\u{e7b4}"),              // ""
+            ("ape", "\u{f001}"),             // ""
+            ("apk", "\u{e70e}"),             // ""
+            ("asc", "\u{f023}"),             // ""
+            ("asm", "\u{e614}"),             // ""
+            ("asp", "\u{f121}"),             // ""
+            ("avi", "\u{f008}"),             // ""
+            ("avro", "\u{e60b}"),            // ""
+            ("awk", "\u{f489}"),             // ""
+            ("bash", "\u{f489}"),            // ""
+            ("bash_history", "\u{f489}"),    // ""
+            ("bash_profile", "\u{f489}"),    // ""
+            ("bashrc", "\u{f489}"),          // ""
+            ("bat", "\u{f17a}"),             // ""
+            ("bin", "\u{f489}"),             // ""
+            ("bio", "\u{f910}"),             // "蘿"
+            ("bmp", "\u{f1c5}"),             // ""
+            ("bz2", "\u{f410}"),             // ""
+            ("c", "\u{e61e}"),               // ""
+            ("c++", "\u{e61d}"),             // ""
+            ("cc", "\u{e61d}"),              // ""
+            ("cfg", "\u{e615}"),             // ""
+            ("cl", "\u{f671}"),              // ""
+            ("class", "\u{e738}"),           // ""
+            ("clj", "\u{e768}"),             // ""
+            ("cljs", "\u{e76a}"),            // ""
+            ("cls", "\u{e600}"),             // ""
+            ("coffee", "\u{f0f4}"),          // ""
+            ("conf", "\u{e615}"),            // ""
+            ("cp", "\u{e61d}"),              // ""
+            ("cpp", "\u{e61d}"),             // ""
+            ("cs", "\u{f81a}"),              // ""
+            ("cshtml", "\u{f1fa}"),          // ""
+            ("csproj", "\u{f81a}"),          // ""
+            ("csx", "\u{f81a}"),             // ""
+            ("csh", "\u{f489}"),             // ""
+            ("css", "\u{e749}"),             // ""
+            ("csv", "\u{f1c3}"),             // ""
+            ("cue", "\u{f001}"),             // ""
+            ("cxx", "\u{e61d}"),             // ""
+            ("dart", "\u{e798}"),            // ""
+            ("db", "\u{f1c0}"),              // ""
+            ("deb", "\u{f187}"),             // ""
+            ("desktop", "\u{f108}"),         // ""
+            ("diff", "\u{e728}"),            // ""
+            ("dll", "\u{f17a}"),             // ""
+            ("doc", "\u{f1c2}"),             // ""
+            ("dockerfile", "\u{f308}"),      // ""
+            ("docx", "\u{f1c2}"),            // ""
+            ("ds_store", "\u{f179}"),        // ""
+            ("dump", "\u{f1c0}"),            // ""
+            ("ebook", "\u{e28b}"),           // ""
+            ("editorconfig", "\u{e615}"),    // ""
+            ("ejs", "\u{e618}"),             // ""
+            ("el", "\u{f671}"),              // ""
+            ("elc", "\u{f671}"),             // ""
+            ("elf", "\u{f489}"),             // ""
+            ("elm", "\u{e62c}"),             // ""
+            ("env", "\u{f462}"),             // ""
+            ("eot", "\u{f031}"),             // ""
+            ("epub", "\u{e28a}"),            // ""
+            ("erb", "\u{e73b}"),             // ""
+            ("erl", "\u{e7b1}"),             // ""
+            ("exe", "\u{f17a}"),             // ""
+            ("ex", "\u{e62d}"),              // ""
+            ("exs", "\u{e62d}"),             // ""
+            ("fish", "\u{f489}"),            // ""
+            ("flac", "\u{f001}"),            // ""
+            ("flv", "\u{f008}"),             // ""
+            ("font", "\u{f031}"),            // ""
+            ("fpl", "\u{f910}"),             // "蘿"
+            ("fs", "\u{e7a7}"),              // ""
+            ("fsx", "\u{e7a7}"),             // ""
+            ("fsi", "\u{e7a7}"),             // ""
+            ("gdoc", "\u{f1c2}"),            // ""
+            ("gemfile", "\u{e21e}"),         // ""
+            ("gemspec", "\u{e21e}"),         // ""
+            ("gform", "\u{f298}"),           // ""
+            ("gif", "\u{f1c5}"),             // ""
+            ("git", "\u{f1d3}"),             // ""
+            ("go", "\u{e627}"),              // ""
+            ("gradle", "\u{e70e}"),          // ""
+            ("gsheet", "\u{f1c3}"),          // ""
+            ("gslides", "\u{f1c4}"),         // ""
+            ("guardfile", "\u{e21e}"),       // ""
+            ("gz", "\u{f410}"),              // ""
+            ("h", "\u{f0fd}"),               // ""
+            ("hbs", "\u{e60f}"),             // ""
+            ("heic", "\u{f1c5}"),            // ""
+            ("heif", "\u{f1c5}"),            // ""
+            ("heix", "\u{f1c5}"),            // ""
+            ("hpp", "\u{f0fd}"),             // ""
+            ("hs", "\u{e777}"),              // ""
+            ("htm", "\u{f13b}"),             // ""
+            ("html", "\u{f13b}"),            // ""
+            ("hxx", "\u{f0fd}"),             // ""
+            ("ico", "\u{f1c5}"),             // ""
+            ("image", "\u{f1c5}"),           // ""
+            ("img", "\u{f1c0}"),             // ""
+            ("iml", "\u{e7b5}"),             // ""
+            ("ini", "\u{e615}"),             // ""
+            ("ipynb", "\u{e606}"),           // ""
+            ("iso", "\u{f1c0}"),             // ""
+            ("jar", "\u{e738}"),             // ""
+            ("java", "\u{e738}"),            // ""
+            ("jpeg", "\u{f1c5}"),            // ""
+            ("jpg", "\u{f1c5}"),             // ""
+            ("js", "\u{e74e}"),              // ""
+            ("json", "\u{e60b}"),            // ""
+            ("jsx", "\u{e7ba}"),             // ""
+            ("jl", "\u{e624}"),              // ""
+            ("key", "\u{e60a}"),             // ""
+            ("ksh", "\u{f489}"),             // ""
+            ("ld", "\u{e624}"),              // ""
+            ("ldb", "\u{f1c0}"),             // ""
+            ("less", "\u{e758}"),            // ""
+            ("lhs", "\u{e777}"),             // ""
+            ("license", "\u{e60a}"),         // ""
+            ("lisp", "\u{f671}"),            // ""
+            ("localized", "\u{f179}"),       // ""
+            ("lock", "\u{f023}"),            // ""
+            ("log", "\u{f18d}"),             // ""
+            ("lua", "\u{e620}"),             // ""
+            ("lz", "\u{f410}"),              // ""
+            ("m3u", "\u{f910}"),             // "蘿"
+            ("m3u8", "\u{f910}"),            // "蘿"
+            ("m4a", "\u{f001}"),             // ""
+            ("m4v", "\u{f008}"),             // ""
+            ("magnet", "\u{f076}"),          // ""
+            ("markdown", "\u{e609}"),        // ""
+            ("md", "\u{e609}"),              // ""
+            ("mjs", "\u{e74e}"),             // ""
+            ("mkd", "\u{e609}"),             // ""
+            ("mkv", "\u{f008}"),             // ""
+            ("mobi", "\u{e28b}"),            // ""
+            ("mov", "\u{f008}"),             // ""
+            ("mp3", "\u{f001}"),             // ""
+            ("mp4", "\u{f008}"),             // ""
+            ("msi", "\u{f17a}"),             // ""
+            ("mustache", "\u{e60f}"),        // ""
+            ("nix", "\u{f313}"),             // ""
+            ("npmignore", "\u{e71e}"),       // ""
+            ("o", "\u{e624}"),               // ""
+            ("opus", "\u{f001}"),            // ""
+            ("ogg", "\u{f001}"),             // ""
+            ("ogv", "\u{f008}"),             // ""
+            ("otf", "\u{f031}"),             // ""
+            ("pdf", "\u{f1c1}"),             // ""
+            ("pem", "\u{f805}"),             // ""
+            ("phar", "\u{e608}"),            // ""
+            ("php", "\u{e608}"),             // ""
+            ("pkg", "\u{f187}"),             // ""
+            ("pl", "\u{e769}"),              // ""
+            ("plist", "\u{f302}"),           // ""
+            ("pls", "\u{f910}"),             // "蘿"
+            ("pm", "\u{e769}"),              // ""
+            ("png", "\u{f1c5}"),             // ""
+            ("ppt", "\u{f1c4}"),             // ""
+            ("pptx", "\u{f1c4}"),            // ""
+            ("procfile", "\u{e21e}"),        // ""
+            ("properties", "\u{e60b}"),      // ""
+            ("ps1", "\u{f489}"),             // ""
+            ("psd", "\u{e7b8}"),             // ""
+            ("pub", "\u{e60a}"),             // ""
+            ("pxm", "\u{f1c5}"),             // ""
+            ("py", "\u{e606}"),              // ""
+            ("pyc", "\u{e606}"),             // ""
+            ("r", "\u{fcd2}"),               // "ﳒ"
+            ("rakefile", "\u{e21e}"),        // ""
+            ("rar", "\u{f410}"),             // ""
+            ("razor", "\u{f1fa}"),           // ""
+            ("rb", "\u{e21e}"),              // ""
+            ("rdata", "\u{fcd2}"),           // "ﳒ"
+            ("rdb", "\u{e76d}"),             // ""
+            ("rdoc", "\u{e609}"),            // ""
+            ("rds", "\u{fcd2}"),             // "ﳒ"
+            ("readme", "\u{e609}"),          // ""
+            ("rlib", "\u{e7a8}"),            // ""
+            ("rmd", "\u{e609}"),             // ""
+            ("rpm", "\u{f187}"),             // ""
+            ("rproj", "\u{fac5}"),           // "鉶"
+            ("rs", "\u{e7a8}"),              // ""
+            ("rspec", "\u{e21e}"),           // ""
+            ("rspec_parallel", "\u{e21e}"),  // ""
+            ("rspec_status", "\u{e21e}"),    // ""
+            ("rss", "\u{f09e}"),             // ""
+            ("rtf", "\u{f15c}"),             // ""
+            ("ru", "\u{e21e}"),              // ""
+            ("rubydoc", "\u{e73b}"),         // ""
+            ("s", "\u{e614}"),               // ""
+            ("sass", "\u{e603}"),            // ""
+            ("scala", "\u{e737}"),           // ""
+            ("scpt", "\u{f302}"),            // ""
+            ("scss", "\u{e603}"),            // ""
+            ("sh", "\u{f489}"),              // ""
+            ("shell", "\u{f489}"),           // ""
+            ("sig", "\u{e60a}"),             // ""
+            ("slim", "\u{e73b}"),            // ""
+            ("sln", "\u{e70c}"),             // ""
+            ("so", "\u{e624}"),              // ""
+            ("sql", "\u{f1c0}"),             // ""
+            ("sqlite3", "\u{e7c4}"),         // ""
+            ("srt", "\u{f02d}"),             // ""
+            ("styl", "\u{e600}"),            // ""
+            ("stylus", "\u{e600}"),          // ""
+            ("sub", "\u{f02d}"),             // ""
+            ("sublime-package", "\u{e7aa}"), // ""
+            ("sublime-session", "\u{e7aa}"), // ""
+            ("svg", "\u{f1c5}"),             // ""
+            ("swift", "\u{e755}"),           // ""
+            ("swp", "\u{e62b}"),             // ""
+            ("sym", "\u{e624}"),             // ""
+            ("t", "\u{e769}"),               // ""
+            ("tar", "\u{f410}"),             // ""
+            ("tex", "\u{e600}"),             // ""
+            ("tgz", "\u{f410}"),             // ""
+            ("tiff", "\u{f1c5}"),            // ""
+            ("toml", "\u{e60b}"),            // ""
+            ("torrent", "\u{f98c}"),         // "歷"
+            ("ts", "\u{e628}"),              // ""
+            ("tsx", "\u{e7ba}"),             // ""
+            ("ttc", "\u{f031}"),             // ""
+            ("ttf", "\u{f031}"),             // ""
+            ("twig", "\u{e61c}"),            // ""
+            ("txt", "\u{f15c}"),             // ""
+            ("video", "\u{f008}"),           // ""
+            ("vim", "\u{e62b}"),             // ""
+            ("vlc", "\u{f910}"),             // "蘿"
+            ("vue", "\u{fd42}"),             // "﵂"
+            ("wav", "\u{f001}"),             // ""
+            ("webm", "\u{f008}"),            // ""
+            ("webp", "\u{f1c5}"),            // ""
+            ("windows", "\u{f17a}"),         // ""
+            ("wma", "\u{f001}"),             // ""
+            ("wmv", "\u{f008}"),             // ""
+            ("wpl", "\u{f910}"),             // "蘿"
+            ("woff", "\u{f031}"),            // ""
+            ("woff2", "\u{f031}"),           // ""
+            ("xbps", "\u{f187}"),            // ""
+            ("xcf", "\u{f1c5}"),             // ""
+            ("xls", "\u{f1c3}"),             // ""
+            ("xlsx", "\u{f1c3}"),            // ""
+            ("xml", "\u{f121}"),             // ""
+            ("xul", "\u{f269}"),             // ""
+            ("xz", "\u{f410}"),              // ""
+            ("yaml", "\u{e60b}"),            // ""
+            ("yml", "\u{e60b}"),             // ""
+            ("zip", "\u{f410}"),             // ""
+            ("zsh", "\u{f489}"),             // ""
+            ("zsh-theme", "\u{f489}"),       // ""
+            ("zshrc", "\u{f489}"),           // ""
+            ("zst", "\u{f410}"),             // ""
+        ])
     }
 }
 
@@ -522,7 +512,7 @@ mod test {
         let icon = Icons::new(Theme::Fancy, " ".to_string());
         let icon_str = icon.get(&meta.name);
 
-        assert_eq!(icon_str, format!("{}{}", "\u{f016}", icon.icon_separator)); // 
+        assert_eq!(icon_str, "\u{f016} "); // 
     }
 
     #[test]
@@ -535,43 +525,43 @@ mod test {
         let icon = Icons::new(Theme::Unicode, " ".to_string());
         let icon_str = icon.get(&meta.name);
 
-        assert_eq!(icon_str, format!("{}{}", "\u{1f5cb}", icon.icon_separator));
+        assert_eq!(icon_str, "\u{1f5cb} ");
     }
 
     #[test]
     fn get_directory_icon() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
         let file_path = tmp_dir.path();
-        let meta = Meta::from_path(&file_path.to_path_buf(), false).unwrap();
+        let meta = Meta::from_path(file_path, false).unwrap();
 
         let icon = Icons::new(Theme::Fancy, " ".to_string());
         let icon_str = icon.get(&meta.name);
 
-        assert_eq!(icon_str, format!("{}{}", "\u{f115}", icon.icon_separator)); // 
+        assert_eq!(icon_str, "\u{f115} "); // 
     }
 
     #[test]
     fn get_directory_icon_unicode() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
         let file_path = tmp_dir.path();
-        let meta = Meta::from_path(&file_path.to_path_buf(), false).unwrap();
+        let meta = Meta::from_path(file_path, false).unwrap();
 
         let icon = Icons::new(Theme::Unicode, " ".to_string());
         let icon_str = icon.get(&meta.name);
 
-        assert_eq!(icon_str, format!("{}{}", "\u{1f5c1}", icon.icon_separator));
+        assert_eq!(icon_str, "\u{1f5c1} ");
     }
 
     #[test]
     fn get_directory_icon_with_ext() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
         let file_path = tmp_dir.path();
-        let meta = Meta::from_path(&file_path.to_path_buf(), false).unwrap();
+        let meta = Meta::from_path(file_path, false).unwrap();
 
         let icon = Icons::new(Theme::Fancy, " ".to_string());
         let icon_str = icon.get(&meta.name);
 
-        assert_eq!(icon_str, format!("{}{}", "\u{f115}", icon.icon_separator)); // 
+        assert_eq!(icon_str, "\u{f115} "); // 
     }
 
     #[test]
diff --git a/src/main.rs b/src/main.rs
index ceb4216..e17567a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,10 +5,9 @@
     clippy::cast_possible_wrap
 )]
 
-#[macro_use]
-extern crate clap;
 extern crate chrono;
 extern crate chrono_humanize;
+extern crate clap;
 extern crate dirs;
 extern crate libc;
 extern crate lscolors;
@@ -107,8 +106,7 @@ fn main() {
     } else if matches.is_present("config-file") {
         let path = matches
             .value_of("config-file")
-            .expect("Invalid config file path")
-            .into();
+            .expect("Invalid config file path");
 
         Config::from_file(path).expect("Provided file path is invalid")
     } else {
diff --git a/src/meta/access_control.rs b/src/meta/access_control.rs
index 4695df1..493025a 100644
--- a/src/meta/access_control.rs
+++ b/src/meta/access_control.rs
@@ -42,11 +42,11 @@ impl AccessControl {
 
     pub fn render_method(&self, colors: &Colors) -> ColoredString {
         if self.has_acl {
-            colors.colorize(String::from("+"), &Elem::Acl)
+            colors.colorize('+', &Elem::Acl)
         } else if !self.selinux_context.is_empty() || !self.smack_context.is_empty() {
-            colors.colorize(String::from("."), &Elem::Context)
+            colors.colorize('.', &Elem::Context)
         } else {
-            colors.colorize(String::from(""), &Elem::Acl)
+            colors.colorize("", &Elem::Acl)
         }
     }
 
diff --git a/src/meta/date.rs b/src/meta/date.rs
index 4820b30..b6f447c 100644
--- a/src/meta/date.rs
+++ b/src/meta/date.rs
@@ -13,21 +13,17 @@ pub enum Date {
 }
 
 // Note that this is split from the From for Metadata so we can test this one (as we can't mock Metadata)
-impl<'a> From<SystemTime> for Date {
+impl From<SystemTime> for Date {
     fn from(systime: SystemTime) -> Self {
         // FIXME: This should really involve a result, but there's upstream issues in chrono. See https://github.com/chronotope/chrono/issues/110
         let res = panic::catch_unwind(|| systime.into());
 
-        if let Ok(time) = res {
-            Date::Date(time)
-        } else {
-            Date::Invalid
-        }
+        res.map_or(Date::Invalid, Date::Date)
     }
 }
 
-impl<'a> From<&'a Metadata> for Date {
-    fn from(meta: &'a Metadata) -> Self {
+impl From<&Metadata> for Date {
+    fn from(meta: &Metadata) -> Self {
         meta.modified()
             .expect("failed to retrieve modified date")
             .into()
@@ -37,25 +33,19 @@ impl<'a> From<&'a Metadata> for Date {
 impl Date {
     pub fn render(&self, colors: &Colors, flags: &Flags) -> ColoredString {
         let now = Local::now();
-        let elem = if let Date::Date(val) = self {
-            if *val > now - Duration::hours(1) {
-                Elem::HourOld
-            } else if *val > now - Duration::days(1) {
-                Elem::DayOld
-            } else {
-                Elem::Older
-            }
-        } else {
-            Elem::Older
+        let elem = match self {
+            &Date::Date(modified) if modified > now - Duration::hours(1) => Elem::HourOld,
+            &Date::Date(modified) if modified > now - Duration::days(1) => Elem::DayOld,
+            &Date::Date(_) | Date::Invalid => Elem::Older,
         };
         colors.colorize(self.date_string(flags), &elem)
     }
 
-    pub fn date_string(&self, flags: &Flags) -> String {
+    fn date_string(&self, flags: &Flags) -> String {
         if let Date::Date(val) = self {
             match &flags.date {
                 DateFlag::Date => val.format("%c").to_string(),
-                DateFlag::Relative => format!("{}", HumanTime::from(*val - Local::now())),
+                DateFlag::Relative => HumanTime::from(*val - Local::now()).to_string(),
                 DateFlag::Iso => {
                     // 365.2425 * 24 * 60 * 60 = 31556952 seconds per year
                     // 15778476 seconds are 6 months
@@ -68,7 +58,7 @@ impl Date {
                 DateFlag::Formatted(format) => val.format(format).to_string(),
             }
         } else {
-            String::from("-")
+            String::from('-')
         }
     }
 }
@@ -215,8 +205,10 @@ mod test {
         let colors = Colors::new(ThemeOption::Default);
         let date = Date::from(&file_path.metadata().unwrap());
 
-        let mut flags = Flags::default();
-        flags.date = DateFlag::Relative;
+        let flags = Flags {
+            date: DateFlag::Relative,
+            ..Default::default()
+        };
 
         assert_eq!(
             "2 days ago".to_string().with(Color::AnsiValue(36)),
@@ -235,13 +227,15 @@ mod test {
         let success = cross_platform_touch(&file_path, &creation_date)
             .unwrap()
             .success();
-        assert_eq!(true, success, "failed to exec touch");
+        assert!(success, "failed to exec touch");
 
         let colors = Colors::new(ThemeOption::Default);
         let date = Date::from(&file_path.metadata().unwrap());
 
-        let mut flags = Flags::default();
-        flags.date = DateFlag::Relative;
+        let flags = Flags {
+            date: DateFlag::Relative,
+            ..Default::default()
+        };
 
         assert_eq!(
             "now".to_string().with(Color::AnsiValue(40)),
@@ -260,13 +254,15 @@ mod test {
         let success = cross_platform_touch(&file_path, &creation_date)
             .unwrap()
             .success();
-        assert_eq!(true, success, "failed to exec touch");
+        assert!(success, "failed to exec touch");
 
         let colors = Colors::new(ThemeOption::Default);
         let date = Date::from(&file_path.metadata().unwrap());
 
-        let mut flags = Flags::default();
-        flags.date = DateFlag::Iso;
+        let flags = Flags {
+            date: DateFlag::Iso,
+            ..Default::default()
+        };
 
         assert_eq!(
             creation_date
@@ -288,13 +284,15 @@ mod test {
         let success = cross_platform_touch(&file_path, &creation_date)
             .unwrap()
             .success();
-        assert_eq!(true, success, "failed to exec touch");
+        assert!(success, "failed to exec touch");
 
         let colors = Colors::new(ThemeOption::Default);
         let date = Date::from(&file_path.metadata().unwrap());
 
-        let mut flags = Flags::default();
-        flags.date = DateFlag::Iso;
+        let flags = Flags {
+            date: DateFlag::Iso,
+            ..Default::default()
+        };
 
         assert_eq!(
             creation_date
@@ -318,8 +316,10 @@ mod test {
         let colors = Colors::new(ThemeOption::Default);
         let date = Date::from(end_time);
 
-        let mut flags = Flags::default();
-        flags.date = DateFlag::Date;
+        let flags = Flags {
+            date: DateFlag::Date,
+            ..Default::default()
+        };
 
         assert_eq!(
             "-".to_string().with(Color::AnsiValue(36)),
diff --git a/src/meta/filetype.rs b/src/meta/filetype.rs
index 91bbdbd..27b59f7 100644
--- a/src/meta/filetype.rs
+++ b/src/meta/filetype.rs
@@ -91,18 +91,14 @@ impl FileType {
 impl FileType {
     pub fn render(self, colors: &Colors) -> ColoredString {
         match self {
-            FileType::File { exec, .. } => {
-                colors.colorize(String::from("."), &Elem::File { exec, uid: false })
-            }
-            FileType::Directory { .. } => {
-                colors.colorize(String::from("d"), &Elem::Dir { uid: false })
-            }
-            FileType::Pipe => colors.colorize(String::from("|"), &Elem::Pipe),
-            FileType::SymLink { .. } => colors.colorize(String::from("l"), &Elem::SymLink),
-            FileType::BlockDevice => colors.colorize(String::from("b"), &Elem::BlockDevice),
-            FileType::CharDevice => colors.colorize(String::from("c"), &Elem::CharDevice),
-            FileType::Socket => colors.colorize(String::from("s"), &Elem::Socket),
-            FileType::Special => colors.colorize(String::from("?"), &Elem::Special),
+            FileType::File { exec, .. } => colors.colorize('.', &Elem::File { exec, uid: false }),
+            FileType::Directory { .. } => colors.colorize('d', &Elem::Dir { uid: false }),
+            FileType::Pipe => colors.colorize('|', &Elem::Pipe),
+            FileType::SymLink { .. } => colors.colorize('l', &Elem::SymLink),
+            FileType::BlockDevice => colors.colorize('b', &Elem::BlockDevice),
+            FileType::CharDevice => colors.colorize('c', &Elem::CharDevice),
+            FileType::Socket => colors.colorize('s', &Elem::Socket),
+            FileType::Special => colors.colorize('?', &Elem::Special),
         }
     }
 }
@@ -147,8 +143,7 @@ mod test {
     #[test]
     fn test_dir_type() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
-        let meta = Meta::from_path(&tmp_dir.path().to_path_buf(), false)
-            .expect("failed to get tempdir path");
+        let meta = Meta::from_path(tmp_dir.path(), false).expect("failed to get tempdir path");
         let metadata = tmp_dir.path().metadata().expect("failed to get metas");
 
         let colors = Colors::new(ThemeOption::NoLscolors);
@@ -222,7 +217,7 @@ mod test {
             .status()
             .expect("failed to exec mkfifo")
             .success();
-        assert_eq!(true, success, "failed to exec mkfifo");
+        assert!(success, "failed to exec mkfifo");
         let meta = pipe_path.metadata().expect("failed to get metas");
 
         let colors = Colors::new(ThemeOption::NoLscolors);
@@ -250,7 +245,7 @@ mod test {
             .status()
             .expect("failed to exec mknod")
             .success();
-        assert_eq!(true, success, "failed to exec mknod");
+        assert!(success, "failed to exec mknod");
         let meta = char_device_path.metadata().expect("failed to get metas");
 
         let colors = Colors::new(ThemeOption::NoLscolors);
diff --git a/src/meta/indicator.rs b/src/meta/indicator.rs
index b0793dc..c81758b 100644
--- a/src/meta/indicator.rs
+++ b/src/meta/indicator.rs
@@ -38,53 +38,63 @@ mod test {
 
     #[test]
     fn test_directory_indicator() {
-        let mut flags = Flags::default();
-        flags.display_indicators = Indicators(true);
+        let flags = Flags {
+            display_indicators: Indicators(true),
+            ..Default::default()
+        };
 
         let file_type = Indicator::from(FileType::Directory { uid: false });
 
-        assert_eq!("/", file_type.render(&flags).to_string().as_str());
+        assert_eq!("/", file_type.render(&flags).to_string());
     }
 
     #[test]
     fn test_executable_file_indicator() {
-        let mut flags = Flags::default();
-        flags.display_indicators = Indicators(true);
+        let flags = Flags {
+            display_indicators: Indicators(true),
+            ..Default::default()
+        };
 
         let file_type = Indicator::from(FileType::File {
             uid: false,
             exec: true,
         });
 
-        assert_eq!("*", file_type.render(&flags).to_string().as_str());
+        assert_eq!("*", file_type.render(&flags).to_string());
     }
 
     #[test]
     fn test_socket_indicator() {
-        let mut flags = Flags::default();
-        flags.display_indicators = Indicators(true);
+        let flags = Flags {
+            display_indicators: Indicators(true),
+            ..Default::default()
+        };
 
         let file_type = Indicator::from(FileType::Socket);
 
-        assert_eq!("=", file_type.render(&flags).to_string().as_str());
+        assert_eq!("=", file_type.render(&flags).to_string());
     }
 
     #[test]
     fn test_symlink_indicator() {
-        let mut flags = Flags::default();
-        flags.display_indicators = Indicators(true);
+        let flags = Flags {
+            display_indicators: Indicators(true),
+            ..Default::default()
+        };
 
         let file_type = Indicator::from(FileType::SymLink { is_dir: false });
-        assert_eq!("@", file_type.render(&flags).to_string().as_str());
+        assert_eq!("@", file_type.render(&flags).to_string());
 
         let file_type = Indicator::from(FileType::SymLink { is_dir: true });
-        assert_eq!("@", file_type.render(&flags).to_string().as_str());
+        assert_eq!("@", file_type.render(&flags).to_string());
     }
 
     #[test]
     fn test_not_represented_indicator() {
-        let mut flags = Flags::default();
-        flags.display_indicators = Indicators(true);
+        let flags = Flags {
+            display_indicators: Indicators(true),
+            ..Default::default()
+        };
 
         // The File type doesn't have any indicator
         let file_type = Indicator::from(FileType::File {
@@ -92,6 +102,6 @@ mod test {
             uid: false,
         });
 
-        assert_eq!("", file_type.render(&flags).to_string().as_str());
+        assert_eq!("", file_type.render(&flags).to_string());
     }
 }
diff --git a/src/meta/inode.rs b/src/meta/inode.rs
index 6849947..7aac805 100644
--- a/src/meta/inode.rs
+++ b/src/meta/inode.rs
@@ -6,7 +6,7 @@ pub struct INode {
     index: Option<u64>,
 }
 
-impl<'a> From<&'a Metadata> for INode {
+impl From<&Metadata> for INode {
     #[cfg(unix)]
     fn from(meta: &Metadata) -> Self {
         use std::os::unix::fs::MetadataExt;
@@ -26,7 +26,7 @@ impl INode {
     pub fn render(&self, colors: &Colors) -> ColoredString {
         match self.index {
             Some(i) => colors.colorize(i.to_string(), &Elem::INode { valid: true }),
-            None => colors.colorize(String::from("-"), &Elem::INode { valid: false }),
+            None => colors.colorize('-', &Elem::INode { valid: false }),
         }
     }
 }
diff --git a/src/meta/links.rs b/src/meta/links.rs
index e103790..2372928 100644
--- a/src/meta/links.rs
+++ b/src/meta/links.rs
@@ -6,7 +6,7 @@ pub struct Links {
     nlink: Option<u64>,
 }
 
-impl<'a> From<&'a Metadata> for Links {
+impl From<&Metadata> for Links {
     #[cfg(unix)]
     fn from(meta: &Metadata) -> Self {
         use std::os::unix::fs::MetadataExt;
@@ -26,7 +26,7 @@ impl Links {
     pub fn render(&self, colors: &Colors) -> ColoredString {
         match self.nlink {
             Some(i) => colors.colorize(i.to_string(), &Elem::Links { valid: true }),
-            None => colors.colorize(String::from("-"), &Elem::Links { valid: false }),
+            None => colors.colorize('-', &Elem::Links { valid: false }),
         }
     }
 }
diff --git a/src/meta/mod.rs b/src/meta/mod.rs
index 8c0c41d..b83228b 100644
--- a/src/meta/mod.rs
+++ b/src/meta/mod.rs
@@ -29,7 +29,7 @@ pub use crate::icon::Icons;
 use crate::flags::{Display, Flags, Layout};
 use crate::print_error;
 
-use std::io::{Error, ErrorKind};
+use std::io::{self, Error, ErrorKind};
 use std::path::{Component, Path, PathBuf};
 
 #[derive(Clone, Debug)]
@@ -50,11 +50,7 @@ pub struct Meta {
 }
 
 impl Meta {
-    pub fn recurse_into(
-        &self,
-        depth: usize,
-        flags: &Flags,
-    ) -> Result<Option<Vec<Meta>>, std::io::Error> {
+    pub fn recurse_into(&self, depth: usize, flags: &Flags) -> io::Result<Option<Vec<Meta>>> {
         if depth == 0 {
             return Ok(None);
         }
@@ -103,14 +99,12 @@ impl Meta {
                 .file_name()
                 .ok_or_else(|| Error::new(ErrorKind::InvalidInput, "invalid file name"))?;
 
-            if flags.ignore_globs.0.is_match(&name) {
+            if flags.ignore_globs.0.is_match(name) {
                 continue;
             }
 
-            if let Display::VisibleOnly = flags.display {
-                if name.to_string_lossy().starts_with('.') {
-                    continue;
-                }
+            if flags.display == Display::VisibleOnly && name.to_string_lossy().starts_with('.') {
+                continue;
             }
 
             let mut entry_meta = match Self::from_path(&path, flags.dereference.0) {
@@ -122,17 +116,15 @@ impl Meta {
             };
 
             // skip files for --tree -d
-            if flags.layout == Layout::Tree {
-                if let Display::DirectoryOnly = flags.display {
-                    if !entry.file_type()?.is_dir() {
-                        continue;
-                    }
-                }
+            if flags.layout == Layout::Tree
+                && flags.display == Display::DirectoryOnly
+                && !entry.file_type()?.is_dir()
+            {
+                continue;
             }
 
-            let dereference =
-                !matches!(entry_meta.file_type, FileType::SymLink { .. }) || flags.dereference.0;
-            if dereference {
+            // check dereferencing
+            if flags.dereference.0 || !matches!(entry_meta.file_type, FileType::SymLink { .. }) {
                 match entry_meta.recurse_into(depth - 1, flags) {
                     Ok(content) => entry_meta.content = content,
                     Err(err) => {
@@ -202,7 +194,7 @@ impl Meta {
         }
     }
 
-    pub fn from_path(path: &Path, dereference: bool) -> Result<Self, std::io::Error> {
+    pub fn from_path(path: &Path, dereference: bool) -> io::Result<Self> {
         let mut metadata = path.symlink_metadata()?;
         let mut symlink_meta = None;
         if metadata.file_type().is_symlink() {
diff --git a/src/meta/name.rs b/src/meta/name.rs
index 139ff88..8bfa5d5 100644
--- a/src/meta/name.rs
+++ b/src/meta/name.rs
@@ -78,7 +78,7 @@ impl Name {
             .collect()
     }
 
-    pub fn escape(&self, string: &str) -> String {
+    fn escape(&self, string: &str) -> String {
         if string
             .chars()
             .all(|c| c >= 0x20 as char && c != 0x7f as char)
@@ -105,29 +105,22 @@ impl Name {
                 // HyperlinkOption::Auto gets converted to None or Always in core.rs based on tty_available
                 match std::fs::canonicalize(&self.path) {
                     Ok(rp) => {
-                        match Url::from_file_path(&rp) {
-                            Ok(url) => {
-                                // Crossterm does not support hyperlinks as of now
-                                // https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
-                                format!("\x1B]8;;{}\x1B\x5C{}\x1B]8;;\x1B\x5C", url, name)
-                            }
-                            Err(_) => {
-                                print_error!("{}: unable to form url.", name);
-                                name
-                            }
+                        if let Ok(url) = Url::from_file_path(&rp) {
+                            // Crossterm does not support hyperlinks as of now
+                            // https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
+                            format!("\x1B]8;;{}\x1B\x5C{}\x1B]8;;\x1B\x5C", url, name)
+                        } else {
+                            print_error!("{}: unable to form url.", name);
+                            name
                         }
                     }
                     Err(err) => {
-                        match err.kind() {
-                            std::io::ErrorKind::NotFound => {
-                                // If this happens, it just means the file is a broken symlink. This is not an error, and the user is already warned that the symlink is broken by the colors.
-                                name
-                            }
-                            _ => {
-                                print_error!("{}: {}", name, err);
-                                name
-                            }
+                        // If the error is NotFound, it just means the file is a broken symlink.
+                        // That is not an error, and the user is already warned that the symlink is broken by the colors.
+                        if err.kind() != std::io::ErrorKind::NotFound {
+                            print_error!("{}: {}", name, err);
                         }
+                        name
                     }
                 }
             }
@@ -358,7 +351,7 @@ mod test {
             .status()
             .expect("failed to exec mkfifo")
             .success();
-        assert_eq!(true, success, "failed to exec mkfifo");
+        assert!(success, "failed to exec mkfifo");
         let meta = pipe_path.metadata().expect("failed to get metas");
 
         let colors = Colors::new(color::ThemeOption::NoLscolors);
@@ -398,7 +391,6 @@ mod test {
                     HyperlinkOption::Never
                 )
                 .to_string()
-                .as_str()
         );
     }
 
@@ -431,7 +423,6 @@ mod test {
                     HyperlinkOption::Always
                 )
                 .to_string()
-                .as_str()
         );
     }
 
@@ -440,7 +431,7 @@ mod test {
         let path = Path::new("some-file.txt");
 
         let name = Name::new(
-            &path,
+            path,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -455,7 +446,7 @@ mod test {
         let path = Path::new(".gitignore");
 
         let name = Name::new(
-            &path,
+            path,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -469,7 +460,7 @@ mod test {
     fn test_order_impl_is_case_insensitive() {
         let path_1 = Path::new("/AAAA");
         let name_1 = Name::new(
-            &path_1,
+            path_1,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -478,7 +469,7 @@ mod test {
 
         let path_2 = Path::new("/aaaa");
         let name_2 = Name::new(
-            &path_2,
+            path_2,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -492,7 +483,7 @@ mod test {
     fn test_partial_order_impl() {
         let path_a = Path::new("/aaaa");
         let name_a = Name::new(
-            &path_a,
+            path_a,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -501,21 +492,21 @@ mod test {
 
         let path_z = Path::new("/zzzz");
         let name_z = Name::new(
-            &path_z,
+            path_z,
             FileType::File {
                 uid: false,
                 exec: false,
             },
         );
 
-        assert_eq!(true, name_a < name_z);
+        assert!(name_a < name_z);
     }
 
     #[test]
     fn test_partial_order_impl_is_case_insensitive() {
         let path_a = Path::new("aaaa");
         let name_a = Name::new(
-            &path_a,
+            path_a,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -524,21 +515,21 @@ mod test {
 
         let path_z = Path::new("ZZZZ");
         let name_z = Name::new(
-            &path_z,
+            path_z,
             FileType::File {
                 uid: false,
                 exec: false,
             },
         );
 
-        assert_eq!(true, name_a < name_z);
+        assert!(name_a < name_z);
     }
 
     #[test]
     fn test_partial_eq_impl() {
         let path_1 = Path::new("aaaa");
         let name_1 = Name::new(
-            &path_1,
+            path_1,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -547,21 +538,21 @@ mod test {
 
         let path_2 = Path::new("aaaa");
         let name_2 = Name::new(
-            &path_2,
+            path_2,
             FileType::File {
                 uid: false,
                 exec: false,
             },
         );
 
-        assert_eq!(true, name_1 == name_2);
+        assert!(name_1 == name_2);
     }
 
     #[test]
     fn test_partial_eq_impl_is_case_insensitive() {
         let path_1 = Path::new("AAAA");
         let name_1 = Name::new(
-            &path_1,
+            path_1,
             FileType::File {
                 uid: false,
                 exec: false,
@@ -570,14 +561,14 @@ mod test {
 
         let path_2 = Path::new("aaaa");
         let name_2 = Name::new(
-            &path_2,
+            path_2,
             FileType::File {
                 uid: false,
                 exec: false,
             },
         );
 
-        assert_eq!(true, name_1 == name_2);
+        assert!(name_1 == name_2);
     }
 
     #[test]
diff --git a/src/meta/owner.rs b/src/meta/owner.rs
index a9ecd5c..ea48736 100644
--- a/src/meta/owner.rs
+++ b/src/meta/owner.rs
@@ -16,7 +16,7 @@ impl Owner {
 }
 
 #[cfg(unix)]
-impl<'a> From<&'a Metadata> for Owner {
+impl From<&Metadata> for Owner {
     fn from(meta: &Metadata) -> Self {
         use std::os::unix::fs::MetadataExt;
         use users::{get_group_by_gid, get_user_by_uid};
diff --git a/src/meta/permissions.rs b/src/meta/permissions.rs
index d67f96a..79a0e47 100644
--- a/src/meta/permissions.rs
+++ b/src/meta/permissions.rs
@@ -21,7 +21,7 @@ pub struct Permissions {
     pub setuid: bool,
 }
 
-impl<'a> From<&'a Metadata> for Permissions {
+impl From<&Metadata> for Permissions {
     #[cfg(unix)]
     fn from(meta: &Metadata) -> Self {
         use std::os::unix::fs::PermissionsExt;
@@ -62,65 +62,68 @@ impl Permissions {
     pub fn render(&self, colors: &Colors, flags: &Flags) -> ColoredString {
         let bit = |bit, chr: &'static str, elem: &Elem| {
             if bit {
-                colors.colorize(String::from(chr), elem)
+                colors.colorize(chr, elem)
             } else {
-                colors.colorize(String::from("-"), &Elem::NoAccess)
+                colors.colorize('-', &Elem::NoAccess)
             }
         };
 
-        let strings = match flags.permission {
-            PermissionFlag::Rwx => vec![
+        let res = match flags.permission {
+            PermissionFlag::Rwx => [
                 // User permissions
                 bit(self.user_read, "r", &Elem::Read),
                 bit(self.user_write, "w", &Elem::Write),
                 match (self.user_execute, self.setuid) {
-                    (false, false) => colors.colorize(String::from("-"), &Elem::NoAccess),
-                    (true, false) => colors.colorize(String::from("x"), &Elem::Exec),
-                    (false, true) => colors.colorize(String::from("S"), &Elem::ExecSticky),
-                    (true, true) => colors.colorize(String::from("s"), &Elem::ExecSticky),
+                    (false, false) => colors.colorize('-', &Elem::NoAccess),
+                    (true, false) => colors.colorize('x', &Elem::Exec),
+                    (false, true) => colors.colorize('S', &Elem::ExecSticky),
+                    (true, true) => colors.colorize('s', &Elem::ExecSticky),
                 },
                 // Group permissions
                 bit(self.group_read, "r", &Elem::Read),
                 bit(self.group_write, "w", &Elem::Write),
                 match (self.group_execute, self.setgid) {
-                    (false, false) => colors.colorize(String::from("-"), &Elem::NoAccess),
-                    (true, false) => colors.colorize(String::from("x"), &Elem::Exec),
-                    (false, true) => colors.colorize(String::from("S"), &Elem::ExecSticky),
-                    (true, true) => colors.colorize(String::from("s"), &Elem::ExecSticky),
+                    (false, false) => colors.colorize('-', &Elem::NoAccess),
+                    (true, false) => colors.colorize('x', &Elem::Exec),
+                    (false, true) => colors.colorize('S', &Elem::ExecSticky),
+                    (true, true) => colors.colorize('s', &Elem::ExecSticky),
                 },
                 // Other permissions
                 bit(self.other_read, "r", &Elem::Read),
                 bit(self.other_write, "w", &Elem::Write),
                 match (self.other_execute, self.sticky) {
-                    (false, false) => colors.colorize(String::from("-"), &Elem::NoAccess),
-                    (true, false) => colors.colorize(String::from("x"), &Elem::Exec),
-                    (false, true) => colors.colorize(String::from("T"), &Elem::ExecSticky),
-                    (true, true) => colors.colorize(String::from("t"), &Elem::ExecSticky),
+                    (false, false) => colors.colorize('-', &Elem::NoAccess),
+                    (true, false) => colors.colorize('x', &Elem::Exec),
+                    (false, true) => colors.colorize('T', &Elem::ExecSticky),
+                    (true, true) => colors.colorize('t', &Elem::ExecSticky),
                 },
-            ],
+            ]
+            .into_iter()
+            // From the experiment, the maximum string size is 153 bytes
+            .fold(String::with_capacity(160), |mut acc, x| {
+                acc.push_str(&x.to_string());
+                acc
+            }),
             PermissionFlag::Octal => {
-                let octal_sticky = Self::bits_to_octal(self.setuid, self.setgid, self.sticky);
-                let octal_user =
-                    Self::bits_to_octal(self.user_read, self.user_write, self.user_execute);
-                let octal_group =
-                    Self::bits_to_octal(self.group_read, self.group_write, self.group_execute);
-                let octal_other =
-                    Self::bits_to_octal(self.other_read, self.other_write, self.other_execute);
-                vec![colors.colorize(
-                    format!(
-                        "{}{}{}{}",
-                        octal_sticky, octal_user, octal_group, octal_other
-                    ),
-                    &Elem::Octal,
-                )]
+                let octals = [
+                    Self::bits_to_octal(self.setuid, self.setgid, self.sticky),
+                    Self::bits_to_octal(self.user_read, self.user_write, self.user_execute),
+                    Self::bits_to_octal(self.group_read, self.group_write, self.group_execute),
+                    Self::bits_to_octal(self.other_read, self.other_write, self.other_execute),
+                ]
+                .into_iter()
+                .fold(String::with_capacity(4), |mut acc, x| {
+                    acc.push(
+                        char::from_digit(x as u32, 8)
+                            .expect("octal value of permission should not be greater than 7"),
+                    );
+                    acc
+                });
+
+                colors.colorize(octals, &Elem::Octal).to_string()
             }
         };
 
-        let res = strings
-            .iter()
-            .map(|s| s.to_string())
-            .collect::<Vec<String>>()
-            .join("");
         ColoredString::new(Colors::default_style(), res)
     }
 
@@ -166,7 +169,7 @@ mod test {
     use tempfile::tempdir;
 
     #[test]
-    pub fn permission_rwx() {
+    fn permission_rwx() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
 
         // Create the file;
@@ -186,7 +189,7 @@ mod test {
     }
 
     #[test]
-    pub fn permission_rwx2() {
+    fn permission_rwx2() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
 
         // Create the file;
@@ -206,7 +209,7 @@ mod test {
     }
 
     #[test]
-    pub fn permission_rwx_sticky() {
+    fn permission_rwx_sticky() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
 
         // Create the file;
@@ -218,15 +221,17 @@ mod test {
         let meta = file_path.metadata().expect("failed to get meta");
 
         let colors = Colors::new(ThemeOption::NoColor);
-        let mut flags = Flags::default();
-        flags.permission = PermissionFlag::Rwx;
+        let flags = Flags {
+            permission: PermissionFlag::Rwx,
+            ..Default::default()
+        };
         let perms = Permissions::from(&meta);
 
         assert_eq!("rwxrwxrwt", perms.render(&colors, &flags).content());
     }
 
     #[test]
-    pub fn permission_octal() {
+    fn permission_octal() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
 
         // Create the file;
@@ -237,15 +242,17 @@ mod test {
         let meta = file_path.metadata().expect("failed to get meta");
 
         let colors = Colors::new(ThemeOption::NoColor);
-        let mut flags = Flags::default();
-        flags.permission = PermissionFlag::Octal;
+        let flags = Flags {
+            permission: PermissionFlag::Octal,
+            ..Default::default()
+        };
         let perms = Permissions::from(&meta);
 
         assert_eq!("0655", perms.render(&colors, &flags).content());
     }
 
     #[test]
-    pub fn permission_octal2() {
+    fn permission_octal2() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
 
         // Create the file;
@@ -256,15 +263,17 @@ mod test {
         let meta = file_path.metadata().expect("failed to get meta");
 
         let colors = Colors::new(ThemeOption::NoColor);
-        let mut flags = Flags::default();
-        flags.permission = PermissionFlag::Octal;
+        let flags = Flags {
+            permission: PermissionFlag::Octal,
+            ..Default::default()
+        };
         let perms = Permissions::from(&meta);
 
         assert_eq!("0777", perms.render(&colors, &flags).content());
     }
 
     #[test]
-    pub fn permission_octal_sticky() {
+    fn permission_octal_sticky() {
         let tmp_dir = tempdir().expect("failed to create temp dir");
 
         // Create the file;
@@ -276,8 +285,10 @@ mod test {
         let meta = file_path.metadata().expect("failed to get meta");
 
         let colors = Colors::new(ThemeOption::NoColor);
-        let mut flags = Flags::default();
-        flags.permission = PermissionFlag::Octal;
+        let flags = Flags {
+            permission: PermissionFlag::Octal,
+            ..Default::default()
+        };
         let perms = Permissions::from(&meta);
 
         assert_eq!("1777", perms.render(&colors, &flags).content());
diff --git a/src/meta/size.rs b/src/meta/size.rs
index f4dd763..9f39b99 100644
--- a/src/meta/size.rs
+++ b/src/meta/size.rs
@@ -2,9 +2,13 @@ use crate::color::{ColoredString, Colors, Elem};
 use crate::flags::{Flags, SizeFlag};
 use std::fs::Metadata;
 
+const KB: u64 = 1024;
+const MB: u64 = 1024_u64.pow(2);
+const GB: u64 = 1024_u64.pow(3);
+const TB: u64 = 1024_u64.pow(4);
+
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub enum Unit {
-    None,
     Byte,
     Kilo,
     Mega,
@@ -17,10 +21,9 @@ pub struct Size {
     bytes: u64,
 }
 
-impl<'a> From<&'a Metadata> for Size {
+impl From<&Metadata> for Size {
     fn from(meta: &Metadata) -> Self {
-        let len = meta.len();
-        Self { bytes: len }
+        Self { bytes: meta.len() }
     }
 }
 
@@ -37,17 +40,17 @@ impl Size {
         format!("{0:.1$}", number, if number < 10.0 { 1 } else { 0 })
     }
 
-    pub fn get_unit(&self, flags: &Flags) -> Unit {
-        if self.bytes < 1024 || flags.size == SizeFlag::Bytes {
-            Unit::Byte
-        } else if self.bytes < 1024 * 1024 {
-            Unit::Kilo
-        } else if self.bytes < 1024 * 1024 * 1024 {
-            Unit::Mega
-        } else if self.bytes < 1024 * 1024 * 1024 * 1024 {
-            Unit::Giga
-        } else {
-            Unit::Tera
+    fn get_unit(&self, flags: &Flags) -> Unit {
+        if flags.size == SizeFlag::Bytes {
+            return Unit::Byte;
+        }
+
+        match self.bytes {
+            b if b < KB => Unit::Byte,
+            b if b < MB => Unit::Kilo,
+            b if b < GB => Unit::Mega,
+            b if b < TB => Unit::Giga,
+            _ => Unit::Tera,
         }
     }
 
@@ -85,16 +88,13 @@ impl Size {
 
     fn paint(&self, colors: &Colors, flags: &Flags, content: String) -> ColoredString {
         let unit = self.get_unit(flags);
+        let elem = match unit {
+            Unit::Byte | Unit::Kilo => &Elem::FileSmall,
+            Unit::Mega => &Elem::FileMedium,
+            _ => &Elem::FileLarge,
+        };
 
-        if unit == Unit::None {
-            colors.colorize(content, &Elem::NonFile)
-        } else if unit == Unit::Byte || unit == Unit::Kilo {
-            colors.colorize(content, &Elem::FileSmall)
-        } else if unit == Unit::Mega {
-            colors.colorize(content, &Elem::FileMedium)
-        } else {
-            colors.colorize(content, &Elem::FileLarge)
-        }
+        colors.colorize(content, elem)
     }
 
     pub fn render_value(&self, colors: &Colors, flags: &Flags) -> ColoredString {
@@ -107,18 +107,11 @@ impl Size {
         let unit = self.get_unit(flags);
 
         match unit {
-            Unit::None => "".to_string(),
             Unit::Byte => self.bytes.to_string(),
-            Unit::Kilo => self.format_size(((self.bytes as f64) / 1024.0 * 10.0).round() / 10.0),
-            Unit::Mega => {
-                self.format_size(((self.bytes as f64) / (1024.0 * 1024.0) * 10.0).round() / 10.0)
-            }
-            Unit::Giga => self.format_size(
-                ((self.bytes as f64) / (1024.0 * 1024.0 * 1024.0) * 10.0).round() / 10.0,
-            ),
-            Unit::Tera => self.format_size(
-                ((self.bytes as f64) / (1024.0 * 1024.0 * 1024.0 * 1024.0) * 10.0).round() / 10.0,
-            ),
+            Unit::Kilo => self.format_size(((self.bytes as f64 / KB as f64) * 10.0).round() / 10.0),
+            Unit::Mega => self.format_size(((self.bytes as f64 / MB as f64) * 10.0).round() / 10.0),
+            Unit::Giga => self.format_size(((self.bytes as f64 / GB as f64) * 10.0).round() / 10.0),
+            Unit::Tera => self.format_size(((self.bytes as f64 / TB as f64) * 10.0).round() / 10.0),
         }
     }
 
@@ -133,20 +126,18 @@ impl Size {
 
         match flags.size {
             SizeFlag::Default => match unit {
-                Unit::None => String::from("-"),
-                Unit::Byte => String::from("B"),
+                Unit::Byte => String::from('B'),
                 Unit::Kilo => String::from("KB"),
                 Unit::Mega => String::from("MB"),
                 Unit::Giga => String::from("GB"),
                 Unit::Tera => String::from("TB"),
             },
             SizeFlag::Short => match unit {
-                Unit::None => String::from("-"),
-                Unit::Byte => String::from("B"),
-                Unit::Kilo => String::from("K"),
-                Unit::Mega => String::from("M"),
-                Unit::Giga => String::from("G"),
-                Unit::Tera => String::from("T"),
+                Unit::Byte => String::from('B'),
+                Unit::Kilo => String::from('K'),
+                Unit::Mega => String::from('M'),
+                Unit::Giga => String::from('G'),
+                Unit::Tera => String::from('T'),
             },
             SizeFlag::Bytes => String::from(""),
         }
@@ -155,7 +146,7 @@ impl Size {
 
 #[cfg(test)]
 mod test {
-    use super::Size;
+    use super::{Size, GB, KB, MB, TB};
     use crate::color::{Colors, ThemeOption};
     use crate::flags::{Flags, SizeFlag};
 
@@ -164,170 +155,172 @@ mod test {
         let size = Size::new(42); // == 42 bytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
+        assert_eq!(size.value_string(&flags), "42");
 
-        assert_eq!(size.unit_string(&flags).as_str(), "B");
+        assert_eq!(size.unit_string(&flags), "B");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "B");
+        assert_eq!(size.unit_string(&flags), "B");
         flags.size = SizeFlag::Bytes;
-        assert_eq!(size.unit_string(&flags).as_str(), "");
+        assert_eq!(size.unit_string(&flags), "");
     }
 
     #[test]
     fn render_10_minus_kilobyte() {
-        let size = Size::new(4 * 1024); // 4 kilobytes
+        let size = Size::new(4 * KB); // 4 kilobytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "4.0");
-        assert_eq!(size.unit_string(&flags).as_str(), "KB");
+        assert_eq!(size.value_string(&flags), "4.0");
+        assert_eq!(size.unit_string(&flags), "KB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "K");
+        assert_eq!(size.unit_string(&flags), "K");
     }
 
     #[test]
     fn render_kilobyte() {
-        let size = Size::new(42 * 1024); // 42 kilobytes
+        let size = Size::new(42 * KB); // 42 kilobytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
-        assert_eq!(size.unit_string(&flags).as_str(), "KB");
+        assert_eq!(size.value_string(&flags), "42");
+        assert_eq!(size.unit_string(&flags), "KB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "K");
+        assert_eq!(size.unit_string(&flags), "K");
     }
 
     #[test]
     fn render_100_plus_kilobyte() {
-        let size = Size::new(420 * 1024 + 420); // 420.4 kilobytes
+        let size = Size::new(420 * KB + 420); // 420.4 kilobytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "420");
-        assert_eq!(size.unit_string(&flags).as_str(), "KB");
+        assert_eq!(size.value_string(&flags), "420");
+        assert_eq!(size.unit_string(&flags), "KB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "K");
+        assert_eq!(size.unit_string(&flags), "K");
     }
 
     #[test]
     fn render_10_minus_megabyte() {
-        let size = Size::new(4 * 1024 * 1024); // 4 megabytes
+        let size = Size::new(4 * MB); // 4 megabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "4.0");
-        assert_eq!(size.unit_string(&flags).as_str(), "MB");
+        assert_eq!(size.value_string(&flags), "4.0");
+        assert_eq!(size.unit_string(&flags), "MB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "M");
+        assert_eq!(size.unit_string(&flags), "M");
     }
 
     #[test]
     fn render_megabyte() {
-        let size = Size::new(42 * 1024 * 1024); // 42 megabytes
+        let size = Size::new(42 * MB); // 42 megabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
-        assert_eq!(size.unit_string(&flags).as_str(), "MB");
+        assert_eq!(size.value_string(&flags), "42");
+        assert_eq!(size.unit_string(&flags), "MB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "M");
+        assert_eq!(size.unit_string(&flags), "M");
     }
 
     #[test]
     fn render_100_plus_megabyte() {
-        let size = Size::new(420 * 1024 * 1024 + 420 * 1024); // 420.4 megabytes
+        let size = Size::new(420 * MB + 420 * KB); // 420.4 megabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "420");
-        assert_eq!(size.unit_string(&flags).as_str(), "MB");
+        assert_eq!(size.value_string(&flags), "420");
+        assert_eq!(size.unit_string(&flags), "MB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "M");
+        assert_eq!(size.unit_string(&flags), "M");
     }
 
     #[test]
     fn render_10_minus_gigabyte() {
-        let size = Size::new(4 * 1024 * 1024 * 1024); // 4 gigabytes
+        let size = Size::new(4 * GB); // 4 gigabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "4.0");
-        assert_eq!(size.unit_string(&flags).as_str(), "GB");
+        assert_eq!(size.value_string(&flags), "4.0");
+        assert_eq!(size.unit_string(&flags), "GB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "G");
+        assert_eq!(size.unit_string(&flags), "G");
     }
 
     #[test]
     fn render_gigabyte() {
-        let size = Size::new(42 * 1024 * 1024 * 1024); // 42 gigabytes
+        let size = Size::new(42 * GB); // 42 gigabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
-        assert_eq!(size.unit_string(&flags).as_str(), "GB");
+        assert_eq!(size.value_string(&flags), "42");
+        assert_eq!(size.unit_string(&flags), "GB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "G");
+        assert_eq!(size.unit_string(&flags), "G");
     }
 
     #[test]
     fn render_100_plus_gigabyte() {
-        let size = Size::new(420 * 1024 * 1024 * 1024 + 420 * 1024 * 1024); // 420.4 gigabytes
+        let size = Size::new(420 * GB + 420 * MB); // 420.4 gigabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "420");
-        assert_eq!(size.unit_string(&flags).as_str(), "GB");
+        assert_eq!(size.value_string(&flags), "420");
+        assert_eq!(size.unit_string(&flags), "GB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "G");
+        assert_eq!(size.unit_string(&flags), "G");
     }
 
     #[test]
     fn render_10_minus_terabyte() {
-        let size = Size::new(4 * 1024 * 1024 * 1024 * 1024); // 4 terabytes
+        let size = Size::new(4 * TB); // 4 terabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "4.0");
-        assert_eq!(size.unit_string(&flags).as_str(), "TB");
+        assert_eq!(size.value_string(&flags), "4.0");
+        assert_eq!(size.unit_string(&flags), "TB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "T");
+        assert_eq!(size.unit_string(&flags), "T");
     }
 
     #[test]
     fn render_terabyte() {
-        let size = Size::new(42 * 1024 * 1024 * 1024 * 1024); // 42 terabytes
+        let size = Size::new(42 * TB); // 42 terabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
-        assert_eq!(size.unit_string(&flags).as_str(), "TB");
+        assert_eq!(size.value_string(&flags), "42");
+        assert_eq!(size.unit_string(&flags), "TB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "T");
+        assert_eq!(size.unit_string(&flags), "T");
     }
 
     #[test]
     fn render_100_plus_terabyte() {
-        let size = Size::new(420 * 1024 * 1024 * 1024 * 1024 + 420 * 1024 * 1024 * 1024); // 420.4 terabytes
+        let size = Size::new(420 * TB + 420 * GB); // 420.4 terabytes
         let mut flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "420");
-        assert_eq!(size.unit_string(&flags).as_str(), "TB");
+        assert_eq!(size.value_string(&flags), "420");
+        assert_eq!(size.unit_string(&flags), "TB");
         flags.size = SizeFlag::Short;
-        assert_eq!(size.unit_string(&flags).as_str(), "T");
+        assert_eq!(size.unit_string(&flags), "T");
     }
 
     #[test]
     fn render_with_a_fraction() {
-        let size = Size::new(42 * 1024 + 103); // 42.1 kilobytes
+        let size = Size::new(42 * KB + 103); // 42.1 kilobytes
         let flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
-        assert_eq!(size.unit_string(&flags).as_str(), "KB");
+        assert_eq!(size.value_string(&flags), "42");
+        assert_eq!(size.unit_string(&flags), "KB");
     }
 
     #[test]
     fn render_with_a_truncated_fraction() {
-        let size = Size::new(42 * 1024 + 1); // 42.001 kilobytes == 42 kilobytes
+        let size = Size::new(42 * KB + 1); // 42.001 kilobytes == 42 kilobytes
         let flags = Flags::default();
 
-        assert_eq!(size.value_string(&flags).as_str(), "42");
-        assert_eq!(size.unit_string(&flags).as_str(), "KB");
+        assert_eq!(size.value_string(&flags), "42");
+        assert_eq!(size.unit_string(&flags), "KB");
     }
 
     #[test]
     fn render_short_nospaces() {
-        let size = Size::new(42 * 1024); // 42 kilobytes
-        let mut flags = Flags::default();
-        flags.size = SizeFlag::Short;
+        let size = Size::new(42 * KB); // 42 kilobytes
+        let flags = Flags {
+            size: SizeFlag::Short,
+            ..Default::default()
+        };
         let colors = Colors::new(ThemeOption::NoColor);
 
         assert_eq!(size.render(&colors, &flags, Some(2)).to_string(), "42K");
diff --git a/src/meta/symlink.rs b/src/meta/symlink.rs
index bb9437c..224d4fc 100644
--- a/src/meta/symlink.rs
+++ b/src/meta/symlink.rs
@@ -9,8 +9,8 @@ pub struct SymLink {
     valid: bool,
 }
 
-impl<'a> From<&'a Path> for SymLink {
-    fn from(path: &'a Path) -> Self {
+impl From<&Path> for SymLink {
+    fn from(path: &Path) -> Self {
         if let Ok(target) = read_link(path) {
             if target.is_absolute() || path.parent() == None {
                 return Self {
@@ -86,7 +86,7 @@ mod tests {
             target: Some("/target".to_string()),
             valid: true,
         };
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             format!("{}", " ⇒ /target"),
@@ -104,7 +104,7 @@ mod tests {
             target: Some("/target".to_string()),
             valid: false,
         };
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             format!("{}", " ⇒ /target"),
@@ -122,7 +122,7 @@ mod tests {
             target: Some("/target".to_string()),
             valid: false,
         };
-        let argv = vec!["lsd"];
+        let argv = ["lsd"];
         let matches = app::build().get_matches_from_safe(argv).unwrap();
         assert_eq!(
             format!("{}", " ⇒ \u{1b}[38;5;124m/target\u{1b}[39m"),
diff --git a/src/meta/windows_utils.rs b/src/meta/windows_utils.rs
index 3d34498..456f850 100644
--- a/src/meta/windows_utils.rs
+++ b/src/meta/windows_utils.rs
@@ -217,7 +217,7 @@ unsafe fn get_acl_access_mask(
 /// is
 ///
 /// Note: winapi's TRUSTEE_W looks different from the one in the MS docs because
-/// of some unusal pre-processor macros in the original .h file. The winapi
+/// of some unusual pre-processor macros in the original .h file. The winapi
 /// version is correct (MS's doc generator messed up)
 unsafe fn trustee_from_sid(sid_ptr: *mut c_void) -> TRUSTEE_W {
     let mut trustee: TRUSTEE_W = std::mem::zeroed();
diff --git a/src/sort.rs b/src/sort.rs
index a80d990..b744b52 100644
--- a/src/sort.rs
+++ b/src/sort.rs
@@ -124,7 +124,7 @@ mod tests {
         let sorter = assemble_sorters(&flags);
         assert_eq!(by_meta(&sorter, &meta_a, &meta_z), Ordering::Less);
 
-        // Sort with file first reversed (thie files stay first)
+        // Sort with file first reversed (this files stay first)
         let sorter = assemble_sorters(&flags);
         assert_eq!(by_meta(&sorter, &meta_a, &meta_z), Ordering::Less);
     }
@@ -217,7 +217,7 @@ mod tests {
             .unwrap()
             .success();
 
-        assert_eq!(true, success, "failed to change file timestamp");
+        assert!(success, "failed to change file timestamp");
         let meta_z = Meta::from_path(&path_z, false).expect("failed to get meta");
 
         let mut flags = Flags::default();
