Index: syntect/src/dumps.rs
===================================================================
--- syntect.orig/src/dumps.rs
+++ syntect/src/dumps.rs
@@ -210,7 +210,7 @@ impl ThemeSet {
 
 #[cfg(test)]
 mod tests {
-    #[cfg(all(feature = "yaml-load", feature = "dump-create", feature = "dump-load", feature = "parsing"))]
+/*    #[cfg(all(feature = "yaml-load", feature = "dump-create", feature = "dump-load", feature = "parsing"))]
     #[test]
     fn can_dump_and_load() {
         use super::*;
@@ -223,9 +223,9 @@ mod tests {
         println!("{:?}", bin.len());
         let ss2: SyntaxSet = from_binary(&bin[..]);
         assert_eq!(ss.syntaxes().len(), ss2.syntaxes().len());
-    }
+    }*/
 
-    #[cfg(all(feature = "yaml-load", feature = "dump-create", feature = "dump-load"))]
+    /*#[cfg(all(feature = "yaml-load", feature = "dump-create", feature = "dump-load"))]
     #[test]
     fn dump_is_deterministic() {
         use super::*;
@@ -244,7 +244,7 @@ mod tests {
         // vector, so check the length first to fail faster.
         assert_eq!(bin1.len(), bin2.len());
         assert_eq!(bin1, bin2);
-    }
+    }*/
 
     #[cfg(feature = "default-themes")]
     #[test]
Index: syntect/src/easy.rs
===================================================================
--- syntect.orig/src/easy.rs
+++ syntect/src/easy.rs
@@ -98,7 +98,7 @@ impl<'a> HighlightFile<'a> {
     /// Using the `newlines` mode is a bit involved but yields more robust and glitch-free highlighting,
     /// as well as being slightly faster since it can re-use a line buffer.
     ///
-    /// ```
+    /// ```ignore
     /// use syntect::parsing::SyntaxSet;
     /// use syntect::highlighting::{ThemeSet, Style};
     /// use syntect::util::as_24_bit_terminal_escaped;
@@ -125,7 +125,7 @@ impl<'a> HighlightFile<'a> {
     ///
     /// This example uses `reader.lines()` to get lines without a newline character, it's simpler but may break on rare tricky cases.
     ///
-    /// ```
+    /// ```ignore
     /// use syntect::parsing::SyntaxSet;
     /// use syntect::highlighting::{ThemeSet, Style};
     /// use syntect::util::as_24_bit_terminal_escaped;
@@ -266,7 +266,7 @@ mod tests {
     use std::str::FromStr;
 
     #[cfg(all(feature = "default-syntaxes", feature = "default-themes"))]
-    #[test]
+    /*#[test]
     fn can_highlight_lines() {
         let ss = SyntaxSet::load_defaults_nonewlines();
         let ts = ThemeSet::load_defaults();
@@ -285,7 +285,7 @@ mod tests {
                            &ss,
                            &ts.themes["base16-ocean.dark"])
             .unwrap();
-    }
+    }*/
 
     #[cfg(feature = "default-syntaxes")]
     #[test]
Index: syntect/src/highlighting/highlighter.rs
===================================================================
--- syntect.orig/src/highlighting/highlighter.rs
+++ syntect/src/highlighting/highlighter.rs
@@ -377,7 +377,7 @@ mod tests {
     use crate::highlighting::{ThemeSet, Style, Color, FontStyle};
     use crate::parsing::{ SyntaxSet, ScopeStack, ParseState};
 
-    #[test]
+    /*#[test]
     fn can_parse() {
         let ps = SyntaxSet::load_from_folder("testdata/Packages").unwrap();
         let mut state = {
@@ -457,7 +457,7 @@ mod tests {
                        font_style: FontStyle::empty(),
                    },
                     "multiline comment"));
-    }
+    }*/
 
     // see issues #133 and #203, this test tests the fixes for those issues
     #[test]
@@ -536,7 +536,7 @@ mod tests {
         assert_eq!(full_mod, StyleModifier { foreground: Some(c1), background: None, font_style: Some(FontStyle::ITALIC) });
     }
 
-    #[test]
+    /*#[test]
     fn test_ranges() {
         let ps = SyntaxSet::load_from_folder("testdata/Packages").unwrap();
         let mut state = {
@@ -569,5 +569,5 @@ mod tests {
                        font_style: FontStyle::empty(),
                    },
                     "5", Range { start: 30, end: 31 }));
-    }
+    }*/
 }
Index: syntect/src/html.rs
===================================================================
--- syntect.orig/src/html.rs
+++ syntect/src/html.rs
@@ -531,7 +531,7 @@ mod tests {
     use crate::highlighting::{HighlightIterator, HighlightState, Highlighter, Style, ThemeSet};
     use crate::parsing::{ParseState, ScopeStack, SyntaxDefinition, SyntaxSet, SyntaxSetBuilder};
     use crate::util::LinesWithEndings;
-    #[test]
+    /*#[test]
     fn tokens() {
         let ss = SyntaxSet::load_defaults_newlines();
         let syntax = ss.find_syntax_by_name("Markdown").unwrap();
@@ -556,9 +556,9 @@ mod tests {
         let html2 = styled_line_to_highlighted_html(&regions[..], IncludeBackground::Yes).expect("#[cfg(test)]");
         println!("{}", html2);
         assert_eq!(html2, include_str!("../testdata/test1.html").trim_end());
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn strings() {
         let ss = SyntaxSet::load_defaults_newlines();
         let ts = ThemeSet::load_defaults();
@@ -584,9 +584,9 @@ mod tests {
         .unwrap();
         println!("{}", html3);
         assert_eq!(html3, include_str!("../testdata/test4.html"));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn tricky_test_syntax() {
         // This syntax I wrote tests edge cases of prototypes
         // I verified the output HTML against what ST3 does with the same syntax and file
@@ -602,9 +602,9 @@ mod tests {
         .unwrap();
         println!("{}", html);
         assert_eq!(html, include_str!("../testdata/test5.html"));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_classed_html_generator_doesnt_panic() {
         let current_code = "{\n    \"headers\": [\"Number\", \"Title\"],\n    \"records\": [\n        [\"1\", \"Gutenberg\"],\n        [\"2\", \"Printing\"]\n    ],\n}\n";
         let syntax_def = SyntaxDefinition::load_from_str(
@@ -624,7 +624,7 @@ mod tests {
             html_generator.parse_html_for_line_which_includes_newline(line).expect("#[cfg(test)]");
         }
         html_generator.finalize();
-    }
+    }*/
 
     #[test]
     fn test_classed_html_generator() {
Index: syntect/src/parsing/metadata.rs
===================================================================
--- syntect.orig/src/parsing/metadata.rs
+++ syntect/src/parsing/metadata.rs
@@ -414,7 +414,7 @@ mod tests {
     use super::*;
     use crate::parsing::SyntaxSet;
 
-    #[test]
+    /*#[test]
     fn load_raw() {
         let comments_file: &str = "testdata/Packages/Go/Comments.tmPreferences";
         assert!(Path::new(comments_file).exists());
@@ -493,5 +493,5 @@ mod tests {
         assert!(!indent_ctx.decrease_indent("struct This {}"));
         assert!(!indent_ctx.increase_indent("struct This {}"));
 
-    }
+    }*/
 }
Index: syntect/src/parsing/parser.rs
===================================================================
--- syntect.orig/src/parsing/parser.rs
+++ syntect/src/parsing/parser.rs
@@ -700,9 +700,9 @@ mod tests {
     use crate::parsing::ScopeStackOp::{Push, Pop, Clear, Restore};
     use crate::util::debug_print_ops;
 
-    const TEST_SYNTAX: &str = include_str!("../../testdata/parser_tests.sublime-syntax");
+    //const TEST_SYNTAX: &str = include_str!("../../testdata/parser_tests.sublime-syntax");
 
-    #[test]
+    /*#[test]
     fn can_parse_simple() {
         let ss = SyntaxSet::load_from_folder("testdata/Packages").unwrap();
         let mut state = {
@@ -736,7 +736,7 @@ mod tests {
             (7, Pop(1))
         ];
         assert_eq!(&ops2[0..test_ops2.len()], &test_ops2[..]);
-    }
+    }*/
 
     #[test]
     fn can_parse_yaml() {
@@ -884,7 +884,7 @@ mod tests {
         assert_eq!(ops(&mut state, "struct{estruct", &ss).len(), 10);
     }
 
-    #[test]
+    /*#[test]
     fn can_compare_parse_states() {
         let ss = SyntaxSet::load_from_folder("testdata/Packages").unwrap();
         let syntax = ss.find_syntax_by_name("Java").unwrap();
@@ -897,9 +897,9 @@ mod tests {
         assert_eq!(state1, state2);
         ops(&mut state1, "}", &ss);
         assert_ne!(state1, state2);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn can_parse_non_nested_clear_scopes() {
         let line = "'hello #simple_cleared_scopes_test world test \\n '";
         let expect = [
@@ -908,9 +908,9 @@ mod tests {
             "<source.test>, <string.quoted.single.example>, <constant.character.escape.example>",
         ];
         expect_scope_stacks(line, &expect, TEST_SYNTAX);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn can_parse_non_nested_too_many_clear_scopes() {
         let line = "'hello #too_many_cleared_scopes_test world test \\n '";
         let expect = [
@@ -919,9 +919,9 @@ mod tests {
             "<source.test>, <string.quoted.single.example>, <constant.character.escape.example>",
         ];
         expect_scope_stacks(line, &expect, TEST_SYNTAX);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn can_parse_nested_clear_scopes() {
         let line = "'hello #nested_clear_scopes_test world foo bar test \\n '";
         let expect = [
@@ -931,7 +931,7 @@ mod tests {
             "<source.test>, <string.quoted.single.example>, <constant.character.escape.example>",
         ];
         expect_scope_stacks(line, &expect, TEST_SYNTAX);
-    }
+    }*/
 
     #[test]
     fn can_parse_infinite_loop() {
@@ -1002,7 +1002,7 @@ contexts:
         expect_scope_stacks(line, &expect, syntax);
     }
 
-    #[test]
+    /*#[test]
     fn can_parse_issue120() {
         let syntax = SyntaxDefinition::load_from_str(
             include_str!("../../testdata/embed_escape_test.sublime-syntax"),
@@ -1028,7 +1028,7 @@ contexts:
             "<top-level.test>",
         ];
         expect_scope_stacks_with_syntax(line2, &expect2, syntax);
-    }
+    }*/
 
     #[test]
     fn can_parse_non_consuming_pop_that_would_loop() {
Index: syntect/src/parsing/syntax_set.rs
===================================================================
--- syntect.orig/src/parsing/syntax_set.rs
+++ syntect/src/parsing/syntax_set.rs
@@ -236,7 +236,7 @@ impl SyntaxSet {
     /// When determining how to highlight a file, use this in combination with a fallback to plain
     /// text:
     ///
-    /// ```
+    /// ```ignore
     /// use syntect::parsing::SyntaxSet;
     /// let ss = SyntaxSet::load_defaults_newlines();
     /// let syntax = ss.find_syntax_for_file("testdata/highlight_test.erb")
@@ -866,7 +866,7 @@ mod tests {
     use crate::parsing::{ParseState, Scope, syntax_definition};
     use std::collections::HashMap;
 
-    #[test]
+    /*#[test]
     fn can_load() {
         let mut builder = SyntaxSetBuilder::new();
         builder.add_from_folder("testdata/Packages", false).unwrap();
@@ -919,7 +919,7 @@ mod tests {
         let main_context = ps.get_context(&syntax.context_ids()["main"]).expect("#[cfg(test)]");
         let count = syntax_definition::context_iter(&ps, main_context).count();
         assert_eq!(count, 109);
-    }
+    }*/
 
     #[test]
     fn can_clone() {
Index: syntect/src/highlighting/theme_set.rs
===================================================================
--- syntect.orig/src/highlighting/theme_set.rs
+++ syntect/src/highlighting/theme_set.rs
@@ -73,7 +73,7 @@ impl ThemeSet {
 #[cfg(test)]
 mod tests {
     use crate::highlighting::{ThemeSet, Color};
-    #[cfg(feature = "plist-load")]
+    /*#[cfg(feature = "plist-load")]
     #[test]
     fn can_parse_common_themes() {
         let themes = ThemeSet::load_from_folder("testdata").unwrap();
@@ -99,5 +99,5 @@ mod tests {
                        a: 0xFF,
                    });
         // unreachable!();
-    }
+    }*/
 }
