Index: rustc-serialize/src/json.rs
===================================================================
--- rustc-serialize.orig/src/json.rs
+++ rustc-serialize/src/json.rs
@@ -2587,7 +2587,7 @@ impl FromStr for Json {
 
 #[cfg(test)]
 mod tests {
-    use self::Animal::*;
+    //use self::Animal::*;
     use {Encodable, Decodable};
     use super::Json::*;
     use super::ErrorCode::*;
@@ -2601,7 +2601,7 @@ mod tests {
     use std::collections::BTreeMap;
     use std::string;
 
-    #[derive(RustcDecodable, Eq, PartialEq, Debug)]
+    /*#[derive(RustcDecodable, Eq, PartialEq, Debug)]
     struct OptionData {
         opt: Option<usize>,
     }
@@ -2656,7 +2656,7 @@ mod tests {
         };
 
         Object(d)
-    }
+    }*/
 
     #[test]
     fn test_from_str_trait() {
@@ -2762,7 +2762,7 @@ mod tests {
         );
     }
 
-    #[test]
+    /* #[test]
     fn test_write_object() {
         assert_eq!(mk_object(&[]).to_string(), "{}");
         assert_eq!(mk_object(&[]).pretty().to_string(), "{}");
@@ -2824,9 +2824,9 @@ mod tests {
         // printed in a different order.
         assert_eq!(a.clone(), a.to_string().parse().unwrap());
         assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());
-    }
+    } */
 
-    #[test]
+    /*#[test]
     fn test_write_enum() {
         let animal = Dog;
         assert_eq!(
@@ -2853,7 +2853,7 @@ mod tests {
                ]\n\
              }"
         );
-    }
+    }*/
 
     macro_rules! check_encoder_for_simple {
         ($value:expr, $expected:expr) => ({
@@ -3106,7 +3106,7 @@ mod tests {
         assert!(super::decode::<(usize, usize)>("[1, 2, 3]").is_err());
     }
 
-    #[test]
+    /* #[test]
     fn test_read_object() {
         assert_eq!(Json::from_str("{"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));
         assert_eq!(Json::from_str("{ "),      Err(SyntaxError(EOFWhileParsingObject, 1, 3)));
@@ -3159,9 +3159,9 @@ mod tests {
                           ])
                       ]))
                   ]));
-    }
+    } */
 
-    #[test]
+    /*#[test]
     fn test_decode_struct() {
         let s = "{
             \"inner\": [
@@ -3178,9 +3178,9 @@ mod tests {
                 ]
             }
         );
-    }
+    }*/
 
-    #[derive(RustcDecodable)]
+    /*#[derive(RustcDecodable)]
     struct FloatStruct {
         f: f64,
         a: Vec<f64>
@@ -3192,7 +3192,7 @@ mod tests {
         assert!(obj.f.is_nan());
         assert!(obj.a[0].is_nan());
         assert_eq!(obj.a[1], 123f64);
-    }
+    }*/
 
     #[test]
     fn test_decode_option() {
@@ -3203,7 +3203,7 @@ mod tests {
         assert_eq!(value, Some("jodhpurs".to_string()));
     }
 
-    #[test]
+    /*#[test]
     fn test_decode_enum() {
         let value: Animal = super::decode("\"Dog\"").unwrap();
         assert_eq!(value, Dog);
@@ -3211,7 +3211,7 @@ mod tests {
         let s = "{\"variant\":\"Frog\",\"fields\":[\"Henry\",349]}";
         let value: Animal = super::decode(s).unwrap();
         assert_eq!(value, Frog("Henry".to_string(), 349));
-    }
+    }*/
 
     #[test]
     fn test_decode_result() {
@@ -3222,7 +3222,7 @@ mod tests {
         assert_eq!(decoded_value, Ok(4));
     }
 
-    #[test]
+    /*#[test]
     fn test_decode_map() {
         let s = "{\"a\": \"Dog\", \"b\": {\"variant\":\"Frog\",\
                   \"fields\":[\"Henry\", 349]}}";
@@ -3230,7 +3230,7 @@ mod tests {
 
         assert_eq!(map.remove(&"a".to_string()), Some(Dog));
         assert_eq!(map.remove(&"b".to_string()), Some(Frog("Henry".to_string(), 349)));
-    }
+    }*/
 
     #[test]
     fn test_multiline_errors() {
@@ -3238,7 +3238,7 @@ mod tests {
             Err(SyntaxError(EOFWhileParsingObject, 3, 8)));
     }
 
-    #[derive(RustcDecodable)]
+    /*#[derive(RustcDecodable)]
     #[allow(dead_code)]
     struct DecodeStruct {
         x: f64,
@@ -3292,7 +3292,7 @@ mod tests {
                                 ExpectedError("Array".to_string(), "null".to_string()));
         check_err::<DecodeEnum>("{\"variant\": \"C\", \"fields\": []}",
                                 UnknownVariantError("C".to_string()));
-    }
+    }*/
 
     #[test]
     fn test_find(){
@@ -3537,7 +3537,7 @@ mod tests {
         }
     }
 
-    #[test]
+    /* #[test]
     fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {
         use std::collections::HashMap;
         use Decodable;
@@ -3548,9 +3548,9 @@ mod tests {
         };
         let mut decoder = Decoder::new(json_obj);
         let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();
-    }
+    } */
 
-    #[test]
+    /* #[test]
     fn test_hashmap_with_enum_key() {
         use std::collections::HashMap;
         use json;
@@ -3566,7 +3566,7 @@ mod tests {
         assert_eq!(result, r#"{"Foo":0}"#);
         let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();
         assert_eq!(map, decoded);
-    }
+    }*/
 
     #[test]
     fn test_hashmap_with_numeric_key_will_error_with_string_keys() {
@@ -3926,7 +3926,7 @@ mod tests {
         assert_eq!(None::<isize>.to_json(), Null);
     }
 
-    #[test]
+    /* #[test]
     fn test_encode_hashmap_with_arbitrary_key() {
         use std::collections::HashMap;
         #[derive(PartialEq, Eq, Hash, RustcEncodable)]
@@ -3940,9 +3940,9 @@ mod tests {
             EncoderError::BadHashmapKey => (),
             _ => panic!("expected bad hash map key")
         }
-    }
+    } */
 
-    #[test]
+    /* #[test]
     fn test_encode_decode_phantom_data() {
         use std::marker::PhantomData;
 
@@ -3957,9 +3957,9 @@ mod tests {
         let s = super::encode(&f).unwrap();
         let d: Foo<u8> = super::decode(&s).unwrap();
         assert_eq!(f, d);
-    }
+    } */
 
-    #[test]
+    /* #[test]
     fn test_bad_json_stack_depleted() {
         use json;
         #[derive(Debug, RustcDecodable)]
@@ -3969,9 +3969,9 @@ mod tests {
         let serialized = "{\"variant\": \"Variant\", \"fields\": []}";
         let r: Result<ChatEvent, _> = json::decode(serialized);
         assert!(r.unwrap_err() == EOF);
-    }
+    } */
 
-    #[test]
+    /* #[test]
     fn fixed_length_array() {
         #[derive(Debug, RustcDecodable, RustcEncodable, Eq, PartialEq)]
         struct Foo {
@@ -3987,7 +3987,7 @@ mod tests {
         let s = super::encode(&f).unwrap();
         let d = super::decode(&s).unwrap();
         assert_eq!(f, d);
-    }
+    } */
 
     #[test]
     fn test_unexpected_token() {
