diff --git a/src/parser.rs b/src/parser.rs
index 61e6d1d..0f314d2 100644
--- a/src/parser.rs
+++ b/src/parser.rs
@@ -519,6 +519,7 @@ impl Parser {
     /// incrementally parsing it.
     ///
     /// ```
+    /// #[cfg(feature = "std")] {
     /// use std::io::Read;
     /// use anyhow::Result;
     /// use wasmparser::{Parser, Chunk, Payload::*};
@@ -619,6 +620,7 @@ impl Parser {
     /// }
     ///
     /// # parse(&b"\0asm\x01\0\0\0"[..]).unwrap();
+    /// }
     /// ```
     pub fn parse<'a>(&mut self, data: &'a [u8], eof: bool) -> Result<Chunk<'a>> {
         let (data, eof) = if usize_to_u64(data.len()) > self.max_size {
@@ -1011,6 +1013,7 @@ impl Parser {
     /// a buffer and then parsing it.
     ///
     /// ```
+    /// #[cfg(feature = "std")]	{
     /// use std::io::Read;
     /// use anyhow::Result;
     /// use wasmparser::{Parser, Chunk, Payload::*};
@@ -1082,6 +1085,7 @@ impl Parser {
     /// }
     ///
     /// # parse(&b"\0asm\x01\0\0\0"[..]).unwrap();
+    /// }
     /// ```
     pub fn parse_all(self, mut data: &[u8]) -> impl Iterator<Item = Result<Payload<'_>>> {
         let mut stack = Vec::new();
@@ -1839,6 +1843,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "std")]
     fn single_module() {
         let mut p = parser_after_component_header();
         assert_matches!(p.parse(&[4], false), Ok(Chunk::NeedMoreData(1)));
@@ -1891,6 +1896,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "std")]
     fn nested_section_too_big() {
         let mut p = parser_after_component_header();
 
diff --git a/tests/big-module.rs b/tests/big-module.rs
index 9064eba..553802d 100644
--- a/tests/big-module.rs
+++ b/tests/big-module.rs
@@ -2,6 +2,7 @@ use std::borrow::Cow;
 use wasm_encoder::*;
 
 #[test]
+#[cfg(feature = "std")]
 fn big_type_indices() {
     const N: u32 = 100_000;
     let mut module = Module::new();
