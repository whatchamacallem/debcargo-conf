From f253f02a6658b3b7612a50d56c71f5ae4da4ca21 Mon Sep 17 00:00:00 2001
From: Emily <hello@emily.moe>
Date: Tue, 1 Apr 2025 21:55:16 +0100
Subject: [PATCH] =?UTF-8?q?feat!:=20detect=20SHA=E2=80=901=20collision=20a?=
 =?UTF-8?q?ttacks?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Fix [GHSA-2frx-2596-x5r6].

[GHSA-2frx-2596-x5r6]: https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-2frx-2596-x5r6

This uses the `sha1-checked` crate from the RustCrypto project. It’s
a pure Rust implementation, with no SIMD or assembly code.

The hashing implementation moves to `gix-hash`, as it no longer
depends on any feature configuration. I wasn’t sure the ideal
crate to put this in, but after checking reverse dependencies on
crates.io, it seems like there’s essentially no user of `gix-hash`
that wouldn’t be pulling in a hashing implementation anyway, so I
think this is a fine and logical place for it to be.

A fallible API seems better than killing the process as Git does,
since we’re in a library context and it would be bad if you could
perform denial‐of‐service attacks on a server by sending it hash
collisions. (Although there are probably cheaper ways to mount a
denial‐of‐service attack.)

The new API also returns an `ObjectId` rather than `[u8; 20]`; the
vast majority of `Hasher::digest()` users immediately convert the
result to `ObjectId`, so this will help eliminate a lot of cruft
across the tree. `ObjectId` also has nicer `Debug` and `Display`
instances than `[u8; 20]`, and should theoretically make supporting
the hash function transition easier, although I suspect further API
changes will be required for that anyway. I wasn’t sure whether
this would be a good change, as not every digest identifies an
entry in the Git object database, but even many of the existing
uses for non‐object digests across the tree used the `ObjectId`
API anyway. Perhaps it would be best to have a separate non‐alias
`Digest` type that `ObjectId` wraps, but this seems like the pragmatic
choice for now that sticks with current practice.

The old API remains in this commit, as well as a temporary
non‐fallible but `ObjectId`‐returning `Hasher::finalize()`,
pending the migration of all in‐tree callers.

I named the module `gix_hash::hasher` since `gix_hash::hash` seemed
like it would be confusing. This does mean that there is a function
and module with the same name, which is permitted but perhaps a
little strange.

Everything is re‐exported directly other than
`gix_features::hash::Write`, which moves along with the I/O
convenience functions into a new public submodule and becomes
`gix_hash::hasher::io::Write`, as that seems like a clearer name
to me, being akin to the `gix_hash::hasher` function but as an
`std::io::Write` wrapper.

Raw hashing is somewhere around 0.25× to 0.65× the speed of the
previous implementation, depending on the feature configuration
and whether the CPU supports hardware‐accelerated hashing. (The
more portable assembly in `sha1-asm` that doesn’t require the SHA
instruction set doesn’t seem to speed things up that much; in fact,
`sha1_smol` somehow regularly beats the assembly code used by `sha1`
on my i9‐9880H MacBook Pro! Presumably this is why that path was
removed in newer versions of the `sha1` crate.)

Performance on an end‐to‐end `gix no-repo pack verify` benchmark
using pack files from the Linux kernel Git server measures around
0.41× to 0.44× compared to the base commit on an M2 Max and a
Ryzen 7 5800X, both of which have hardware instructions for SHA‐1
acceleration that the previous implementation uses but this one does
not. On the i9‐9880H, it’s around 0.58× to 0.60× the speed;
the slowdown is reduced by the older hardware’s lack of SHA‐1
instructions.

The `sha1collisiondetection` crate from the Sequoia PGP project,
based on a modified C2Rust translation of the library used by Git,
was also considered; although its raw hashing performance seems
to measure around 1.12–1.15× the speed of `sha1-checked` on
x86, it’s indistinguishable from noise on the end‐to‐end
benchmark, and on an M2 Max `sha1-checked` is consistently
around 1.03× the speed of `sha1collisiondetection` on that
benchmark. The `sha1collisiondetection` crate has also had a
soundness issue in the past due to the automatic C translation,
whereas `sha1-checked` has only one trivial `unsafe` block. On the
other hand, `sha1collisiondetection` is used by both Sequoia itself
and the `gitoid` crate, whereas rPGP is the only major user of
`sha1-checked`. I don’t think there’s a clear winner here.

The performance regression is very unfortunate, but the [SHAttered]
attack demonstrated a collision back in 2017, and the 2020 [SHA‐1 is
a Shambles] attack demonstrated a practical chosen‐prefix collision
that broke the use of SHA‐1 in OpenPGP, costing $75k to perform,
with an estimate of $45k to replicate at the time of publication and
$11k for a classical collision.

[SHAttered]: https://shattered.io/
[SHA‐1 is a Shambles]: https://sha-mbles.github.io/

Given the increase in GPU performance and production since then,
that puts the Git object format squarely at risk. Git mitigated this
attack in 2017; the algorithm is fairly general and detects all the
existing public collisions. My understanding is that an entirely new
cryptanalytic approach would be required to develop a collision attack
for SHA‐1 that would not be detected with very high probability.

I believe that the speed penalty could be mitigated, although not
fully eliminated, by implementing a version of the hardened SHA‐1
function that makes use of SIMD. For instance, the assembly code used
by `openssl speed sha1` on my i9‐9880H measures around 830 MiB/s,
compared to the winning 580 MiB/s of `sha1_smol`; adding collision
detection support to that would surely incur a performance penalty,
but it is likely that it could be much more competitive with
the performance before this commit than the 310 MiB/s I get with
`sha1-checked`. I haven’t been able to find any existing work on
this; it seems that more or less everyone just uses the original
C library that Git does, presumably because nothing except Git and
OpenPGP is still relying on SHA‐1 anyway…

The performance will never compete with the >2 GiB/s that can
be achieved with the x86 SHA instruction set extension, as the
`SHA1RNDS4` instruction sadly runs four rounds at a time while the
collision detection algorithm requires checks after every round,
but I believe SIMD would still offer a significant improvement,
and the AArch64 extension seems like it may be more flexible.

I know that these days the Git codebase has an additional faster
unsafe API without these checks that it tries to carefully use only
for operations that do not depend on hashing results for correctness
or safety. I personally believe that’s not a terribly good idea,
as it seems easy to misuse in a case where correctness actually does
matter, but maybe that’s just my Rust safety bias talking. I think
it would be better to focus on improving the performance of the safer
algorithm, as I think that many of the operations where the performance
penalty is the most painful are dealing with untrusted input anyway.

The `Hasher` struct gets a lot bigger; I don’t know if this is
an issue or not, but if it is, it could potentially be boxed.

Closes: #585

FG: removed non-gix-hash parts, adapted context/paths where necessary
fold in fd12ef89af29bf0684fc1df3e7b76ff367dee994
Signed-off-by: Fabian Grünbichler <git@fabian.gruenbichler.email>
---
 Cargo.toml             |   6 ++
 src/hasher/io.rs       | 138 ++++++++++++++++++++++++
 src/hasher/mod.rs      |  90 ++++++++++++++++
 src/lib.rs             |   5 +
 13 files changed, 292 insertions(+), 242 deletions(-)
 create mode 100644 src/hasher/io.rs
 create mode 100644 src/hasher/mod.rs

--- a/Cargo.toml
+++ b/Cargo.toml
@@ -46,18 +46,26 @@
 [dependencies.faster-hex]
 version = "0.9.0"
 
+[dependencies.prodash]
+version = "28"
+
 [dependencies.serde]
 version = "1.0.114"
 features = ["derive"]
 optional = true
 default-features = false
 
+[dependencies.sha1-checked]
+version = "0.10.0"
+default-features = false
+
 [dependencies.thiserror]
 version = "2.0.0"
 
 [dev-dependencies]
 
 [features]
+progress-unit-bytes = ["prodash/unit-bytes"]
 serde = ["dep:serde"]
 
 [lints.clippy]
--- /dev/null
+++ b/src/hasher/io.rs
@@ -0,0 +1,138 @@
+use crate::{hasher, Hasher};
+
+// Temporary, to avoid a circular dependency on `gix-features`.
+///
+mod gix_features {
+    ///
+    pub mod progress {
+        pub use prodash::{self, unit, Progress, Unit};
+
+        ///
+        #[cfg(feature = "progress-unit-bytes")]
+        pub fn bytes() -> Option<Unit> {
+            Some(unit::dynamic_and_mode(
+                unit::Bytes,
+                unit::display::Mode::with_throughput().and_percentage(),
+            ))
+        }
+
+        ///
+        #[cfg(not(feature = "progress-unit-bytes"))]
+        pub fn bytes() -> Option<Unit> {
+            Some(unit::label_and_mode(
+                "B",
+                unit::display::Mode::with_throughput().and_percentage(),
+            ))
+        }
+    }
+}
+
+/// Compute the hash of `kind` for the bytes in the file at `path`, hashing only the first `num_bytes_from_start`
+/// while initializing and calling `progress`.
+///
+/// `num_bytes_from_start` is useful to avoid reading trailing hashes, which are never part of the hash itself,
+/// denoting the amount of bytes to hash starting from the beginning of the file.
+///
+/// # Note
+///
+/// * Interrupts are supported.
+// TODO: Fix link to `gix_features::interrupt`.
+pub fn bytes_of_file(
+    path: &std::path::Path,
+    num_bytes_from_start: u64,
+    kind: crate::Kind,
+    progress: &mut dyn gix_features::progress::Progress,
+    should_interrupt: &std::sync::atomic::AtomicBool,
+) -> std::io::Result<crate::ObjectId> {
+    bytes(
+        &mut std::fs::File::open(path)?,
+        num_bytes_from_start,
+        kind,
+        progress,
+        should_interrupt,
+    )
+}
+
+/// Similar to [`bytes_of_file`], but operates on a stream of bytes.
+pub fn bytes(
+    read: &mut dyn std::io::Read,
+    num_bytes_from_start: u64,
+    kind: crate::Kind,
+    progress: &mut dyn gix_features::progress::Progress,
+    should_interrupt: &std::sync::atomic::AtomicBool,
+) -> std::io::Result<crate::ObjectId> {
+    bytes_with_hasher(read, num_bytes_from_start, hasher(kind), progress, should_interrupt)
+}
+
+/// Similar to [`bytes()`], but takes a `hasher` instead of a hash kind.
+pub fn bytes_with_hasher(
+    read: &mut dyn std::io::Read,
+    num_bytes_from_start: u64,
+    mut hasher: Hasher,
+    progress: &mut dyn gix_features::progress::Progress,
+    should_interrupt: &std::sync::atomic::AtomicBool,
+) -> std::io::Result<crate::ObjectId> {
+    let start = std::time::Instant::now();
+    // init progress before the possibility for failure, as convenience in case people want to recover
+    progress.init(
+        Some(num_bytes_from_start as gix_features::progress::prodash::progress::Step),
+        gix_features::progress::bytes(),
+    );
+
+    const BUF_SIZE: usize = u16::MAX as usize;
+    let mut buf = [0u8; BUF_SIZE];
+    let mut bytes_left = num_bytes_from_start;
+
+    while bytes_left > 0 {
+        let out = &mut buf[..BUF_SIZE.min(bytes_left as usize)];
+        read.read_exact(out)?;
+        bytes_left -= out.len() as u64;
+        progress.inc_by(out.len());
+        hasher.update(out);
+        if should_interrupt.load(std::sync::atomic::Ordering::SeqCst) {
+            return Err(std::io::Error::new(std::io::ErrorKind::Other, "Interrupted"));
+        }
+    }
+
+    let id = crate::ObjectId::from(hasher.digest());
+    progress.show_throughput(start);
+    Ok(id)
+}
+
+/// A utility to automatically generate a hash while writing into an inner writer.
+pub struct Write<T> {
+    /// The hash implementation.
+    pub hash: Hasher,
+    /// The inner writer.
+    pub inner: T,
+}
+
+impl<T> std::io::Write for Write<T>
+where
+    T: std::io::Write,
+{
+    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
+        let written = self.inner.write(buf)?;
+        self.hash.update(&buf[..written]);
+        Ok(written)
+    }
+
+    fn flush(&mut self) -> std::io::Result<()> {
+        self.inner.flush()
+    }
+}
+
+impl<T> Write<T>
+where
+    T: std::io::Write,
+{
+    /// Create a new hash writer which hashes all bytes written to `inner` with a hash of `kind`.
+    pub fn new(inner: T, object_hash: crate::Kind) -> Self {
+        match object_hash {
+            crate::Kind::Sha1 => Write {
+                inner,
+                hash: Hasher::default(),
+            },
+        }
+    }
+}
--- /dev/null
+++ b/src/hasher/mod.rs
@@ -0,0 +1,90 @@
+use sha1_checked::CollisionResult;
+
+/// A hash-digest produced by a [`Hasher`] hash implementation.
+pub type Digest = [u8; 20];
+
+/// The error returned by [`Hasher::try_finalize()`].
+#[derive(Debug, thiserror::Error)]
+#[allow(missing_docs)]
+pub enum Error {
+    #[error("Detected SHA-1 collision attack with digest {digest}")]
+    CollisionAttack { digest: crate::ObjectId },
+}
+
+/// A implementation of the Sha1 hash, which can be used once.
+///
+/// We use [`sha1_checked`] to implement the same collision detection
+/// algorithm as Git.
+#[derive(Clone)]
+pub struct Hasher(sha1_checked::Sha1);
+
+impl Default for Hasher {
+    #[inline]
+    fn default() -> Self {
+        // This matches the configuration used by Git, which only uses
+        // the collision detection to bail out, rather than computing
+        // alternate “safe hashes” for inputs where a collision attack
+        // was detected.
+        Self(sha1_checked::Builder::default().safe_hash(false).build())
+    }
+}
+
+impl Hasher {
+    /// Digest the given `bytes`.
+    pub fn update(&mut self, bytes: &[u8]) {
+        use sha1_checked::Digest;
+        self.0.update(bytes);
+    }
+
+    /// Finalize the hash and produce an object ID.
+    ///
+    /// Returns [`Error`] if a collision attack is detected.
+    #[inline]
+    pub fn try_finalize(self) -> Result<crate::ObjectId, Error> {
+        match self.0.try_finalize() {
+            CollisionResult::Ok(digest) => Ok(crate::ObjectId::Sha1(digest.into())),
+            CollisionResult::Mitigated(_) => {
+                // SAFETY: `CollisionResult::Mitigated` is only
+                // returned when `safe_hash()` is on. `Hasher`’s field
+                // is private, and we only construct it in the
+                // `Default` instance, which turns `safe_hash()` off.
+                //
+                // As of Rust 1.84.1, the compiler can’t figure out
+                // this function cannot panic without this.
+                #[allow(unsafe_code)]
+                unsafe {
+                    std::hint::unreachable_unchecked()
+                }
+            }
+            CollisionResult::Collision(digest) => Err(Error::CollisionAttack {
+                digest: crate::ObjectId::Sha1(digest.into()),
+            }),
+        }
+    }
+
+    /// Finalize the hash and produce an object ID.
+    #[inline]
+    pub fn finalize(self) -> crate::ObjectId {
+        self.try_finalize().expect("Detected SHA-1 collision attack")
+    }
+
+    /// Finalize the hash and produce a digest.
+    #[inline]
+    pub fn digest(self) -> Digest {
+        self.finalize()
+            .as_slice()
+            .try_into()
+            .expect("SHA-1 object ID to be 20 bytes long")
+    }
+}
+
+/// Produce a hasher suitable for the given kind of hash.
+#[inline]
+pub fn hasher(kind: crate::Kind) -> Hasher {
+    match kind {
+        crate::Kind::Sha1 => Hasher::default(),
+    }
+}
+
+/// Hashing utilities for I/O operations.
+pub mod io;
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -13,6 +13,11 @@
 mod borrowed;
 pub use borrowed::{oid, Error};
 
+/// Hash functions and hash utilities
+pub mod hasher;
+pub use hasher::io::{bytes, bytes_of_file, bytes_with_hasher};
+pub use hasher::{hasher, Hasher};
+
 mod object_id;
 pub use object_id::{decode, ObjectId};
 
