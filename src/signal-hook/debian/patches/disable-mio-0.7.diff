This patch is essentially a revert of upstream commit 2c89272faf3f868ad8ab00753b338a6e6ff04793
adapted slightly for the Debian package.

diff --git a/Cargo.lock b/Cargo.lock
index 57f0466c3..85cfa65de 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -439,7 +439,6 @@ version = "0.1.13"
 dependencies = [
  "futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.62 (registry+https://github.com/rust-lang/crates.io-index)",
- "mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)",
  "mio 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "signal-hook-registry 1.2.0",
  "tokio 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)",
diff --git a/Cargo.toml b/Cargo.toml
index 56babca0c..3aee6fa03 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,8 +15,7 @@ maintenance = { status = "actively-developed" }
 
 [features]
 mio-support = ["mio"]
-mio-0_7-support = ["mio_0_7"]
-tokio-support = ["futures", "mio-support", "mio-0_7-support", "tokio-reactor"]
+tokio-support = ["futures", "mio-support", "tokio-reactor"]
 
 [workspace]
 members = [
@@ -27,13 +26,12 @@ members = [
 [dependencies]
 libc = "~0.2"
 futures = { version = "~0.1", optional = true }
-mio_0_7 = { package = "mio", version = "~0.7", features = ["os-util"], optional = true }
-mio = { version = "~0.6", optional = true }
+mio = { version = "~0.7", features = ["os-util"], optional = true }
 signal-hook-registry = { version = "~1.2", path = "signal-hook-registry" }
 tokio-reactor = { version = "~0.1", optional = true }
 
 [dev-dependencies]
-mio_0_7 = { package ="mio", version = "~0.7", features = ["os-poll", "os-util"] }
+mio = { version = "~0.7", features = ["os-poll", "os-util"] }
 version-sync = "~0.8"
 tokio = "~0.1"
 
diff --git a/src/iterator.rs b/src/iterator.rs
index bb743e9fe..261561351 100644
--- a/src/iterator.rs
+++ b/src/iterator.rs
@@ -138,10 +138,9 @@ impl Drop for RegisteredSignals {
 ///
 /// # `mio` support
 ///
-/// If the crate is compiled with the `mio-support` or `mio-0_7-support` flags, the `Signals`
-/// becomes pluggable into `mio` (it implements the `Source` trait). If it becomes readable, there
-/// may be new signals to pick up. The structure is expected to be registered with level triggered
-/// mode.
+/// If the crate is compiled with the `mio-support` flag, the `Signals` becomes pluggable into
+/// `mio` (it implements the `Source` trait). If it becomes readable, there may be new signals to
+/// pick up. The structure is expected to be registered with level triggered mode.
 ///
 /// # `tokio` support
 ///
@@ -430,82 +429,16 @@ impl<'a> Iterator for Forever<'a> {
 
         None
     }
-
-}
-#[cfg(feature = "mio-support")]
-mod mio_support {
-    use std::io::Error;
-    use std::os::unix::io::AsRawFd;
-
-    use mio::event::Evented;
-    use mio::unix::EventedFd;
-    use mio::{Poll, PollOpt, Ready, Token};
-
-    use super::Signals;
-
-    impl Evented for Signals {
-        fn register(
-            &self,
-            poll: &Poll,
-            token: Token,
-            interest: Ready,
-            opts: PollOpt,
-        ) -> Result<(), Error> {
-            EventedFd(&self.waker.read.as_raw_fd()).register(poll, token, interest, opts)
-        }
-
-        fn reregister(
-            &self,
-            poll: &Poll,
-            token: Token,
-            interest: Ready,
-            opts: PollOpt,
-        ) -> Result<(), Error> {
-            EventedFd(&self.waker.read.as_raw_fd()).reregister(poll, token, interest, opts)
-        }
-
-        fn deregister(&self, poll: &Poll) -> Result<(), Error> {
-            EventedFd(&self.waker.read.as_raw_fd()).deregister(poll)
-        }
-    }
-
-    #[cfg(test)]
-    mod tests {
-        use std::time::Duration;
-
-        use libc;
-        use mio::Events;
-
-        use super::*;
-
-        #[test]
-        fn mio_wakeup() {
-            let signals = Signals::new(&[::SIGUSR1]).unwrap();
-            let token = Token(0);
-            let poll = Poll::new().unwrap();
-            poll.register(&signals, token, Ready::readable(), PollOpt::level())
-                .unwrap();
-            let mut events = Events::with_capacity(10);
-            unsafe { libc::raise(::SIGUSR1) };
-            poll.poll(&mut events, Some(Duration::from_secs(10)))
-                .unwrap();
-            let event = events.iter().next().unwrap();
-            assert!(event.readiness().is_readable());
-            assert_eq!(token, event.token());
-            let sig = signals.pending().next().unwrap();
-            assert_eq!(::SIGUSR1, sig);
-        }
-    }
 }
 
-#[cfg(any(test, feature = "mio-0_7-support"))]
-mod mio_0_7_support {
+#[cfg(any(test, feature = "mio-support"))]
+mod mio_support {
     use std::io::Error;
     use std::os::unix::io::AsRawFd;
 
-    use mio_0_7::event::Source;
-    use mio_0_7::unix::SourceFd;
-    use mio_0_7::{Registry, Interest, Token};
+    use mio::event::Source;
+    use mio::unix::SourceFd;
+    use mio::{Registry, Interest, Token};
 
     use super::Signals;
 
@@ -538,7 +471,7 @@ mod mio_0_7_support {
         use std::time::Duration;
 
         use libc;
-        use mio_0_7::{Events, Poll};
+        use mio::{Events, Poll};
 
         use super::*;
 
diff --git a/src/lib.rs b/src/lib.rs
index 0231b771b..470e69af2 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -142,9 +142,7 @@
 //! # Features
 //!
 //! * `mio-support`: The [`Signals` iterator](iterator/struct.Signals.html) becomes pluggable into
-//!   mio 0.6.
-//! * `mio-0_7-support`: The [`Signals` iterator](iterator/struct.Signals.html) becomes pluggable into
-//!   mio 0.7.
+//!   mio.
 //! * `tokio-support`: The [`Signals`](iterator/struct.Signals.html) can be turned into
 //!   [`Async`](iterator/struct.Async.html), which provides a `Stream` interface for integration in
 //!   the asynchronous world.
@@ -152,10 +150,8 @@
 #[cfg(feature = "tokio-support")]
 extern crate futures;
 extern crate libc;
-#[cfg(feature = "mio-support")]
+#[cfg(any(test, feature = "mio-support"))]
 extern crate mio;
-#[cfg(any(test, feature= "mio-0_7-support"))]
-extern crate mio_0_7;
 extern crate signal_hook_registry;
 #[cfg(feature = "tokio-support")]
 extern crate tokio_reactor;
