From 3cd3e2a71beb01591afe732ab4ae914ed62a4ecf Mon Sep 17 00:00:00 2001
From: Ed Page <eopage@gmail.com>
Date: Fri, 31 Jan 2025 10:08:32 -0600
Subject: [PATCH] Resolve Winnow deprecations

---
 gix-actor/src/signature/decode.rs             | 42 +++++++++----------
 src/parse/nom/mod.rs               | 40 +++++++++---------
 src/parse/nom/tests.rs             | 17 ++++++--
 gix-object/src/commit/decode.rs               | 20 ++++-----
 gix-object/src/commit/message/body.rs         | 10 ++---
 gix-object/src/commit/message/decode.rs       |  8 ++--
 gix-object/src/parse.rs                       | 10 ++---
 gix-object/src/tag/decode.rs                  |  8 ++--
 gix-object/src/tag/ref_iter.rs                |  3 +-
 gix-object/src/tree/ref_iter.rs               |  9 ++--
 gix-protocol/src/remote_progress.rs           |  8 ++--
 gix-ref/src/parse.rs                          |  4 +-
 gix-ref/src/store/file/log/line.rs            |  8 ++--
 .../src/store/file/loose/reference/decode.rs  |  2 +-
 gix-ref/src/store/packed/decode.rs            |  6 +--
 gix-ref/src/store/packed/iter.rs              |  6 +--
 16 files changed, 100 insertions(+), 101 deletions(-)

--- a/src/parse/nom/mod.rs
+++ b/src/parse/nom/mod.rs
@@ -3,9 +3,9 @@
 use bstr::{BStr, ByteSlice};
 use winnow::{
     combinator::{alt, delimited, opt, preceded, repeat},
-    error::{ErrorKind, InputError as NomError, ParserError as _},
+    error::{ErrMode, InputError as NomError, ParserError as _},
     prelude::*,
-    stream::{Offset as _, Stream as _},
+    stream::Offset as _,
     token::{one_of, take_till, take_while},
 };
 
@@ -78,7 +78,7 @@
     start_input.next_slice(offset).iter().filter(|c| **c == b'\n').count()
 }
 
-fn comment<'i>(i: &mut &'i [u8]) -> PResult<Comment<'i>, NomError<&'i [u8]>> {
+fn comment<'i>(i: &mut &'i [u8]) -> ModalResult<Comment<'i>, NomError<&'i [u8]>> {
     (
         one_of([';', '#']),
         take_till(0.., |c| c == b'\n').map(|text: &[u8]| Cow::Borrowed(text.as_bstr())),
@@ -94,7 +94,7 @@
     i: &mut &'i [u8],
     node: &mut ParseNode,
     dispatch: &mut dyn FnMut(Event<'i>),
-) -> PResult<(), NomError<&'i [u8]>> {
+) -> ModalResult<(), NomError<&'i [u8]>> {
     let start = i.checkpoint();
     let header = section_header(i).map_err(|e| {
         i.reset(&start);
@@ -129,11 +129,14 @@
     Ok(())
 }
 
-fn section_header<'i>(i: &mut &'i [u8]) -> PResult<section::Header<'i>, NomError<&'i [u8]>> {
+fn section_header<'i>(i: &mut &'i [u8]) -> ModalResult<section::Header<'i>, NomError<&'i [u8]>> {
     // No spaces must be between section name and section start
     let name = preceded('[', take_while(1.., is_section_char).map(bstr::ByteSlice::as_bstr)).parse_next(i)?;
 
-    if opt(one_of::<_, _, NomError<&[u8]>>(']')).parse_next(i)?.is_some() {
+    if opt(one_of::<_, _, ErrMode<NomError<&[u8]>>>(']'))
+        .parse_next(i)?
+        .is_some()
+    {
         // Either section does not have a subsection or using deprecated
         // subsection syntax at this point.
         let header = match memchr::memrchr(b'.', name.as_bytes()) {
@@ -150,7 +153,7 @@
         };
 
         if header.name.is_empty() {
-            return Err(winnow::error::ErrMode::from_error_kind(i, ErrorKind::Fail));
+            return Err(winnow::error::ErrMode::from_input(i));
         }
         return Ok(header);
     }
@@ -169,7 +172,7 @@
     c.is_ascii_alphanumeric() || c == b'-' || c == b'.'
 }
 
-fn sub_section<'i>(i: &mut &'i [u8]) -> PResult<Cow<'i, BStr>, NomError<&'i [u8]>> {
+fn sub_section<'i>(i: &mut &'i [u8]) -> ModalResult<Cow<'i, BStr>, NomError<&'i [u8]>> {
     let mut output = Cow::Borrowed(Default::default());
     if let Some(sub) = opt(subsection_subset).parse_next(i)? {
         output = Cow::Borrowed(sub.as_bstr());
@@ -181,15 +184,15 @@
     Ok(output)
 }
 
-fn subsection_subset<'i>(i: &mut &'i [u8]) -> PResult<&'i [u8], NomError<&'i [u8]>> {
+fn subsection_subset<'i>(i: &mut &'i [u8]) -> ModalResult<&'i [u8], NomError<&'i [u8]>> {
     alt((subsection_unescaped, subsection_escaped_char)).parse_next(i)
 }
 
-fn subsection_unescaped<'i>(i: &mut &'i [u8]) -> PResult<&'i [u8], NomError<&'i [u8]>> {
+fn subsection_unescaped<'i>(i: &mut &'i [u8]) -> ModalResult<&'i [u8], NomError<&'i [u8]>> {
     take_while(1.., is_subsection_unescaped_char).parse_next(i)
 }
 
-fn subsection_escaped_char<'i>(i: &mut &'i [u8]) -> PResult<&'i [u8], NomError<&'i [u8]>> {
+fn subsection_escaped_char<'i>(i: &mut &'i [u8]) -> ModalResult<&'i [u8], NomError<&'i [u8]>> {
     preceded('\\', one_of(is_subsection_escapable_char).take()).parse_next(i)
 }
 
@@ -205,7 +208,7 @@
     i: &mut &'i [u8],
     node: &mut ParseNode,
     dispatch: &mut dyn FnMut(Event<'i>),
-) -> PResult<(), NomError<&'i [u8]>> {
+) -> ModalResult<(), NomError<&'i [u8]>> {
     *node = ParseNode::Name;
     if let Some(name) = opt(config_name).parse_next(i)? {
         dispatch(Event::SectionValueName(section::ValueName(Cow::Borrowed(name))));
@@ -223,7 +226,7 @@
 
 /// Parses the config name of a config pair. Assumes the input has already been
 /// trimmed of any leading whitespace.
-fn config_name<'i>(i: &mut &'i [u8]) -> PResult<&'i BStr, NomError<&'i [u8]>> {
+fn config_name<'i>(i: &mut &'i [u8]) -> ModalResult<&'i BStr, NomError<&'i [u8]>> {
     (
         one_of(|c: u8| c.is_ascii_alphabetic()),
         take_while(0.., |c: u8| c.is_ascii_alphanumeric() || c == b'-'),
@@ -233,7 +236,7 @@
         .parse_next(i)
 }
 
-fn config_value<'i>(i: &mut &'i [u8], dispatch: &mut dyn FnMut(Event<'i>)) -> PResult<(), NomError<&'i [u8]>> {
+fn config_value<'i>(i: &mut &'i [u8], dispatch: &mut dyn FnMut(Event<'i>)) -> ModalResult<(), NomError<&'i [u8]>> {
     if opt('=').parse_next(i)?.is_some() {
         dispatch(Event::KeyValueSeparator);
         if let Some(whitespace) = opt(take_spaces1).parse_next(i)? {
@@ -251,7 +254,7 @@
 
 /// Handles parsing of known-to-be values. This function handles both single
 /// line values as well as values that are continuations.
-fn value_impl<'i>(i: &mut &'i [u8], dispatch: &mut dyn FnMut(Event<'i>)) -> PResult<(), NomError<&'i [u8]>> {
+fn value_impl<'i>(i: &mut &'i [u8], dispatch: &mut dyn FnMut(Event<'i>)) -> ModalResult<(), NomError<&'i [u8]>> {
     let start_checkpoint = i.checkpoint();
     let mut value_start_checkpoint = i.checkpoint();
     let mut value_end = None;
@@ -278,17 +281,17 @@
                     let escape_index = escaped_index - 1;
                     let Some(mut c) = i.next_token() else {
                         i.reset(&start_checkpoint);
-                        return Err(winnow::error::ErrMode::from_error_kind(i, ErrorKind::Token));
+                        return Err(winnow::error::ErrMode::from_input(i));
                     };
                     let mut consumed = 1;
                     if c == b'\r' {
                         c = i.next_token().ok_or_else(|| {
                             i.reset(&start_checkpoint);
-                            winnow::error::ErrMode::from_error_kind(i, ErrorKind::Token)
+                            winnow::error::ErrMode::from_input(i)
                         })?;
                         if c != b'\n' {
                             i.reset(&start_checkpoint);
-                            return Err(winnow::error::ErrMode::from_error_kind(i, ErrorKind::Slice));
+                            return Err(winnow::error::ErrMode::from_input(i));
                         }
                         consumed += 1;
                     }
@@ -313,7 +316,7 @@
                         b'n' | b't' | b'\\' | b'b' | b'"' => {}
                         _ => {
                             i.reset(&start_checkpoint);
-                            return Err(winnow::error::ErrMode::from_error_kind(i, ErrorKind::Token));
+                            return Err(winnow::error::ErrMode::from_input(i));
                         }
                     }
                 }
@@ -326,7 +329,7 @@
     }
     if is_in_quotes {
         i.reset(&start_checkpoint);
-        return Err(winnow::error::ErrMode::from_error_kind(i, ErrorKind::Slice));
+        return Err(winnow::error::ErrMode::from_input(i));
     }
 
     let value_end = match value_end {
@@ -360,13 +363,13 @@
     Ok(())
 }
 
-fn take_spaces1<'i>(i: &mut &'i [u8]) -> PResult<&'i BStr, NomError<&'i [u8]>> {
+fn take_spaces1<'i>(i: &mut &'i [u8]) -> ModalResult<&'i BStr, NomError<&'i [u8]>> {
     take_while(1.., winnow::stream::AsChar::is_space)
         .map(bstr::ByteSlice::as_bstr)
         .parse_next(i)
 }
 
-fn take_newlines1<'i>(i: &mut &'i [u8]) -> PResult<&'i BStr, NomError<&'i [u8]>> {
+fn take_newlines1<'i>(i: &mut &'i [u8]) -> ModalResult<&'i BStr, NomError<&'i [u8]>> {
     repeat(1..1024, alt(("\r\n", "\n")))
         .map(|()| ())
         .take()
--- a/src/parse/nom/tests.rs
+++ b/src/parse/nom/tests.rs
@@ -167,6 +167,8 @@
 }
 
 mod section {
+    use winnow::error::InputError;
+
     use crate::parse::{
         error::ParseNode,
         tests::util::{
@@ -177,7 +179,10 @@
         Event, Section,
     };
 
-    fn section<'a>(mut i: &'a [u8], node: &mut ParseNode) -> winnow::IResult<&'a [u8], Section<'a>> {
+    fn section<'a>(
+        mut i: &'a [u8],
+        node: &mut ParseNode,
+    ) -> winnow::ModalResult<(&'a [u8], Section<'a>), InputError<&'a [u8]>> {
         let mut header = None;
         let mut events = Vec::new();
         super::section(&mut i, node, &mut |e| match &header {
@@ -507,13 +512,17 @@
 
 mod value_continuation {
     use bstr::ByteSlice;
+    use winnow::error::InputError;
 
     use crate::parse::{
         tests::util::{newline_custom_event, newline_event, value_done_event, value_not_done_event},
         Event,
     };
 
-    pub fn value_impl<'a>(mut i: &'a [u8], events: &mut Vec<Event<'a>>) -> winnow::IResult<&'a [u8], ()> {
+    pub fn value_impl<'a>(
+        mut i: &'a [u8],
+        events: &mut Vec<Event<'a>>,
+    ) -> winnow::ModalResult<(&'a [u8], ()), InputError<&'a [u8]>> {
         super::value_impl(&mut i, &mut |e| events.push(e)).map(|_| (i, ()))
     }
 
@@ -772,6 +781,8 @@
 }
 
 mod key_value_pair {
+    use winnow::error::InputError;
+
     use crate::parse::{
         error::ParseNode,
         tests::util::{name_event, value_event, whitespace_event},
@@ -782,7 +793,7 @@
         mut i: &'a [u8],
         node: &mut ParseNode,
         events: &mut Vec<Event<'a>>,
-    ) -> winnow::IResult<&'a [u8], ()> {
+    ) -> winnow::ModalResult<(&'a [u8], ()), InputError<&'a [u8]>> {
         super::key_value_pair(&mut i, node, &mut |e| events.push(e)).map(|_| (i, ()))
     }
 
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -93,7 +93,7 @@
 version = "2.0.3"
 
 [dependencies.winnow]
-version = "0.6"
+version = "0.7"
 features = ["simd"]
 
 [dev-dependencies.criterion]
