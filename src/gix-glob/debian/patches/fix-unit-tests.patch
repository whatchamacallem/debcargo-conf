diff --git a/Cargo.toml b/Cargo.toml
index 9c18715..06f0092 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -54,7 +54,11 @@ features = ["derive"]
 optional = true
 default-features = false
 
-[dev-dependencies]
+[dev-dependencies.bstr]
+version = "1.3.0"
+features = ["unicode"]
+default-features = false
+
 
 [features]
 serde = [
diff --git a/tests/pattern/matching.rs b/tests/pattern/matching.rs
index df29e02..6c46a5d 100644
--- a/tests/pattern/matching.rs
+++ b/tests/pattern/matching.rs
@@ -41,65 +41,6 @@ impl<'a> Baseline<'a> {
     }
 }
 
-#[test]
-fn compare_baseline_with_ours() {
-    let dir = gix_testtools::scripted_fixture_read_only("make_baseline.sh").unwrap();
-    let (mut total_matches, mut total_correct, mut panics) = (0, 0, 0);
-    let mut mismatches = Vec::new();
-    for (input_file, expected_matches, case) in &[
-        ("git-baseline.match", true, pattern::Case::Sensitive),
-        ("git-baseline.nmatch", false, pattern::Case::Sensitive),
-        ("git-baseline.match-icase", true, pattern::Case::Fold),
-    ] {
-        let input = std::fs::read(dir.join(*input_file)).unwrap();
-        let mut seen = BTreeSet::default();
-
-        for m @ GitMatch {
-            pattern,
-            value,
-            is_match,
-        } in Baseline::new(&input)
-        {
-            total_matches += 1;
-            assert!(seen.insert(m), "duplicate match entry: {m:?}");
-            assert_eq!(
-                is_match, *expected_matches,
-                "baseline for matches must be {expected_matches} - check baseline and git version: {m:?}"
-            );
-            match std::panic::catch_unwind(|| {
-                let pattern = pat(pattern);
-                pattern.matches_repo_relative_path(
-                    value,
-                    basename_start_pos(value),
-                    None,
-                    *case,
-                    gix_glob::wildmatch::Mode::NO_MATCH_SLASH_LITERAL,
-                )
-            }) {
-                Ok(actual_match) => {
-                    if actual_match == is_match {
-                        total_correct += 1;
-                    } else {
-                        mismatches.push((pattern.to_owned(), value.to_owned(), is_match, expected_matches));
-                    }
-                }
-                Err(_) => {
-                    panics += 1;
-                    continue;
-                }
-            };
-        }
-    }
-
-    dbg!(mismatches);
-    assert_eq!(
-        total_correct,
-        total_matches - panics,
-        "We perfectly agree with git here"
-    );
-    assert_eq!(panics, 0);
-}
-
 #[test]
 fn non_dirs_for_must_be_dir_patterns_are_ignored() {
     let pattern = pat("hello/");
