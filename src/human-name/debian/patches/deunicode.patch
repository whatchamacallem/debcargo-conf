From 3959dce5d16e274477b3690b14447942391bcd6b Mon Sep 17 00:00:00 2001
From: Max Crone <code@maxcrone.org>
Date: Mon, 25 Mar 2024 13:25:28 +0100
Subject: [PATCH] Replace unmaintained unidecode with deunicode

---
 Cargo.toml           |  2 +-
 src/comparison.rs    |  2 +-
 src/lib.rs           |  2 +-
 src/transliterate.rs | 19 ++++++++++---------
 5 files changed, 20 insertions(+), 19 deletions(-)

--- a/Cargo.toml
+++ b/Cargo.toml
@@ -51,7 +51,7 @@
 required-features = ["serialization"]
 
 [dependencies.compact_str]
-version = "0.7.1"
+version = "0.8"
 features = ["serde"]
 
 [dependencies.crossbeam-utils]
@@ -78,7 +78,7 @@
 features = ["union"]
 
 [dependencies.unicode-case-mapping]
-version = "0.4"
+version = "1"
 
 [dependencies.unicode-normalization]
 version = "0.1"
@@ -86,8 +86,8 @@
 [dependencies.unicode-segmentation]
 version = "1.9"
 
-[dependencies.unidecode]
-version = "0.3"
+[dependencies.deunicode]
+version = "1.3"
 
 [dev-dependencies.alloc_counter]
 version = "0.0"
--- a/src/comparison.rs
+++ b/src/comparison.rs
@@ -43,7 +43,7 @@
     /// names and/or suffixes are present in both names, they must match as well.
     ///
     /// Transliterates everything to ASCII before comparison using the naive
-    /// algorithm of [unidecode](https://github.com/chowdhurya/rust-unidecode/)
+    /// algorithm of [deunicode](https://github.com/kornelski/deunicode/blob/main/README.md)
     /// (which ignores context), and ignores case, accents and combining marks.
     ///
     /// In the case of given and middle names, allows one name to be a prefix of
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -6,10 +6,10 @@
 #![cfg_attr(feature = "bench", feature(test))]
 
 extern crate crossbeam_utils;
+extern crate deunicode;
 extern crate smallvec;
 extern crate unicode_normalization;
 extern crate unicode_segmentation;
-extern crate unidecode;
 
 #[cfg(test)]
 #[cfg(feature = "bench")]
--- a/src/transliterate.rs
+++ b/src/transliterate.rs
@@ -1,14 +1,12 @@
+use deunicode::deunicode_char;
 use std::str::Chars;
-use unidecode::unidecode_char;
 
 #[inline]
-fn transliterate(c: char) -> Chars<'static> {
-    let s = unidecode_char(c);
-    if s.is_empty() {};
+fn transliterate(c: char) -> Option<Chars<'static>> {
     // We should maybe use unicode case folding here as an initial pass,
     // but without a concrete motivating case (yet) it doesn't seem worth
     // the cost.
-    unidecode_char(c).chars()
+    deunicode_char(c).map(|s| s.chars())
 }
 
 #[inline]
@@ -41,14 +39,15 @@
 pub fn to_ascii_initial(c: char) -> Option<char> {
     match c {
         'A'..='Z' => Some(c),
-        _ => transliterate(c).find_map(ascii_to_upper_if_alpha),
+        _ => transliterate(c)?.find_map(ascii_to_upper_if_alpha),
     }
 }
 
 pub fn to_ascii_casefolded(text: &str) -> Option<impl Iterator<Item = char> + '_> {
     let mut result = text
         .chars()
-        .flat_map(transliterate)
+        .filter_map(transliterate)
+        .flatten()
         .filter_map(ascii_to_lower_if_alpha)
         .peekable();
 
@@ -63,7 +62,8 @@
 pub fn to_ascii_casefolded_reversed(text: &str) -> Option<impl Iterator<Item = char> + '_> {
     let mut result = text
         .chars()
-        .flat_map(transliterate)
+        .filter_map(transliterate)
+        .flatten()
         .rev()
         .filter_map(ascii_to_lower_if_alpha)
         .peekable();
@@ -79,7 +79,8 @@
 pub fn to_ascii_titlecase(s: &str) -> Option<String> {
     let mut result = s
         .chars()
-        .flat_map(transliterate)
+        .filter_map(transliterate)
+        .flatten()
         .filter_map(ascii_to_lower_if_alpha);
 
     result.next().map(|initial| {
