Description: Upgrade to bytes 0.5
Origin: upstream, https://github.com/hyperium/http/commit/43dffa1
Author: Sean McArthur <sean@seanmonstar.com>
Last-Update: 2022-03-29
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
Index: http/src/byte_str.rs
===================================================================
--- http.orig/src/byte_str.rs
+++ http/src/byte_str.rs
@@ -50,7 +50,7 @@ impl From<String> for ByteStr {
 impl<'a> From<&'a str> for ByteStr {
     #[inline]
     fn from(src: &'a str) -> ByteStr {
-        ByteStr { bytes: Bytes::from(src) }
+        ByteStr { bytes: Bytes::copy_from_slice(src.as_bytes()) }
     }
 }
 
Index: http/src/header/name.rs
===================================================================
--- http.orig/src/header/name.rs
+++ http/src/header/name.rs
@@ -1662,7 +1662,7 @@ impl HeaderName {
         match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {
             Repr::Standard(std) => Ok(std.into()),
             Repr::Custom(MaybeLower { buf, lower: true }) => {
-                let buf = Bytes::from(buf);
+                let buf = Bytes::copy_from_slice(buf);
                 let val = unsafe { ByteStr::from_utf8_unchecked(buf) };
                 Ok(Custom(val).into())
             }
@@ -1677,7 +1677,7 @@ impl HeaderName {
                         return Err(InvalidHeaderName::new());
                     }
 
-                    dst.put(b);
+                    dst.put_u8(b);
                 }
 
                 let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };
@@ -1711,7 +1711,7 @@ impl HeaderName {
         match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {
             Repr::Standard(std) => Ok(std.into()),
             Repr::Custom(MaybeLower { buf, lower: true }) => {
-                let buf = Bytes::from(buf);
+                let buf = Bytes::copy_from_slice(buf);
                 let val = unsafe { ByteStr::from_utf8_unchecked(buf) };
                 Ok(Custom(val).into())
             }
@@ -1722,7 +1722,7 @@ impl HeaderName {
                     }
                 }
 
-                let buf = Bytes::from(buf);
+                let buf = Bytes::copy_from_slice(buf);
                 let val = unsafe { ByteStr::from_utf8_unchecked(buf) };
                 Ok(Custom(val).into())
             }
@@ -2089,7 +2089,7 @@ impl<'a> From<HdrName<'a>> for HeaderNam
             }
             Repr::Custom(maybe_lower) => {
                 if maybe_lower.lower {
-                    let buf = Bytes::from(&maybe_lower.buf[..]);
+                    let buf = Bytes::copy_from_slice(&maybe_lower.buf[..]);
                     let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };
 
                     HeaderName {
@@ -2100,7 +2100,7 @@ impl<'a> From<HdrName<'a>> for HeaderNam
                     let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());
 
                     for b in maybe_lower.buf.iter() {
-                        dst.put(HEADER_CHARS[*b as usize]);
+                        dst.put_u8(HEADER_CHARS[*b as usize]);
                     }
 
                     let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };
Index: http/src/header/value.rs
===================================================================
--- http.orig/src/header/value.rs
+++ http/src/header/value.rs
@@ -104,7 +104,7 @@ impl HeaderValue {
     /// ```
     #[inline]
     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {
-        HeaderValue::try_from(src)
+        HeaderValue::try_from_generic(src, |s| Bytes::copy_from_slice(s.as_bytes()))
     }
 
     /// Converts a HeaderName into a HeaderValue
@@ -150,7 +150,7 @@ impl HeaderValue {
     /// ```
     #[inline]
     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {
-        HeaderValue::try_from(src)
+        HeaderValue::try_from_generic(src, Bytes::copy_from_slice)
     }
 
     /// Attempt to convert a `Bytes` buffer to a `HeaderValue`.
@@ -163,7 +163,7 @@ impl HeaderValue {
     /// implementation once the trait is stabilized in std.
     #[inline]
     pub fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValueBytes> {
-        HeaderValue::try_from(src).map_err(InvalidHeaderValueBytes)
+        HeaderValue::try_from_generic(src, std::convert::identity).map_err(InvalidHeaderValueBytes)
     }
 
     /// Convert a `Bytes` directly into a `HeaderValue` without validating.
@@ -189,7 +189,7 @@ impl HeaderValue {
         }
     }
 
-    fn try_from<T: AsRef<[u8]> + Into<Bytes>>(src: T) -> Result<HeaderValue, InvalidHeaderValue> {
+    fn try_from_generic<T: AsRef<[u8]>, F: FnOnce(T) -> Bytes>(src: T, into: F) -> Result<HeaderValue, InvalidHeaderValue> {
         for &b in src.as_ref() {
             if !is_valid(b) {
                 return Err(InvalidHeaderValue {
@@ -198,7 +198,7 @@ impl HeaderValue {
             }
         }
         Ok(HeaderValue {
-            inner: src.into(),
+            inner: into(src),
             is_sensitive: false,
         })
     }
@@ -546,6 +546,15 @@ impl HttpTryFrom<String> for HeaderValue
     }
 }
 
+impl HttpTryFrom<Vec<u8>> for HeaderValue {
+    type Error = InvalidHeaderValueBytes;
+
+    #[inline]
+    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {
+        HeaderValue::from_shared(vec.into())
+    }
+}
+
 impl HttpTryFrom<Bytes> for HeaderValue {
     type Error = InvalidHeaderValueBytes;
 
Index: http/src/uri/authority.rs
===================================================================
--- http.orig/src/uri/authority.rs
+++ http/src/uri/authority.rs
@@ -1,6 +1,3 @@
-// Deprecated in 1.26, needed until our minimum version is >=1.23.
-#[allow(unused, deprecated)]
-use std::ascii::AsciiExt;
 use std::{cmp, fmt, str};
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
@@ -457,7 +454,9 @@ impl<'a> HttpTryFrom<&'a [u8]> for Autho
         }
 
         Ok(Authority {
-            data: unsafe { ByteStr::from_utf8_unchecked(s.into()) },
+            data: unsafe {
+                ByteStr::from_utf8_unchecked(Bytes::copy_from_slice(s))
+            },
         })
     }
 }
Index: http/src/uri/mod.rs
===================================================================
--- http.orig/src/uri/mod.rs
+++ http/src/uri/mod.rs
@@ -888,7 +888,7 @@ impl FromStr for Uri {
 
     #[inline]
     fn from_str(s: &str) -> Result<Uri, InvalidUri> {
-        Uri::from_shared(s.into()).map_err(|e| e.0)
+        Uri::from_shared(Bytes::copy_from_slice(s.as_bytes())).map_err(|e| e.0)
     }
 }
 
Index: http/src/uri/path.rs
===================================================================
--- http.orig/src/uri/path.rs
+++ http/src/uri/path.rs
@@ -296,7 +296,7 @@ impl<'a> HttpTryFrom<&'a [u8]> for PathA
     type Error = InvalidUri;
     #[inline]
     fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {
-        PathAndQuery::from_shared(s.into()).map_err(|e| e.0)
+        PathAndQuery::from_shared(Bytes::copy_from_slice(s)).map_err(|e| e.0)
     }
 }
 
Index: http/src/uri/scheme.rs
===================================================================
--- http.orig/src/uri/scheme.rs
+++ http/src/uri/scheme.rs
@@ -1,6 +1,3 @@
-// Deprecated in 1.26, needed until our minimum version is >=1.23.
-#[allow(unused, deprecated)]
-use std::ascii::AsciiExt;
 use std::fmt;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
@@ -130,7 +127,7 @@ impl<'a> HttpTryFrom<&'a [u8]> for Schem
             Other(_) => {
                 // Unsafe: parse_exact already checks for a strict subset of UTF-8
                 Ok(Other(Box::new(unsafe {
-                    ByteStr::from_utf8_unchecked(s.into())
+                    ByteStr::from_utf8_unchecked(Bytes::copy_from_slice(s))
                 })).into())
             }
         }
Index: http/Cargo.toml
===================================================================
--- http.orig/Cargo.toml
+++ http/Cargo.toml
@@ -38,7 +38,7 @@ path = "benches/header_value.rs"
 name = "uri"
 path = "benches/uri.rs"
 [dependencies.bytes]
-version = "0.4"
+version = "0.5"
 
 [dependencies.fnv]
 version = "1.0.5"
