diff --git a/src/sudo/pipeline/list.rs b/src/sudo/pipeline/list.rs
index 596b59dae..a24e864f6 100644
--- a/src/sudo/pipeline/list.rs
+++ b/src/sudo/pipeline/list.rs
@@ -26,20 +26,16 @@ pub(in crate::sudo) fn run_list(cmd_opts: SudoListOptions) -> Result<(), Error>
 
     let mut context = Context::from_list_opts(cmd_opts, &mut sudoers)?;
 
-    if original_command.is_some() && !context.command.resolved {
-        return Err(Error::CommandNotFound(context.command.command));
-    }
-
-    if auth_invoking_user(&mut context, &sudoers, &original_command, &other_user)?.is_break() {
+    if auth_invoking_user(&mut context, &mut sudoers, &original_command, &other_user)?.is_break() {
         return Ok(());
     }
 
     if let Some(other_user) = &other_user {
-        check_other_users_list_perms(other_user, &context, &sudoers, &original_command)?;
+        check_other_users_list_perms(other_user, &context, &mut sudoers, &original_command)?;
     }
 
     if let Some(original_command) = original_command {
-        check_sudo_command_perms(&original_command, &context, &other_user, &mut sudoers)?;
+        check_sudo_command_perms(&original_command, context, &other_user, &mut sudoers)?;
     } else {
         let invoking_user = other_user.as_ref().unwrap_or(&context.current_user);
         println_ignore_io_error!(
@@ -65,11 +61,14 @@ pub(in crate::sudo) fn run_list(cmd_opts: SudoListOptions) -> Result<(), Error>
 
 fn auth_invoking_user(
     context: &mut Context,
-    sudoers: &Sudoers,
+    sudoers: &mut Sudoers,
     original_command: &Option<String>,
     other_user: &Option<User>,
 ) -> Result<ControlFlow<(), ()>, Error> {
+    let user = other_user.as_ref().unwrap_or(&context.current_user);
+
     let list_request = ListRequest {
+        inspected_user: user,
         target_user: &context.target_user,
         target_group: &context.target_group,
     };
@@ -87,7 +86,7 @@ fn auth_invoking_user(
 
                 println_ignore_io_error!(
                     "User {} is not allowed to run sudo on {}.",
-                    other_user.as_ref().unwrap_or(&context.current_user).name,
+                    user.name,
                     context.hostname
                 );
 
@@ -115,10 +114,11 @@ fn auth_invoking_user(
 fn check_other_users_list_perms(
     other_user: &User,
     context: &Context,
-    sudoers: &Sudoers,
+    sudoers: &mut Sudoers,
     original_command: &Option<String>,
 ) -> Result<(), Error> {
     let list_request = ListRequest {
+        inspected_user: other_user,
         target_user: &context.target_user,
         target_group: &context.target_group,
     };
@@ -138,7 +138,7 @@ fn check_other_users_list_perms(
 
 fn check_sudo_command_perms(
     original_command: &str,
-    context: &Context,
+    context: Context,
     other_user: &Option<User>,
     sudoers: &mut Sudoers,
 ) -> Result<(), Error> {
@@ -156,6 +156,9 @@ fn check_sudo_command_perms(
     if let Authorization::Forbidden = judgement.authorization() {
         return Err(Error::Silent);
     } else {
+        if !context.command.resolved {
+            return Err(Error::CommandNotFound(context.command.command));
+        }
         let command_is_relative_path =
             original_command.contains('/') && !Path::new(&original_command).is_absolute();
         let command: Cow<_> = if command_is_relative_path {
diff --git a/src/sudoers/mod.rs b/src/sudoers/mod.rs
index 1e9a0c98d..30693b4db 100644
--- a/src/sudoers/mod.rs
+++ b/src/sudoers/mod.rs
@@ -59,6 +59,7 @@ pub struct Request<'a, User: UnixUser, Group: UnixGroup> {
 }
 
 pub struct ListRequest<'a, User: UnixUser, Group: UnixGroup> {
+    pub inspected_user: &'a User,
     pub target_user: &'a User,
     pub target_group: &'a Group,
 }
@@ -170,21 +171,37 @@ impl Sudoers {
     }
 
     pub fn check_list_permission<User: UnixUser + PartialEq<User>, Group: UnixGroup>(
-        &self,
+        &mut self,
         invoking_user: &User,
         hostname: &system::Hostname,
         request: ListRequest<User, Group>,
     ) -> Authorization {
-        // exception: if user is root or does not switch users, NOPASSWD is implied
-        let skip_passwd = invoking_user.is_root()
-            || (request.target_user == invoking_user
-                && in_group(invoking_user, request.target_group));
-
-        let mut flags = self
-            .matching_user_specs(invoking_user, hostname)
-            .flatten()
-            .map(|(_, (tag, _))| tag)
-            .max_by_key(|tag| !tag.needs_passwd());
+        let skip_passwd;
+        let mut flags = if request.inspected_user != invoking_user {
+            skip_passwd = invoking_user.is_root();
+
+            self.check(
+                invoking_user,
+                hostname,
+                Request {
+                    user: request.inspected_user,
+                    group: &request.inspected_user.group(),
+                    command: Path::new("list"),
+                    arguments: &[],
+                },
+            )
+            .flags
+            .or(invoking_user.is_root().then(Tag::default))
+        } else {
+            skip_passwd = invoking_user.is_root()
+                || (request.target_user == invoking_user
+                    && in_group(invoking_user, request.target_group));
+
+            self.matching_user_specs(invoking_user, hostname)
+                .flatten()
+                .map(|(_, (tag, _))| tag)
+                .max_by_key(|tag| !tag.needs_passwd())
+        };
 
         if let Some(tag) = flags.as_mut() {
             if skip_passwd {
diff --git a/src/sudoers/test/mod.rs b/src/sudoers/test/mod.rs
index 671153d4a..c7484e428 100644
--- a/src/sudoers/test/mod.rs
+++ b/src/sudoers/test/mod.rs
@@ -36,6 +36,10 @@ impl UnixUser for Named {
     fn is_root(&self) -> bool {
         self.0 == "root"
     }
+    type Group = Named;
+    fn group(&self) -> Named {
+        Self(self.0)
+    }
 }
 
 impl UnixGroup for Named {
diff --git a/src/system/interface.rs b/src/system/interface.rs
index e2d0af975..e318ca6ad 100644
--- a/src/system/interface.rs
+++ b/src/system/interface.rs
@@ -116,6 +116,9 @@ pub trait UnixUser {
     fn is_root(&self) -> bool;
     fn in_group_by_name(&self, _name: &CStr) -> bool;
     fn in_group_by_gid(&self, _gid: GroupId) -> bool;
+
+    type Group: UnixGroup;
+    fn group(&self) -> Self::Group;
 }
 
 pub trait UnixGroup {
@@ -143,6 +146,13 @@ impl UnixUser for super::User {
     fn in_group_by_gid(&self, gid: GroupId) -> bool {
         self.groups.contains(&gid)
     }
+    type Group = super::Group;
+    fn group(&self) -> super::Group {
+        Self::Group {
+            gid: self.gid,
+            name: None,
+        }
+    }
 }
 
 impl UnixGroup for super::Group {
