Index: futures/tests/ready_queue.rs
===================================================================
--- futures.orig/tests/ready_queue.rs
+++ futures/tests/ready_queue.rs
@@ -3,7 +3,7 @@ use futures::executor::{block_on, block_
 use futures::future;
 use futures::stream::{FuturesUnordered, StreamExt};
 use futures::task::Poll;
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 use std::panic::{self, AssertUnwindSafe};
 use std::sync::{Arc, Barrier};
 use std::thread;
@@ -64,7 +64,7 @@ fn resolving_errors() {
     }));
 }
 
-#[test]
+/*#[test]
 fn dropping_ready_queue() {
     block_on(future::lazy(move |_| {
         let queue = FuturesUnordered::new();
@@ -89,7 +89,7 @@ fn dropping_ready_queue() {
             assert!(tx3.poll_canceled(cx).is_ready());
         }
     }));
-}
+}*/
 
 #[test]
 fn stress() {
Index: futures/tests/stream_select_next_some.rs
===================================================================
--- futures.orig/tests/stream_select_next_some.rs
+++ futures/tests/stream_select_next_some.rs
@@ -3,10 +3,10 @@ use futures::future::{self, FusedFuture,
 use futures::select;
 use futures::stream::{FuturesUnordered, StreamExt};
 use futures::task::{Context, Poll};
-use futures_test::future::FutureTestExt;
-use futures_test::task::new_count_waker;
+//use futures_test::future::FutureTestExt;
+//use futures_test::task::new_count_waker;
 
-#[test]
+/*#[test]
 fn is_terminated() {
     let (waker, counter) = new_count_waker();
     let mut cx = Context::from_waker(&waker);
@@ -28,9 +28,9 @@ fn is_terminated() {
     assert_eq!(select_next_some.is_terminated(), false);
     assert_eq!(select_next_some.poll_unpin(&mut cx), Poll::Pending);
     assert_eq!(select_next_some.is_terminated(), true);
-}
+}*/
 
-#[test]
+/*#[test]
 fn select() {
     // Checks that even though `async_tasks` will yield a `None` and return
     // `is_terminated() == true` during the first poll, it manages to toggle
@@ -54,10 +54,10 @@ fn select() {
         }
         assert_eq!(total, 6);
     });
-}
+}*/
 
 // Check that `select!` macro does not fail when importing from `futures_util`.
-#[test]
+/*#[test]
 fn futures_util_select() {
     use futures_util::select;
 
@@ -83,4 +83,4 @@ fn futures_util_select() {
         }
         assert_eq!(total, 6);
     });
-}
+}*/
Index: futures/tests/eager_drop.rs
===================================================================
--- futures.orig/tests/eager_drop.rs
+++ futures/tests/eager_drop.rs
@@ -1,12 +1,12 @@
 use futures::channel::oneshot;
 use futures::future::{self, Future, FutureExt, TryFutureExt};
 use futures::task::{Context, Poll};
-use futures_test::future::FutureTestExt;
+//use futures_test::future::FutureTestExt;
 use pin_project::pin_project;
 use std::pin::Pin;
 use std::sync::mpsc;
 
-#[test]
+/*#[test]
 fn map_ok() {
     // The closure given to `map_ok` should have been dropped by the time `map`
     // runs.
@@ -25,9 +25,9 @@ fn map_ok() {
         .run_in_background();
 
     rx2.recv().unwrap();
-}
+}*/
 
-#[test]
+/*#[test]
 fn map_err() {
     // The closure given to `map_err` should have been dropped by the time `map`
     // runs.
@@ -46,7 +46,7 @@ fn map_err() {
         .run_in_background();
 
     rx2.recv().unwrap();
-}
+}*/
 
 #[pin_project]
 struct FutureData<F, T> {
@@ -63,7 +63,7 @@ impl<F: Future, T: Send + 'static> Futur
     }
 }
 
-#[test]
+/*#[test]
 fn then_drops_eagerly() {
     let (tx0, rx0) = oneshot::channel::<()>();
     let (tx1, rx1) = mpsc::channel::<()>();
@@ -80,9 +80,9 @@ fn then_drops_eagerly() {
     assert_eq!(Err(mpsc::TryRecvError::Empty), rx2.try_recv());
     tx0.send(()).unwrap();
     rx2.recv().unwrap();
-}
+}*/
 
-#[test]
+/*#[test]
 fn and_then_drops_eagerly() {
     let (tx0, rx0) = oneshot::channel::<Result<(), ()>>();
     let (tx1, rx1) = mpsc::channel::<()>();
@@ -99,9 +99,9 @@ fn and_then_drops_eagerly() {
     assert_eq!(Err(mpsc::TryRecvError::Empty), rx2.try_recv());
     tx0.send(Ok(())).unwrap();
     rx2.recv().unwrap();
-}
+}*/
 
-#[test]
+/*#[test]
 fn or_else_drops_eagerly() {
     let (tx0, rx0) = oneshot::channel::<Result<(), ()>>();
     let (tx1, rx1) = mpsc::channel::<()>();
@@ -118,4 +118,4 @@ fn or_else_drops_eagerly() {
     assert_eq!(Err(mpsc::TryRecvError::Empty), rx2.try_recv());
     tx0.send(Err(())).unwrap();
     rx2.recv().unwrap();
-}
+}*/
Index: futures/tests/future_abortable.rs
===================================================================
--- futures.orig/tests/future_abortable.rs
+++ futures/tests/future_abortable.rs
@@ -2,7 +2,7 @@ use futures::channel::oneshot;
 use futures::executor::block_on;
 use futures::future::{abortable, Aborted, FutureExt};
 use futures::task::{Context, Poll};
-use futures_test::task::new_count_waker;
+//use futures_test::task::new_count_waker;
 
 #[test]
 fn abortable_works() {
@@ -14,7 +14,7 @@ fn abortable_works() {
     assert_eq!(Err(Aborted), block_on(abortable_rx));
 }
 
-#[test]
+/*#[test]
 fn abortable_awakens() {
     let (_tx, a_rx) = oneshot::channel::<()>();
     let (mut abortable_rx, abort_handle) = abortable(a_rx);
@@ -30,7 +30,7 @@ fn abortable_awakens() {
     assert_eq!(counter, 1);
     assert!(abortable_rx.is_aborted());
     assert_eq!(Poll::Ready(Err(Aborted)), abortable_rx.poll_unpin(&mut cx));
-}
+}*/
 
 #[test]
 fn abortable_resolves() {
Index: futures/tests/future_basic_combinators.rs
===================================================================
--- futures.orig/tests/future_basic_combinators.rs
+++ futures/tests/future_basic_combinators.rs
@@ -1,8 +1,8 @@
 use futures::future::{self, FutureExt, TryFutureExt};
-use futures_test::future::FutureTestExt;
+//use futures_test::future::FutureTestExt;
 use std::sync::mpsc;
 
-#[test]
+/*#[test]
 fn basic_future_combinators() {
     let (tx1, rx) = mpsc::channel();
     let tx2 = tx1.clone();
@@ -29,9 +29,9 @@ fn basic_future_combinators() {
         assert_eq!(rx.recv(), Ok(i));
     } // Check it
     assert!(rx.recv().is_err()); // Should be done
-}
+}*/
 
-#[test]
+/*#[test]
 fn basic_try_future_combinators() {
     let (tx1, rx) = mpsc::channel();
     let tx2 = tx1.clone();
@@ -101,4 +101,4 @@ fn basic_try_future_combinators() {
         assert_eq!(rx.recv(), Ok(i));
     } // Check it
     assert!(rx.recv().is_err()); // Should be done
-}
+}*/
Index: futures/tests/future_fuse.rs
===================================================================
--- futures.orig/tests/future_fuse.rs
+++ futures/tests/future_fuse.rs
@@ -1,12 +1,12 @@
 use futures::future::{self, FutureExt};
 use futures::task::Context;
-use futures_test::task::panic_waker;
+//use futures_test::task::panic_waker;
 
-#[test]
+/*#[test]
 fn fuse() {
     let mut future = future::ready::<i32>(2).fuse();
     let waker = panic_waker();
     let mut cx = Context::from_waker(&waker);
     assert!(future.poll_unpin(&mut cx).is_ready());
     assert!(future.poll_unpin(&mut cx).is_pending());
-}
+}*/
Index: futures/tests/io_buf_writer.rs
===================================================================
--- futures.orig/tests/io_buf_writer.rs
+++ futures/tests/io_buf_writer.rs
@@ -4,7 +4,7 @@ use futures::io::{
     AsyncSeek, AsyncSeekExt, AsyncWrite, AsyncWriteExt, BufWriter, Cursor, SeekFrom,
 };
 use futures::task::{Context, Poll};
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 use std::io;
 use std::pin::Pin;
 
@@ -43,14 +43,14 @@ impl AsyncWrite for MaybePending {
     }
 }
 
-fn run<F: Future + Unpin>(mut f: F) -> F::Output {
+/*fn run<F: Future + Unpin>(mut f: F) -> F::Output {
     let mut cx = noop_context();
     loop {
         if let Poll::Ready(x) = f.poll_unpin(&mut cx) {
             return x;
         }
     }
-}
+}*/
 
 #[test]
 fn buf_writer() {
@@ -119,7 +119,7 @@ fn buf_writer_seek() {
     assert_eq!(&w.into_inner().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);
 }
 
-#[test]
+/*#[test]
 fn maybe_pending_buf_writer() {
     let mut writer = BufWriter::with_capacity(2, MaybePending::new(Vec::new()));
 
@@ -159,9 +159,9 @@ fn maybe_pending_buf_writer() {
     run(writer.flush()).unwrap();
     assert_eq!(writer.buffer(), []);
     assert_eq!(&writer.get_ref().inner, &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
-}
+}*/
 
-#[test]
+/*#[test]
 fn maybe_pending_buf_writer_inner_flushes() {
     let mut w = BufWriter::with_capacity(3, MaybePending::new(Vec::new()));
     run(w.write(&[0, 1])).unwrap();
@@ -169,9 +169,9 @@ fn maybe_pending_buf_writer_inner_flushe
     run(w.flush()).unwrap();
     let w = w.into_inner().inner;
     assert_eq!(w, [0, 1]);
-}
+}*/
 
-#[test]
+/*#[test]
 fn maybe_pending_buf_writer_seek() {
     struct MaybePendingSeek {
         inner: Cursor<Vec<u8>>,
@@ -236,4 +236,4 @@ fn maybe_pending_buf_writer_seek() {
     run(w.write_all(&[8, 9])).unwrap();
     run(w.flush()).unwrap();
     assert_eq!(&w.into_inner().inner.into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);
-}
+}*/
Index: futures/tests/io_lines.rs
===================================================================
--- futures.orig/tests/io_lines.rs
+++ futures/tests/io_lines.rs
@@ -3,17 +3,17 @@ use futures::future::{Future, FutureExt}
 use futures::io::{AsyncBufReadExt, Cursor};
 use futures::stream::{self, StreamExt, TryStreamExt};
 use futures::task::Poll;
-use futures_test::io::AsyncReadTestExt;
-use futures_test::task::noop_context;
+//use futures_test::io::AsyncReadTestExt;
+//use futures_test::task::noop_context;
 
-fn run<F: Future + Unpin>(mut f: F) -> F::Output {
+/*fn run<F: Future + Unpin>(mut f: F) -> F::Output {
     let mut cx = noop_context();
     loop {
         if let Poll::Ready(x) = f.poll_unpin(&mut cx) {
             return x;
         }
     }
-}
+}*/
 
 macro_rules! block_on_next {
     ($expr:expr) => {
@@ -21,11 +21,11 @@ macro_rules! block_on_next {
     };
 }
 
-macro_rules! run_next {
+/*macro_rules! run_next {
     ($expr:expr) => {
         run($expr.next()).unwrap().unwrap()
     };
-}
+}*/
 
 #[test]
 fn lines() {
@@ -41,7 +41,7 @@ fn lines() {
     assert!(block_on(s.next()).is_none());
 }
 
-#[test]
+/*#[test]
 fn maybe_pending() {
     let buf =
         stream::iter(vec![&b"12"[..], &b"\r"[..]]).map(Ok).into_async_read().interleave_pending();
@@ -57,4 +57,4 @@ fn maybe_pending() {
     assert_eq!(run_next!(s), "12".to_string());
     assert_eq!(run_next!(s), "".to_string());
     assert!(run(s.next()).is_none());
-}
+}*/
Index: futures/tests/io_read.rs
===================================================================
--- futures.orig/tests/io_read.rs
+++ futures/tests/io_read.rs
@@ -1,5 +1,5 @@
 use futures::io::AsyncRead;
-use futures_test::task::panic_context;
+//use futures_test::task::panic_context;
 use std::io;
 use std::pin::Pin;
 use std::task::{Context, Poll};
@@ -24,7 +24,7 @@ impl AsyncRead for MockReader {
     }
 }
 
-/// Verifies that the default implementation of `poll_read_vectored`
+/* /// Verifies that the default implementation of `poll_read_vectored`
 /// calls `poll_read` with an empty slice if no buffers are provided.
 #[test]
 fn read_vectored_no_buffers() {
@@ -38,9 +38,9 @@ fn read_vectored_no_buffers() {
     let res = Pin::new(&mut reader).poll_read_vectored(cx, bufs);
     let res = res.map_err(|e| e.kind());
     assert_eq!(res, Poll::Ready(Err(io::ErrorKind::BrokenPipe)))
-}
+}*/
 
-/// Verifies that the default implementation of `poll_read_vectored`
+/* /// Verifies that the default implementation of `poll_read_vectored`
 /// calls `poll_read` with the first non-empty buffer.
 #[test]
 fn read_vectored_first_non_empty() {
@@ -61,4 +61,4 @@ fn read_vectored_first_non_empty() {
     let res = res.map_err(|e| e.kind());
     assert_eq!(res, Poll::Ready(Ok(4)));
     assert_eq!(buf, b"four"[..]);
-}
+}*/
Index: futures/tests/io_read_line.rs
===================================================================
--- futures.orig/tests/io_read_line.rs
+++ futures/tests/io_read_line.rs
@@ -3,17 +3,17 @@ use futures::future::{Future, FutureExt}
 use futures::io::{AsyncBufReadExt, Cursor};
 use futures::stream::{self, StreamExt, TryStreamExt};
 use futures::task::Poll;
-use futures_test::io::AsyncReadTestExt;
-use futures_test::task::noop_context;
+//use futures_test::io::AsyncReadTestExt;
+//use futures_test::task::noop_context;
 
-fn run<F: Future + Unpin>(mut f: F) -> F::Output {
+/*fn run<F: Future + Unpin>(mut f: F) -> F::Output {
     let mut cx = noop_context();
     loop {
         if let Poll::Ready(x) = f.poll_unpin(&mut cx) {
             return x;
         }
     }
-}
+}*/
 
 #[test]
 fn read_line() {
@@ -34,7 +34,7 @@ fn read_line() {
     assert_eq!(v, "");
 }
 
-#[test]
+/*#[test]
 fn maybe_pending() {
     let mut buf = b"12".interleave_pending();
     let mut v = String::new();
@@ -55,4 +55,4 @@ fn maybe_pending() {
     v.clear();
     assert_eq!(run(buf.read_line(&mut v)).unwrap(), 0);
     assert_eq!(v, "");
-}
+}*/
Index: futures/tests/io_read_to_string.rs
===================================================================
--- futures.orig/tests/io_read_to_string.rs
+++ futures/tests/io_read_to_string.rs
@@ -3,8 +3,8 @@ use futures::future::{Future, FutureExt}
 use futures::io::{AsyncReadExt, Cursor};
 use futures::stream::{self, StreamExt, TryStreamExt};
 use futures::task::Poll;
-use futures_test::io::AsyncReadTestExt;
-use futures_test::task::noop_context;
+//use futures_test::io::AsyncReadTestExt;
+//use futures_test::task::noop_context;
 
 #[test]
 fn read_to_string() {
@@ -23,7 +23,7 @@ fn read_to_string() {
     assert!(block_on(c.read_to_string(&mut v)).is_err());
 }
 
-#[test]
+/*#[test]
 fn interleave_pending() {
     fn run<F: Future + Unpin>(mut f: F) -> F::Output {
         let mut cx = noop_context();
@@ -41,4 +41,4 @@ fn interleave_pending() {
     let mut v = String::new();
     assert_eq!(run(buf.read_to_string(&mut v)).unwrap(), 5);
     assert_eq!(v, "12333");
-}
+}*/
Index: futures/tests/io_read_until.rs
===================================================================
--- futures.orig/tests/io_read_until.rs
+++ futures/tests/io_read_until.rs
@@ -3,17 +3,17 @@ use futures::future::{Future, FutureExt}
 use futures::io::{AsyncBufReadExt, Cursor};
 use futures::stream::{self, StreamExt, TryStreamExt};
 use futures::task::Poll;
-use futures_test::io::AsyncReadTestExt;
-use futures_test::task::noop_context;
+//use futures_test::io::AsyncReadTestExt;
+//use futures_test::task::noop_context;
 
-fn run<F: Future + Unpin>(mut f: F) -> F::Output {
+/*fn run<F: Future + Unpin>(mut f: F) -> F::Output {
     let mut cx = noop_context();
     loop {
         if let Poll::Ready(x) = f.poll_unpin(&mut cx) {
             return x;
         }
     }
-}
+}*/
 
 #[test]
 fn read_until() {
@@ -34,7 +34,7 @@ fn read_until() {
     assert_eq!(v, []);
 }
 
-#[test]
+/*#[test]
 fn maybe_pending() {
     let mut buf = b"12".interleave_pending();
     let mut v = Vec::new();
@@ -57,4 +57,4 @@ fn maybe_pending() {
     v.clear();
     assert_eq!(run(buf.read_until(b'3', &mut v)).unwrap(), 0);
     assert_eq!(v, []);
-}
+}*/
Index: futures/tests/io_write.rs
===================================================================
--- futures.orig/tests/io_write.rs
+++ futures/tests/io_write.rs
@@ -1,5 +1,5 @@
 use futures::io::AsyncWrite;
-use futures_test::task::panic_context;
+//use futures_test::task::panic_context;
 use std::io;
 use std::pin::Pin;
 use std::task::{Context, Poll};
@@ -32,7 +32,7 @@ impl AsyncWrite for MockWriter {
     }
 }
 
-/// Verifies that the default implementation of `poll_write_vectored`
+/* /// Verifies that the default implementation of `poll_write_vectored`
 /// calls `poll_write` with an empty slice if no buffers are provided.
 #[test]
 fn write_vectored_no_buffers() {
@@ -46,9 +46,9 @@ fn write_vectored_no_buffers() {
     let res = Pin::new(&mut writer).poll_write_vectored(cx, bufs);
     let res = res.map_err(|e| e.kind());
     assert_eq!(res, Poll::Ready(Err(io::ErrorKind::BrokenPipe)))
-}
+}*/
 
-/// Verifies that the default implementation of `poll_write_vectored`
+/* /// Verifies that the default implementation of `poll_write_vectored`
 /// calls `poll_write` with the first non-empty buffer.
 #[test]
 fn write_vectored_first_non_empty() {
@@ -62,4 +62,4 @@ fn write_vectored_first_non_empty() {
     let res = Pin::new(&mut writer).poll_write_vectored(cx, bufs);
     let res = res.map_err(|e| e.kind());
     assert_eq!(res, Poll::Ready(Ok(4)));
-}
+}*/
Index: futures/tests/lock_mutex.rs
===================================================================
--- futures.orig/tests/lock_mutex.rs
+++ futures/tests/lock_mutex.rs
@@ -4,19 +4,19 @@ use futures::future::{ready, FutureExt};
 use futures::lock::Mutex;
 use futures::stream::StreamExt;
 use futures::task::{Context, SpawnExt};
-use futures_test::future::FutureTestExt;
-use futures_test::task::{new_count_waker, panic_context};
+//use futures_test::future::FutureTestExt;
+//use futures_test::task::{new_count_waker, panic_context};
 use std::sync::Arc;
 
-#[test]
+/*#[test]
 fn mutex_acquire_uncontested() {
     let mutex = Mutex::new(());
     for _ in 0..10 {
         assert!(mutex.lock().poll_unpin(&mut panic_context()).is_ready());
     }
-}
+}*/
 
-#[test]
+/*#[test]
 fn mutex_wakes_waiters() {
     let mutex = Mutex::new(());
     let (waker, counter) = new_count_waker();
@@ -32,9 +32,9 @@ fn mutex_wakes_waiters() {
 
     assert_eq!(counter, 1);
     assert!(waiter.poll_unpin(&mut panic_context()).is_ready());
-}
+}*/
 
-#[cfg_attr(miri, ignore)] // https://github.com/rust-lang/miri/issues/1038
+/*#[cfg_attr(miri, ignore)] // https://github.com/rust-lang/miri/issues/1038
 #[test]
 fn mutex_contested() {
     let (tx, mut rx) = mpsc::unbounded();
@@ -64,4 +64,4 @@ fn mutex_contested() {
         let lock = mutex.lock().await;
         assert_eq!(num_tasks, *lock);
     })
-}
+}*/
Index: futures/tests/oneshot.rs
===================================================================
--- futures.orig/tests/oneshot.rs
+++ futures/tests/oneshot.rs
@@ -1,10 +1,10 @@
 use futures::channel::oneshot;
 use futures::future::{FutureExt, TryFutureExt};
-use futures_test::future::FutureTestExt;
+//use futures_test::future::FutureTestExt;
 use std::sync::mpsc;
 use std::thread;
 
-#[test]
+/*#[test]
 fn oneshot_send1() {
     let (tx1, rx1) = oneshot::channel::<i32>();
     let (tx2, rx2) = mpsc::channel();
@@ -13,9 +13,9 @@ fn oneshot_send1() {
     rx1.map_ok(move |x| tx2.send(x)).run_in_background();
     assert_eq!(1, rx2.recv().unwrap());
     t.join().unwrap();
-}
+}*/
 
-#[test]
+/*#[test]
 fn oneshot_send2() {
     let (tx1, rx1) = oneshot::channel::<i32>();
     let (tx2, rx2) = mpsc::channel();
@@ -23,9 +23,9 @@ fn oneshot_send2() {
     thread::spawn(|| tx1.send(1).unwrap()).join().unwrap();
     rx1.map_ok(move |x| tx2.send(x).unwrap()).run_in_background();
     assert_eq!(1, rx2.recv().unwrap());
-}
+}*/
 
-#[test]
+/*#[test]
 fn oneshot_send3() {
     let (tx1, rx1) = oneshot::channel::<i32>();
     let (tx2, rx2) = mpsc::channel();
@@ -33,9 +33,9 @@ fn oneshot_send3() {
     rx1.map_ok(move |x| tx2.send(x).unwrap()).run_in_background();
     thread::spawn(|| tx1.send(1).unwrap()).join().unwrap();
     assert_eq!(1, rx2.recv().unwrap());
-}
+}*/
 
-#[test]
+/*#[test]
 fn oneshot_drop_tx1() {
     let (tx1, rx1) = oneshot::channel::<i32>();
     let (tx2, rx2) = mpsc::channel();
@@ -44,9 +44,9 @@ fn oneshot_drop_tx1() {
     rx1.map(move |result| tx2.send(result).unwrap()).run_in_background();
 
     assert_eq!(Err(oneshot::Canceled), rx2.recv().unwrap());
-}
+}*/
 
-#[test]
+/*#[test]
 fn oneshot_drop_tx2() {
     let (tx1, rx1) = oneshot::channel::<i32>();
     let (tx2, rx2) = mpsc::channel();
@@ -56,7 +56,7 @@ fn oneshot_drop_tx2() {
     t.join().unwrap();
 
     assert_eq!(Err(oneshot::Canceled), rx2.recv().unwrap());
-}
+}*/
 
 #[test]
 fn oneshot_drop_rx() {
Index: futures/tests/sink.rs
===================================================================
--- futures.orig/tests/sink.rs
+++ futures/tests/sink.rs
@@ -6,7 +6,7 @@ use futures::ready;
 use futures::sink::{self, Sink, SinkErrInto, SinkExt};
 use futures::stream::{self, Stream, StreamExt};
 use futures::task::{self, ArcWake, Context, Poll, Waker};
-use futures_test::task::panic_context;
+//use futures_test::task::panic_context;
 use std::cell::{Cell, RefCell};
 use std::collections::VecDeque;
 use std::fmt;
@@ -16,7 +16,7 @@ use std::rc::Rc;
 use std::sync::atomic::{AtomicBool, Ordering};
 use std::sync::Arc;
 
-fn sassert_next<S>(s: &mut S, item: S::Item)
+/*fn sassert_next<S>(s: &mut S, item: S::Item)
 where
     S: Stream + Unpin,
     S::Item: Eq + fmt::Debug,
@@ -26,7 +26,7 @@ where
         Poll::Ready(Some(e)) => assert_eq!(e, item),
         Poll::Pending => panic!("stream wasn't ready"),
     }
-}
+}*/
 
 fn unwrap<T, E: fmt::Debug>(x: Poll<Result<T, E>>) -> T {
     match x {
@@ -265,7 +265,7 @@ fn send_all() {
 
 // Test that `start_send` on an `mpsc` channel does indeed block when the
 // channel is full
-#[test]
+/*#[test]
 fn mpsc_blocking_start_send() {
     let (mut tx, mut rx) = mpsc::channel::<i32>(0);
 
@@ -284,7 +284,7 @@ fn mpsc_blocking_start_send() {
             sassert_next(&mut rx, 1);
         })
     }));
-}
+}*/
 
 // test `flush` by using `with` to make the first insertion into a sink block
 // until a oneshot is completed
@@ -337,7 +337,7 @@ fn with_flat_map() {
 
 // Check that `with` propagates `poll_ready` to the inner sink.
 // Regression test for the issue #1834.
-#[test]
+/*#[test]
 fn with_propagates_poll_ready() {
     let (tx, mut rx) = mpsc::channel::<i32>(0);
     let mut tx = tx.with(|item: i32| future::ok::<i32, mpsc::SendError>(item + 10));
@@ -359,7 +359,7 @@ fn with_propagates_poll_ready() {
             assert_eq!(tx.as_mut().start_send(1), Ok(()));
         })
     }));
-}
+}*/
 
 // test that the `with` sink doesn't require the underlying sink to flush,
 // but doesn't claim to be flushed until the underlying sink is
@@ -485,7 +485,7 @@ fn fanout_backpressure() {
     })
 }
 
-#[test]
+/*#[test]
 fn sink_map_err() {
     {
         let cx = &mut panic_context();
@@ -497,7 +497,7 @@ fn sink_map_err() {
 
     let tx = mpsc::channel(0).0;
     assert_eq!(Pin::new(&mut tx.sink_map_err(|_| ())).start_send(()), Err(()));
-}
+}*/
 
 #[test]
 fn sink_unfold() {
@@ -531,7 +531,7 @@ fn sink_unfold() {
     }))
 }
 
-#[test]
+/*#[test]
 fn err_into() {
     #[derive(Copy, Clone, Debug, PartialEq, Eq)]
     struct ErrIntoTest;
@@ -552,4 +552,4 @@ fn err_into() {
 
     let tx = mpsc::channel(0).0;
     assert_eq!(Pin::new(&mut tx.sink_err_into()).start_send(()), Err(ErrIntoTest));
-}
+}*/
Index: futures/tests/stream.rs
===================================================================
--- futures.orig/tests/stream.rs
+++ futures/tests/stream.rs
@@ -9,7 +9,7 @@ use futures::sink::SinkExt;
 use futures::stream::{self, StreamExt};
 use futures::task::Poll;
 use futures::{ready, FutureExt};
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 
 #[test]
 fn select() {
@@ -399,7 +399,7 @@ fn ready_chunks_panic_on_cap_zero() {
     let _ = rx1.ready_chunks(0);
 }
 
-#[test]
+/*#[test]
 fn ready_chunks() {
     let (mut tx, rx1) = mpsc::channel::<i32>(16);
 
@@ -419,3 +419,4 @@ fn ready_chunks() {
         assert_eq!(s.next().await.unwrap(), vec![4]);
     });
 }
+*/
Index: futures/tests/stream_abortable.rs
===================================================================
--- futures.orig/tests/stream_abortable.rs
+++ futures/tests/stream_abortable.rs
@@ -3,7 +3,7 @@ use futures::executor::block_on;
 use futures::stream::{abortable, Stream, StreamExt};
 use futures::task::{Context, Poll};
 use futures::SinkExt;
-use futures_test::task::new_count_waker;
+//use futures_test::task::new_count_waker;
 use std::pin::Pin;
 
 #[test]
@@ -16,7 +16,7 @@ fn abortable_works() {
     assert_eq!(None, block_on(abortable_rx.next()));
 }
 
-#[test]
+/*#[test]
 fn abortable_awakens() {
     let (_tx, a_rx) = mpsc::channel::<()>(1);
     let (mut abortable_rx, abort_handle) = abortable(a_rx);
@@ -32,7 +32,7 @@ fn abortable_awakens() {
     assert_eq!(counter, 1);
     assert!(abortable_rx.is_aborted());
     assert_eq!(Poll::Ready(None), Pin::new(&mut abortable_rx).poll_next(&mut cx));
-}
+}*/
 
 #[test]
 fn abortable_resolves() {
Index: futures/tests/stream_futures_ordered.rs
===================================================================
--- futures.orig/tests/stream_futures_ordered.rs
+++ futures/tests/stream_futures_ordered.rs
@@ -2,10 +2,10 @@ use futures::channel::oneshot;
 use futures::executor::{block_on, block_on_stream};
 use futures::future::{self, join, Future, FutureExt, TryFutureExt};
 use futures::stream::{FuturesOrdered, StreamExt};
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 use std::any::Any;
 
-#[test]
+/*#[test]
 fn works_1() {
     let (a_tx, a_rx) = oneshot::channel::<i32>();
     let (b_tx, b_rx) = oneshot::channel::<i32>();
@@ -44,7 +44,7 @@ fn works_2() {
     assert!(stream.poll_next_unpin(&mut cx).is_pending());
     c_tx.send(33).unwrap();
     assert!(stream.poll_next_unpin(&mut cx).is_ready());
-}
+}*/
 
 #[test]
 fn from_iterator() {
@@ -55,7 +55,7 @@ fn from_iterator() {
     assert_eq!(block_on(stream.collect::<Vec<_>>()), vec![1, 2, 3]);
 }
 
-#[cfg_attr(miri, ignore)] // https://github.com/rust-lang/miri/issues/1038
+/*#[cfg_attr(miri, ignore)] // https://github.com/rust-lang/miri/issues/1038
 #[test]
 fn queue_never_unblocked() {
     let (_a_tx, a_rx) = oneshot::channel::<Box<dyn Any + Send>>();
@@ -83,4 +83,4 @@ fn queue_never_unblocked() {
     c_tx.send(Box::new(())).unwrap();
     assert!(stream.poll_next_unpin(cx).is_pending());
     assert!(stream.poll_next_unpin(cx).is_pending());
-}
+}*/
Index: futures/tests/stream_futures_unordered.rs
===================================================================
--- futures.orig/tests/stream_futures_unordered.rs
+++ futures/tests/stream_futures_unordered.rs
@@ -3,14 +3,14 @@ use futures::executor::{block_on, block_
 use futures::future::{self, join, Future, FutureExt};
 use futures::stream::{FusedStream, FuturesUnordered, StreamExt};
 use futures::task::{Context, Poll};
-use futures_test::future::FutureTestExt;
-use futures_test::task::noop_context;
-use futures_test::{assert_stream_done, assert_stream_next, assert_stream_pending};
+//use futures_test::future::FutureTestExt;
+//use futures_test::task::noop_context;
+//use futures_test::{assert_stream_done, assert_stream_next, assert_stream_pending};
 use std::iter::FromIterator;
 use std::pin::Pin;
 use std::sync::atomic::{AtomicBool, Ordering};
 
-#[test]
+/*#[test]
 fn is_terminated() {
     let mut cx = noop_context();
     let mut tasks = FuturesUnordered::new();
@@ -35,7 +35,7 @@ fn is_terminated() {
     assert_eq!(tasks.is_terminated(), false);
     assert_eq!(tasks.poll_next_unpin(&mut cx), Poll::Ready(None));
     assert_eq!(tasks.is_terminated(), true);
-}
+}*/
 
 #[test]
 fn works_1() {
@@ -57,7 +57,7 @@ fn works_1() {
 }
 
 #[cfg_attr(miri, ignore)] // https://github.com/rust-lang/miri/issues/1038
-#[test]
+/*#[test]
 fn works_2() {
     let (a_tx, a_rx) = oneshot::channel::<i32>();
     let (b_tx, b_rx) = oneshot::channel::<i32>();
@@ -75,7 +75,7 @@ fn works_2() {
     c_tx.send(20).unwrap();
     assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(30))));
     assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(None));
-}
+}*/
 
 #[test]
 fn from_iterator() {
@@ -87,7 +87,7 @@ fn from_iterator() {
 }
 
 #[cfg_attr(miri, ignore)] // https://github.com/rust-lang/miri/issues/1038
-#[test]
+/*#[test]
 fn finished_future() {
     let (_a_tx, a_rx) = oneshot::channel::<i32>();
     let (b_tx, b_rx) = oneshot::channel::<i32>();
@@ -110,7 +110,7 @@ fn finished_future() {
     assert!(stream.poll_next_unpin(cx).is_ready());
     assert!(stream.poll_next_unpin(cx).is_pending());
     assert!(stream.poll_next_unpin(cx).is_pending());
-}
+}*/
 
 #[test]
 fn iter_mut_cancel() {
@@ -261,7 +261,7 @@ fn into_iter_len() {
     assert!(into_iter.next().is_none());
 }
 
-#[test]
+/*#[test]
 fn futures_not_moved_after_poll() {
     // Future that will be ready after being polled twice,
     // asserting that it does not move.
@@ -272,9 +272,9 @@ fn futures_not_moved_after_poll() {
     assert_stream_next!(stream, ());
     assert_stream_next!(stream, ());
     assert_stream_done!(stream);
-}
+}*/
 
-#[test]
+/*#[test]
 fn len_valid_during_out_of_order_completion() {
     // Complete futures out-of-order and add new futures afterwards to ensure
     // length values remain correct.
@@ -312,9 +312,9 @@ fn len_valid_during_out_of_order_complet
     a_tx.send(7).unwrap();
     assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(7))));
     assert_eq!(stream.len(), 0);
-}
+}*/
 
-#[test]
+/*#[test]
 fn polled_only_once_at_most_per_iteration() {
     #[derive(Debug, Clone, Copy, Default)]
     struct F {
@@ -346,7 +346,7 @@ fn polled_only_once_at_most_per_iteratio
 
     let mut tasks = FuturesUnordered::<F>::new();
     assert_eq!(Poll::Ready(None), tasks.poll_next_unpin(cx));
-}
+}*/
 
 #[test]
 fn clear() {
Index: futures/tests/stream_into_async_read.rs
===================================================================
--- futures.orig/tests/stream_into_async_read.rs
+++ futures/tests/stream_into_async_read.rs
@@ -2,9 +2,9 @@ use core::pin::Pin;
 use futures::io::{AsyncBufRead, AsyncRead};
 use futures::stream::{self, TryStreamExt};
 use futures::task::Poll;
-use futures_test::{stream::StreamTestExt, task::noop_context};
+//use futures_test::{stream::StreamTestExt, task::noop_context};
 
-macro_rules! assert_read {
+/*macro_rules! assert_read {
     ($reader:expr, $buf:expr, $item:expr) => {
         let mut cx = noop_context();
         loop {
@@ -22,9 +22,9 @@ macro_rules! assert_read {
             }
         }
     };
-}
+}*/
 
-macro_rules! assert_fill_buf {
+/*macro_rules! assert_fill_buf {
     ($reader:expr, $buf:expr) => {
         let mut cx = noop_context();
         loop {
@@ -42,9 +42,9 @@ macro_rules! assert_fill_buf {
             }
         }
     };
-}
+}*/
 
-#[test]
+/*#[test]
 fn test_into_async_read() {
     let stream = stream::iter((1..=3).flat_map(|_| vec![Ok(vec![]), Ok(vec![1, 2, 3, 4, 5])]));
     let mut reader = stream.interleave_pending().into_async_read();
@@ -69,9 +69,9 @@ fn test_into_async_read() {
     assert_eq!(&buf[..2], &[4, 5]);
 
     assert_read!(reader, &mut buf, 0);
-}
+}*/
 
-#[test]
+/*#[test]
 fn test_into_async_bufread() {
     let stream = stream::iter((1..=2).flat_map(|_| vec![Ok(vec![]), Ok(vec![1, 2, 3, 4, 5])]));
     let mut reader = stream.interleave_pending().into_async_read();
@@ -91,4 +91,4 @@ fn test_into_async_bufread() {
     reader.as_mut().consume(3);
 
     assert_fill_buf!(reader, &[][..]);
-}
+}*/
Index: futures/tests/stream_select_all.rs
===================================================================
--- futures.orig/tests/stream_select_all.rs
+++ futures/tests/stream_select_all.rs
@@ -3,9 +3,9 @@ use futures::executor::{block_on, block_
 use futures::future::{self, FutureExt};
 use futures::stream::{self, select_all, FusedStream, SelectAll, StreamExt};
 use futures::task::Poll;
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 
-#[test]
+/*#[test]
 fn is_terminated() {
     let mut cx = noop_context();
     let mut tasks = SelectAll::new();
@@ -28,7 +28,7 @@ fn is_terminated() {
     assert_eq!(tasks.is_terminated(), false);
     assert_eq!(tasks.poll_next_unpin(&mut cx), Poll::Ready(None));
     assert_eq!(tasks.is_terminated(), true);
-}
+}*/
 
 #[test]
 fn issue_1626() {
Index: futures/tests/stream_try_stream.rs
===================================================================
--- futures.orig/tests/stream_try_stream.rs
+++ futures/tests/stream_try_stream.rs
@@ -4,9 +4,9 @@ use futures::{
     stream::{self, StreamExt, TryStreamExt},
     task::Poll,
 };
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 
-#[test]
+/*#[test]
 fn try_filter_map_after_err() {
     let cx = &mut noop_context();
     let mut s = stream::iter(1..=3)
@@ -15,9 +15,9 @@ fn try_filter_map_after_err() {
         .filter_map(|r| async move { r.ok() })
         .boxed();
     assert_eq!(Poll::Ready(None), s.poll_next_unpin(cx));
-}
+}*/
 
-#[test]
+/*#[test]
 fn try_skip_while_after_err() {
     let cx = &mut noop_context();
     let mut s = stream::iter(1..=3)
@@ -26,9 +26,9 @@ fn try_skip_while_after_err() {
         .filter_map(|r| async move { r.ok() })
         .boxed();
     assert_eq!(Poll::Ready(None), s.poll_next_unpin(cx));
-}
+}*/
 
-#[test]
+/*#[test]
 fn try_take_while_after_err() {
     let cx = &mut noop_context();
     let mut s = stream::iter(1..=3)
@@ -37,4 +37,4 @@ fn try_take_while_after_err() {
         .filter_map(|r| async move { r.ok() })
         .boxed();
     assert_eq!(Poll::Ready(None), s.poll_next_unpin(cx));
-}
+}*/
Index: futures/tests/stream_unfold.rs
===================================================================
--- futures.orig/tests/stream_unfold.rs
+++ futures/tests/stream_unfold.rs
@@ -1,9 +1,9 @@
 use futures::future;
 use futures::stream;
-use futures_test::future::FutureTestExt;
-use futures_test::{assert_stream_done, assert_stream_next, assert_stream_pending};
+//use futures_test::future::FutureTestExt;
+//use futures_test::{assert_stream_done, assert_stream_next, assert_stream_pending};
 
-#[test]
+/*#[test]
 fn unfold1() {
     let mut stream = stream::unfold(0, |state| {
         if state <= 2 {
@@ -29,4 +29,4 @@ fn unfold1() {
     // No more items
     assert_stream_pending!(stream);
     assert_stream_done!(stream);
-}
+}*/
Index: futures/tests/test_macro.rs
===================================================================
--- futures.orig/tests/test_macro.rs
+++ futures/tests/test_macro.rs
@@ -1,4 +1,4 @@
-#[futures_test::test]
+/*#[futures_test::test]
 async fn it_works() {
     let fut = async { true };
     assert!(fut.await);
@@ -18,3 +18,4 @@ async fn it_is_being_run() {
 async fn return_ty() -> Result<(), ()> {
     Ok(())
 }
+*/
Index: futures/tests/io_buf_reader.rs
===================================================================
--- futures.orig/tests/io_buf_reader.rs
+++ futures/tests/io_buf_reader.rs
@@ -6,21 +6,21 @@ use futures::io::{
 };
 use futures::pin_mut;
 use futures::task::{Context, Poll};
-use futures_test::task::noop_context;
+//use futures_test::task::noop_context;
 use pin_project::pin_project;
 use std::cmp;
 use std::io;
 use std::pin::Pin;
 
 // helper for maybe_pending_* tests
-fn run<F: Future + Unpin>(mut f: F) -> F::Output {
+/*fn run<F: Future + Unpin>(mut f: F) -> F::Output {
     let mut cx = noop_context();
     loop {
         if let Poll::Ready(x) = f.poll_unpin(&mut cx) {
             return x;
         }
     }
-}
+}*/
 
 // https://github.com/rust-lang/futures-rs/pull/2489#discussion_r697865719
 #[pin_project(!Unpin)]
@@ -310,7 +310,7 @@ fn test_short_reads() {
     });
 }
 
-#[test]
+/*#[test]
 fn maybe_pending() {
     let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];
     let mut reader = BufReader::with_capacity(2, MaybePending::new(inner));
@@ -345,9 +345,9 @@ fn maybe_pending() {
     assert_eq!(reader.buffer(), []);
 
     assert_eq!(run(reader.read(&mut buf)).unwrap(), 0);
-}
+}*/
 
-#[test]
+/*#[test]
 fn maybe_pending_buf_read() {
     let inner = MaybePending::new(&[0, 1, 2, 3, 1, 0]);
     let mut reader = BufReader::with_capacity(2, inner);
@@ -363,10 +363,10 @@ fn maybe_pending_buf_read() {
     v.clear();
     run(reader.read_until(9, &mut v)).unwrap();
     assert_eq!(v, []);
-}
+}*/
 
 // https://github.com/rust-lang/futures-rs/pull/1573#discussion_r281162309
-#[test]
+/*#[test]
 fn maybe_pending_seek() {
     #[pin_project]
     struct MaybePendingSeek<'a> {
@@ -429,4 +429,4 @@ fn maybe_pending_seek() {
     assert_eq!(run(reader.as_mut().fill_buf()).ok(), Some(&[1, 2][..]));
     Pin::new(&mut reader).consume(1);
     assert_eq!(run(reader.seek(SeekFrom::Current(-2))).ok(), Some(3));
-}
+}*/
