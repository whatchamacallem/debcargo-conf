--- rust-clock-steering-0.2.1.orig/src/unix.rs
+++ rust-clock-steering-0.2.1/src/unix.rs
@@ -295,8 +295,8 @@ impl UnixClock {
 
         libc::timex {
             modes,
-            esterror,
-            maxerror,
+            esterror: esterror.into(),
+            maxerror: maxerror.into(),
             ..EMPTY_TIMEX
         }
     }
@@ -308,7 +308,7 @@ impl UnixClock {
 
         let time = libc::timeval {
             tv_sec: offset.seconds,
-            tv_usec: offset.nanos as libc::suseconds_t,
+            tv_usec: offset.nanos as _,
         };
 
         libc::timex {
@@ -386,7 +386,7 @@ impl UnixClock {
         // Since Linux 2.6.26, the supplied value is clamped to the range (-32768000,
         // +32768000). In older kernels, an EINVAL error occurs if the supplied value is
         // out of range. (32768000 is 500 << 16)
-        timex.freq = frequency.clamp(-32_768_000 + 1, 32_768_000 - 1);
+        timex.freq = frequency.clamp(-32_768_000 + 1, 32_768_000 - 1).into();
 
         timex
     }
@@ -652,50 +652,12 @@ fn current_time_timeval(timespec: libc::
     Timestamp { seconds, nanos }
 }
 
-const EMPTY_TIMESPEC: libc::timespec = libc::timespec {
-    tv_sec: 0,
-    tv_nsec: 0,
-};
+const EMPTY_TIMESPEC: libc::timespec = unsafe { core::mem::zeroed() };
 
 // Libc has no good other way of obtaining this, so let's at least make our
 // functions more readable.
 #[cfg(all(target_os = "linux", target_env = "gnu"))]
-pub const EMPTY_TIMEX: libc::timex = libc::timex {
-    modes: 0,
-    offset: 0,
-    freq: 0,
-    maxerror: 0,
-    esterror: 0,
-    status: 0,
-    constant: 0,
-    precision: 0,
-    tolerance: 0,
-    time: libc::timeval {
-        tv_sec: 0,
-        tv_usec: 0,
-    },
-    tick: 0,
-    ppsfreq: 0,
-    jitter: 0,
-    shift: 0,
-    stabil: 0,
-    jitcnt: 0,
-    calcnt: 0,
-    errcnt: 0,
-    stbcnt: 0,
-    tai: 0,
-    __unused1: 0,
-    __unused2: 0,
-    __unused3: 0,
-    __unused4: 0,
-    __unused5: 0,
-    __unused6: 0,
-    __unused7: 0,
-    __unused8: 0,
-    __unused9: 0,
-    __unused10: 0,
-    __unused11: 0,
-};
+pub const EMPTY_TIMEX: libc::timex = unsafe { core::mem::zeroed() };
 
 #[cfg(all(target_os = "linux", target_env = "musl"))]
 pub const EMPTY_TIMEX: libc::timex = libc::timex {
