Index: serde-with/Cargo.toml
===================================================================
--- serde-with.orig/Cargo.toml
+++ serde-with/Cargo.toml
@@ -273,10 +273,6 @@ version = "1.0.6"
 [dev-dependencies.glob]
 version = "0.3.0"
 
-[dev-dependencies.jsonschema]
-version = "0.26.1"
-features = ["resolve-file"]
-default-features = false
 
 [dev-dependencies.mime]
 version = "0.3.16"
Index: serde-with/tests/schemars_0_8.rs
===================================================================
--- serde-with.orig/tests/schemars_0_8.rs
+++ serde-with/tests/schemars_0_8.rs
@@ -1,6 +1,6 @@
 //! Test Cases
 
-use crate::utils::{check_matches_schema, check_valid_json_schema};
+//use crate::utils::{check_matches_schema, check_valid_json_schema};
 use expect_test::expect_file;
 use schemars::JsonSchema;
 use serde::Serialize;
@@ -46,10 +46,10 @@ macro_rules! declare_snapshot_test {
             }
 
             let schema = schemars::schema_for!($name);
-            let _ = jsonschema::Validator::new(
+            /*let _ = jsonschema::Validator::new(
                 &serde_json::to_value(&schema).expect("generated schema is not valid json"),
             )
-            .expect("generated schema is not valid");
+            .expect("generated schema is not valid");*/
 
             let mut schema = serde_json::to_string_pretty(&schema)
                 .expect("schema could not be serialized");
@@ -99,7 +99,7 @@ fn schemars_basic() {
     expected.assert_eq(&schema);
 }
 
-#[test]
+/*#[test]
 fn schemars_other_cfg_attrs() {
     #[serde_as]
     #[derive(JsonSchema, Serialize)]
@@ -113,9 +113,9 @@ fn schemars_other_cfg_attrs() {
     check_matches_schema::<Test>(&json!({
         "custom": "23",
     }));
-}
+}*/
 
-#[test]
+/*#[test]
 fn schemars_custom_with() {
     #[serde_as]
     #[derive(JsonSchema, Serialize)]
@@ -138,7 +138,7 @@ fn schemars_custom_with() {
         "with_disabled": "5",
         "always_enabled": 7,
     }));
-}
+}*/
 
 #[test]
 fn schemars_deserialize_only_bug_735() {
@@ -206,11 +206,11 @@ fn schemars_custom_schema_with() {
         always_enabled: i32,
     }
 
-    check_matches_schema::<Test>(&json!({
+    /* check_matches_schema::<Test>(&json!({
         "custom": 3,
         "with_disabled": "5",
         "always_enabled": 7,
-    }));
+    })); */
 }
 
 mod test_std {
@@ -469,10 +469,10 @@ mod derive {
         field: u32,
     }
 
-    #[test]
+    /*#[test]
     fn test_enabled_has_correct_schema() {
         check_valid_json_schema(&Enabled { field: 77 });
-    }
+    }*/
 }
 
 mod array {
@@ -485,7 +485,7 @@ mod array {
         array: [u32; 3],
     }
 
-    #[test]
+    /* #[test]
     fn test_serialized_is_valid() {
         let array = FixedArray { array: [1, 2, 3] };
 
@@ -528,7 +528,7 @@ mod array {
         check_matches_schema::<FixedArray>(&json!({
             "array": [-1, 0x1_0000_0000i64, 32]
         }));
-    }
+    }*/
 }
 
 mod bool_from_int {
@@ -549,7 +549,7 @@ mod bool_from_int {
         value: bool,
     }
 
-    #[test]
+    /* #[test]
     fn test_serialized_strict_is_valid() {
         check_valid_json_schema(&vec![
             BoolStrict { value: true },
@@ -563,9 +563,9 @@ mod bool_from_int {
             BoolFlexible { value: true },
             BoolFlexible { value: false },
         ]);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     #[should_panic]
     fn strict_out_of_range() {
         check_matches_schema::<BoolStrict>(&json!({
@@ -602,7 +602,7 @@ mod bool_from_int {
         check_matches_schema::<BoolFlexible>(&json!({
             "value": 0.5
         }));
-    }
+    }*/
 }
 
 mod bytes_or_string {
@@ -615,7 +615,7 @@ mod bytes_or_string {
         bytes: Vec<u8>,
     }
 
-    #[test]
+    /* #[test]
     fn test_serialized_is_valid() {
         check_valid_json_schema(&Test {
             bytes: b"test".to_vec(),
@@ -642,7 +642,7 @@ mod bytes_or_string {
         check_matches_schema::<Test>(&json!({
             "bytes": 5
         }));
-    }
+    }*/
 }
 
 mod enum_map {
@@ -666,7 +666,7 @@ mod enum_map {
     #[serde(transparent)]
     struct Outer(#[serde_as(as = "EnumMap")] Vec<Inner>);
 
-    #[test]
+    /*#[test]
     fn test_serialized_is_valid() {
         check_valid_json_schema(&Outer(vec![
             Inner::A(5),
@@ -676,9 +676,9 @@ mod enum_map {
                 d: -34.0,
             }),
         ]));
-    }
+    }*/
 
-    #[test]
+    /* #[test]
     fn test_matches_expected() {
         check_matches_schema::<Outer>(&json!({
             "A": 75,
@@ -688,9 +688,9 @@ mod enum_map {
                 "d": 777
             }
         }));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_no_fields_required() {
         check_matches_schema::<Outer>(&json!({}));
     }
@@ -702,15 +702,15 @@ mod enum_map {
             "A": "b",
             "B": 5
         }));
-    }
+    }*/
 
-    #[test]
+    /* #[test]
     #[should_panic]
     fn test_invalid_key() {
         check_matches_schema::<Outer>(&json!({
             "invalid": 4
         }));
-    }
+    }*/
 }
 
 mod duration {
@@ -740,7 +740,7 @@ mod duration {
         flexible_str: Duration,
     }
 
-    #[test]
+    /*#[test]
     fn test_serialized_is_valid() {
         check_valid_json_schema(&DurationTest {
             strict_u64: Duration::from_millis(2500),
@@ -750,9 +750,9 @@ mod duration {
             flexible_f64: Duration::from_millis(2500),
             flexible_str: Duration::from_millis(2500),
         });
-    }
+    }*/
 
-    #[serde_as]
+    /*#[serde_as]
     #[derive(Serialize, JsonSchema)]
     struct FlexibleU64Duration(#[serde_as(as = "DurationSeconds<u64, Flexible>")] Duration);
 
@@ -762,9 +762,9 @@ mod duration {
 
     #[serde_as]
     #[derive(Serialize, JsonSchema)]
-    struct FlexibleTimestamp(#[serde_as(as = "TimestampSeconds<i64, Flexible>")] SystemTime);
+    struct FlexibleTimestamp(#[serde_as(as = "TimestampSeconds<i64, Flexible>")] SystemTime);*/
 
-    #[test]
+    /*#[test]
     fn test_string_as_flexible_u64() {
         check_matches_schema::<FlexibleU64Duration>(&json!("32"));
     }
@@ -814,10 +814,10 @@ mod duration {
     #[test]
     fn test_negative_string_as_flexible_timestamp() {
         check_matches_schema::<FlexibleTimestamp>(&json!("-50000"));
-    }
+    }*/
 }
 
-#[test]
+/* #[test]
 fn test_borrow_cow() {
     use std::borrow::Cow;
 
@@ -844,9 +844,9 @@ fn test_map() {
     check_valid_json_schema(&Test {
         map: [("a", 1), ("b", 2)],
     });
-}
+}*/
 
-#[test]
+/*#[test]
 fn test_if_is_human_readable() {
     #[serde_as]
     #[derive(Serialize, JsonSchema)]
@@ -871,9 +871,9 @@ fn test_set_last_value_wins_with_duplica
     check_matches_schema::<Test>(&json!({
         "set": [ 1, 2, 3, 1, 4, 2 ]
     }));
-}
+}*/
 
-#[test]
+/*#[test]
 #[should_panic]
 fn test_set_prevent_duplicates_with_duplicates() {
     #[serde_as]
@@ -886,7 +886,7 @@ fn test_set_prevent_duplicates_with_dupl
     check_matches_schema::<Test>(&json!({
         "set": [ 1, 1 ]
     }));
-}
+}*/
 
 mod key_value_map {
     use super::*;
@@ -912,7 +912,7 @@ mod key_value_map {
         B(String, i32),
     }
 
-    #[test]
+    /*#[test]
     fn test_untagged_enum() {
         let value = KVMap(vec![
             UntaggedEnum::A {
@@ -923,7 +923,7 @@ mod key_value_map {
         ]);
 
         check_valid_json_schema(&value);
-    }
+    }*/
 
     #[derive(Clone, Debug, JsonSchema, Serialize)]
     #[serde(untagged)]
@@ -936,7 +936,7 @@ mod key_value_map {
         },
     }
 
-    #[test]
+    /*#[test]
     fn test_untagged_nested_enum() {
         let value = KVMap(vec![
             UntaggedNestedEnum::Nested(UntaggedEnum::A {
@@ -961,14 +961,14 @@ mod key_value_map {
         ]);
 
         check_valid_json_schema(&value);
-    }
+    }*/
 }
 
 mod one_or_many {
     use super::*;
     use serde_with::formats::{PreferMany, PreferOne};
 
-    #[serde_as]
+    /*#[serde_as]
     #[derive(Clone, Debug, JsonSchema, Serialize)]
     #[serde(transparent)]
     struct WithPreferOne(#[serde_as(as = "OneOrMany<_, PreferOne>")] Vec<i32>);
@@ -985,9 +985,9 @@ mod one_or_many {
 
         check_valid_json_schema(&single);
         check_valid_json_schema(&multiple);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_prefer_one_matches() {
         check_matches_schema::<WithPreferOne>(&json!(7));
         check_matches_schema::<WithPreferOne>(&json!([1, 2, 3]));
@@ -1003,9 +1003,9 @@ mod one_or_many {
     #[should_panic]
     fn test_prefer_one_no_invalid_type_many() {
         check_matches_schema::<WithPreferOne>(&json!(["test", 1]));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_prefer_many() {
         let single = WithPreferMany(vec![7]);
         let multiple = WithPreferMany(vec![1, 2, 3]);
@@ -1018,16 +1018,16 @@ mod one_or_many {
     #[should_panic]
     fn test_prefer_many_no_invalid_type_one() {
         check_matches_schema::<WithPreferMany>(&json!("test"));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     #[should_panic]
     fn test_prefer_many_no_invalid_type_many() {
         check_matches_schema::<WithPreferMany>(&json!(["test", 1]));
-    }
+    }*/
 }
 
-#[test]
+/*#[test]
 fn test_pickfirst() {
     #[serde_as]
     #[derive(JsonSchema, Serialize)]
@@ -1036,4 +1036,4 @@ fn test_pickfirst() {
 
     check_matches_schema::<IntOrDisplay>(&json!(7));
     check_matches_schema::<IntOrDisplay>(&json!("17"));
-}
+}*/
Index: serde-with/tests/utils.rs
===================================================================
--- serde-with.orig/tests/utils.rs
+++ serde-with/tests/utils.rs
@@ -78,7 +78,7 @@ where
     );
 }
 
-#[track_caller]
+/*#[track_caller]
 pub fn check_matches_schema<T>(value: &serde_json::Value)
 where
     T: schemars_0_8::JsonSchema,
@@ -122,9 +122,9 @@ where
             panic!("{}", message);
         };
     }
-}
+}*/
 
-#[track_caller]
+/*#[track_caller]
 pub fn check_valid_json_schema<T>(value: &T)
 where
     T: schemars_0_8::JsonSchema + Serialize,
@@ -132,4 +132,4 @@ where
     let value = serde_json::to_value(value).expect("could not serialize T to json");
 
     check_matches_schema::<T>(&value);
-}
+}*/
