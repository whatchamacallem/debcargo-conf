From 5bf954118ea6e22cf8a97f66a05933b6705fe668 Mon Sep 17 00:00:00 2001
From: Wyatt Herkamp <wherkamp@gmail.com>
Date: Sun, 21 Apr 2024 07:41:17 -0400
Subject: [PATCH] Remove the matchers crate

taken from https://github.com/tokio-rs/tracing/pull/2945 and adapted
---

Index: tracing-subscriber/src/filter/env/field.rs
===================================================================
--- tracing-subscriber.orig/src/filter/env/field.rs
+++ tracing-subscriber/src/filter/env/field.rs
@@ -1,4 +1,3 @@
-use matchers::Pattern;
 use std::{
     cmp::Ordering,
     error::Error,
@@ -10,7 +9,8 @@ use std::{
     },
 };
 
-use super::{FieldMap, LevelFilter};
+use super::{matchers::Pattern, FieldMap, LevelFilter};
+use regex_automata::dfa::dense::BuildError;
 use tracing_core::field::{Field, Visit};
 
 #[derive(Clone, Debug, Eq, PartialEq)]
@@ -234,7 +234,7 @@ impl ValueMatch {
     /// This returns an error if the string didn't contain a valid `bool`,
     /// `u64`, `i64`, or `f64` literal, and couldn't be parsed as a regular
     /// expression.
-    fn parse_regex(s: &str) -> Result<Self, matchers::Error> {
+    fn parse_regex(s: &str) -> Result<Self, BuildError> {
         s.parse::<bool>()
             .map(ValueMatch::Bool)
             .or_else(|_| s.parse::<u64>().map(ValueMatch::U64))
@@ -279,9 +279,9 @@ impl fmt::Display for ValueMatch {
 // === impl MatchPattern ===
 
 impl FromStr for MatchPattern {
-    type Err = matchers::Error;
+    type Err = BuildError;
     fn from_str(s: &str) -> Result<Self, Self::Err> {
-        let matcher = s.parse::<Pattern>()?;
+        let matcher = Pattern::new(s)?;
         Ok(Self {
             matcher,
             pattern: s.to_owned().into(),
Index: tracing-subscriber/src/filter/env/matchers.rs
===================================================================
--- /dev/null
+++ tracing-subscriber/src/filter/env/matchers.rs
@@ -0,0 +1,93 @@
+/// Regex Matchers on characters and byte streams. This code is inspired by the [matchers](https://github.com/hawkw/matchers) crate
+/// The code was stripped down as everything was not needed and uses an updated version of regex-automata. 
+use regex_automata::dfa::dense::{BuildError, DFA};
+use regex_automata::dfa::Automaton;
+use regex_automata::util::primitives::StateID;
+use regex_automata::util::start::Config;
+use regex_automata::Anchored;
+use std::{fmt, fmt::Write};
+
+#[derive(Debug, Clone)]
+pub(crate) struct Pattern<A = DFA<Vec<u32>>> {
+    automaton: A,
+}
+
+#[derive(Debug, Clone)]
+pub(crate) struct Matcher<A = DFA<Vec<u32>>> {
+    automaton: A,
+    state: StateID,
+}
+
+impl Pattern {
+    pub(crate) fn new(pattern: &str) -> Result<Self, BuildError> {
+        let automaton = DFA::new(pattern)?;
+        Ok(Pattern { automaton })
+    }
+}
+
+impl<A: Automaton> Pattern<A> {
+    pub(crate) fn matcher(&self) -> Matcher<&'_ A> {
+        Matcher {
+            automaton: &self.automaton,
+            state: self
+                .automaton
+                .start_state(&Config::new().anchored(Anchored::Yes))
+                .unwrap(),
+        }
+    }
+
+    pub(crate) fn matches(&self, s: &impl AsRef<str>) -> bool {
+        self.matcher().matches(s)
+    }
+
+    pub(crate) fn debug_matches(&self, d: &impl fmt::Debug) -> bool {
+        self.matcher().debug_matches(d)
+    }
+}
+
+// === impl Matcher ===
+
+impl<A> Matcher<A>
+where
+    A: Automaton,
+{
+    #[inline]
+    fn advance(&mut self, input: u8) {
+        self.state = unsafe { self.automaton.next_state_unchecked(self.state, input) };
+    }
+
+    #[inline]
+    pub(crate) fn is_matched(&self) -> bool {
+        let eoi_state = self.automaton.next_eoi_state(self.state);
+        self.automaton.is_match_state(eoi_state)
+    }
+
+    /// Returns `true` if this pattern matches the formatted output of the given
+    /// type implementing `fmt::Debug`.
+    pub(crate) fn matches(mut self, s: &impl AsRef<str>) -> bool {
+        for &byte in s.as_ref().as_bytes() {
+            self.advance(byte);
+            if self.automaton.is_dead_state(self.state) {
+                return false;
+            }
+        }
+        self.is_matched()
+    }
+
+    pub(crate) fn debug_matches(mut self, d: &impl fmt::Debug) -> bool {
+        write!(&mut self, "{:?}", d).expect("matcher write impl should not fail");
+        self.is_matched()
+    }
+}
+
+impl<A: Automaton> fmt::Write for Matcher<A> {
+    fn write_str(&mut self, s: &str) -> fmt::Result {
+        for &byte in s.as_bytes() {
+            self.advance(byte);
+            if self.automaton.is_dead_state(self.state) {
+                break;
+            }
+        }
+        Ok(())
+    }
+}
Index: tracing-subscriber/src/filter/env/mod.rs
===================================================================
--- tracing-subscriber.orig/src/filter/env/mod.rs
+++ tracing-subscriber/src/filter/env/mod.rs
@@ -8,6 +8,7 @@ pub use self::{builder::Builder, directi
 mod builder;
 mod directive;
 mod field;
+mod matchers;
 
 use crate::{
     filter::LevelFilter,
Index: tracing-subscriber/Cargo.toml
===================================================================
--- tracing-subscriber.orig/Cargo.toml
+++ tracing-subscriber/Cargo.toml
@@ -75,10 +75,6 @@ features = [
 optional = true
 default-features = false
 
-[dependencies.matchers]
-version = "0.1.0"
-optional = true
-
 [dependencies.nu-ansi-term]
 version = "0.46.0"
 optional = true
@@ -101,6 +97,12 @@ features = [
 optional = true
 default-features = false
 
+[dependencies.regex-automata]
+optional = true
+version = "0.4.3"
+default-features = false
+features = ["syntax", "dfa-build", "dfa-search"]
+
 [dependencies.serde]
 version = "1.0.140"
 optional = true
@@ -202,8 +204,8 @@ default = [
     "std",
 ]
 env-filter = [
-    "matchers",
     "regex",
+    "regex-automata",
     "once_cell",
     "tracing",
     "std",
