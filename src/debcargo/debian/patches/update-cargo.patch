Index: debcargo/Cargo.toml
===================================================================
--- debcargo.orig/Cargo.toml
+++ debcargo/Cargo.toml
@@ -31,7 +31,7 @@ version = "0.12"
 version = "1.0"
 
 [dependencies.cargo]
-version = "0.63"
+version = "0.76"
 
 [dependencies.chrono]
 version = "0.4"
@@ -54,7 +54,7 @@ version = "0.2"
 version = "1"
 
 [dependencies.git2]
-version = "0.14"
+version = "0.16"
 
 [dependencies.glob]
 version = "0.3"
@@ -87,7 +87,7 @@ version = "3"
 version = "0.16"
 
 [dependencies.toml]
-version = "0.5"
+version = "0.7"
 
 [dependencies.walkdir]
 version = "2"
Index: debcargo/src/crates.rs
===================================================================
--- debcargo.orig/src/crates.rs
+++ debcargo/src/crates.rs
@@ -2,15 +2,17 @@ use anyhow::{format_err, Error};
 use cargo::{
     core::manifest::ManifestMetadata,
     core::registry::PackageRegistry,
-    core::source::MaybePackage,
     core::{
         resolver::features::CliFeatures, Dependency, EitherManifest, FeatureValue, Manifest,
-        Package, PackageId, Registry, Source, SourceId, Summary, Target, TargetKind, Workspace,
+        Package, PackageId, Registry, SourceId, Summary, Target, TargetKind, Workspace,
     },
     ops,
     ops::{PackageOpts, Packages},
-    sources::RegistrySource,
-    util::{interning::InternedString, toml::read_manifest, FileLock},
+    sources::{
+        source::{MaybePackage, QueryKind, Source},
+        RegistrySource,
+    },
+    util::{cache_lock::CacheLockMode, interning::InternedString, toml::read_manifest, FileLock},
     Config,
 };
 use filetime::{set_file_times, FileTime};
@@ -60,7 +62,7 @@ fn hash<H: Hash>(hashable: &H) -> u64 {
 }
 
 fn fetch_candidates(registry: &mut PackageRegistry, dep: &Dependency) -> Result<Vec<Summary>> {
-    let mut summaries = match registry.query_vec(dep, false) {
+    let mut summaries = match registry.query_vec(dep, QueryKind::Exact) {
         std::task::Poll::Ready(res) => res?,
         std::task::Poll::Pending => {
             registry.block_until_ready()?;
@@ -73,7 +75,7 @@ fn fetch_candidates(registry: &mut Packa
 
 pub fn invalidate_crates_io_cache() -> Result<()> {
     let config = Config::default()?;
-    let _lock = config.acquire_package_cache_lock()?;
+    let _lock = config.acquire_package_cache_lock(CacheLockMode::DownloadExclusive)?;
     let source_id = SourceId::crates_io(&config)?;
     let yanked_whitelist = HashSet::new();
     let mut r = RegistrySource::remote(source_id, &yanked_whitelist, &config)?;
@@ -125,7 +127,7 @@ impl CrateInfo {
                     let dep = Dependency::parse(crate_name, None, source_id)?;
                     let mut package_id: Option<PackageId> = None;
                     loop {
-                        match source.query(&dep, &mut |p| package_id = Some(p.package_id())) {
+                        match source.query(&dep, QueryKind::Exact, &mut |p| package_id = Some(p.package_id())) {
                             std::task::Poll::Ready(res) => {
                                 res?;
                                 break;
@@ -179,7 +181,7 @@ impl CrateInfo {
                 workspace
                     .target_dir()
                     .join("package")
-                    .open_rw(filename, &config, "crate file")?
+                    .open_rw_exclusive_create(filename, &config, "crate file")?
             };
 
             (package, crate_file)
@@ -232,7 +234,7 @@ impl CrateInfo {
             hash(&source_id).swap_bytes()
         );
         let get_package_info = |config: &Config| -> Result<_> {
-            let lock = config.acquire_package_cache_lock()?;
+            let lock = config.acquire_package_cache_lock(CacheLockMode::DownloadExclusive)?;
             let mut registry = PackageRegistry::new(config)?;
             registry.lock_patches();
             let summaries = fetch_candidates(&mut registry, dependency)?;
@@ -274,7 +276,7 @@ impl CrateInfo {
             let crate_file = config
                 .registry_cache_path()
                 .join(&registry_name)
-                .open_ro(&filename, config, &filename)?;
+                .open_ro_shared(&filename, config, &filename)?;
             Ok((package.clone(), manifest.clone(), crate_file))
         };
         // if update is false but the user never downloaded the crate then the
@@ -329,8 +331,8 @@ impl CrateInfo {
         self.package.manifest_path()
     }
 
-    pub fn rust_version(&self) -> Option<&str> {
-        self.manifest.rust_version()
+    pub fn rust_version(&self) -> Option<String> {
+        self.manifest.rust_version().map(|v| v.to_string())
     }
 
     pub fn targets(&self) -> &[Target] {
Index: debcargo/src/debian/copyright/tests.rs
===================================================================
--- debcargo.orig/src/debian/copyright/tests.rs
+++ debcargo/src/debian/copyright/tests.rs
@@ -1,11 +1,10 @@
 use super::{debian_copyright, get_licenses};
 
 use std::path::Path;
-use std::rc::Rc;
 
 use cargo::{
     core::{package::Package, SourceId},
-    util::{config::Config, toml::TomlManifest},
+    util::{config::Config, toml::schema::TomlManifest},
 };
 use toml::toml;
 
@@ -85,12 +84,11 @@ fn build_package_with_authors(authors: V
         authors = authors
         license = "AGPLv3"
     };
-    let toml_manifest: Rc<TomlManifest> =
-        Rc::new(toml::from_str(&toml::to_string(&toml).unwrap()).unwrap());
-    let source_id = SourceId::for_path(Path::new("/path/to/mypackage")).unwrap();
-    let package_root = Path::new("/path/to/mypackage");
+    let toml_manifest: TomlManifest = toml::from_str(&toml::to_string(&toml).unwrap()).unwrap();
+    let source_id = SourceId::for_path(Path::new("/")).unwrap();
+    let package_root = Path::new("/");
     let config = Config::default().unwrap();
-    let manifest = TomlManifest::to_real_manifest(&toml_manifest, source_id, package_root, &config)
+    let manifest = TomlManifest::to_real_manifest(toml_manifest, false, source_id, package_root, &config)
         .unwrap()
         .0;
     Package::new(manifest, Path::new("/path/to/manifest"))
Index: debcargo/src/debian/mod.rs
===================================================================
--- debcargo.orig/src/debian/mod.rs
+++ debcargo/src/debian/mod.rs
@@ -1172,7 +1172,7 @@ fn reduce_provides(
     (provides, features_with_deps)
 }
 
-fn rustc_dep(min_ver: &Option<&str>) -> String {
+fn rustc_dep(min_ver: &Option<String>) -> String {
     if let Some(min_ver) = min_ver {
         format!("rustc:native (>= {})", min_ver)
     } else {
@@ -1186,7 +1186,10 @@ mod test {
 
     #[test]
     fn rustc_dep_includes_minver() {
-        assert_eq!("rustc:native (>= 1.65)", rustc_dep(&Some(&"1.65")));
+        assert_eq!(
+            "rustc:native (>= 1.65)",
+            rustc_dep(&Some("1.65".to_string()))
+        );
     }
 
     #[test]
