From aa14fbb2905517c6529bd85e448ad4d9507f3a23 Mon Sep 17 00:00:00 2001
From: Jason Francis <jafrancis999@gmail.com>
Date: Tue, 8 Nov 2022 12:32:35 -0500
Subject: [PATCH] glib: support return values and catching panics in
 spawn/spawn_local

---
 glib/src/lib.rs                  |   1 +
 glib/src/main_context_futures.rs | 333 +++++++++++++++++++++++++++----
 2 files changed, 292 insertions(+), 42 deletions(-)

diff --git a/src/lib.rs b/src/lib.rs
index da582bb65e..5895802be6 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -159,6 +159,7 @@ pub use self::bridged_logging::{rust_log_handler, GlibLogger, GlibLoggerDomain,
 pub mod subclass;
 
 mod main_context_futures;
+pub use main_context_futures::{JoinError, JoinHandle};
 mod source_futures;
 pub use self::source_futures::*;
 
diff --git a/src/main_context_futures.rs b/src/main_context_futures.rs
index 35f4a7eda7..82945f8358 100644
--- a/src/main_context_futures.rs
+++ b/src/main_context_futures.rs
@@ -2,12 +2,14 @@
 
 use crate::thread_guard::ThreadGuard;
 use crate::translate::*;
+use futures_channel::oneshot;
 use futures_core::future::Future;
 use futures_core::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};
+use futures_util::FutureExt;
 use futures_task::{FutureObj, LocalFutureObj, LocalSpawn, Spawn, SpawnError};
-use std::mem;
-use std::pin::{self, Pin};
-use std::ptr;
+use std::{
+    any::Any, cell::Cell, marker::PhantomData, mem, num::NonZeroU32, panic, pin::Pin, ptr, thread,
+};
 
 use crate::MainContext;
 use crate::MainLoop;
@@ -19,16 +21,21 @@ use crate::SourceId;
 // if the non-Send Future is polled/dropped from a different thread
 // than where this was created.
 enum FutureWrapper {
-    Send(FutureObj<'static, ()>),
-    NonSend(ThreadGuard<LocalFutureObj<'static, ()>>),
+    Send(FutureObj<'static, Box<dyn Any + Send + 'static>>),
+    NonSend(ThreadGuard<LocalFutureObj<'static, Box<dyn Any + 'static>>>),
 }
 
+unsafe impl Send for FutureWrapper {}
+unsafe impl Sync for FutureWrapper {}
+
 impl Future for FutureWrapper {
-    type Output = ();
+    type Output = Box<dyn Any + 'static>;
 
-    fn poll(self: pin::Pin<&mut Self>, ctx: &mut Context) -> Poll<()> {
+    fn poll(self: Pin<&mut Self>, ctx: &mut Context<'_>) -> Poll<Self::Output> {
         match self.get_mut() {
-            FutureWrapper::Send(fut) => Pin::new(fut).poll(ctx),
+            FutureWrapper::Send(fut) => {
+                Pin::new(fut).poll(ctx).map(|b| b as Box<dyn Any + 'static>)
+            }
             FutureWrapper::NonSend(fut) => Pin::new(fut.get_mut()).poll(ctx),
         }
     }
@@ -46,6 +53,7 @@ struct TaskSource {
     source: ffi::GSource,
     future: FutureWrapper,
     waker: Waker,
+    return_tx: Option<oneshot::Sender<thread::Result<Box<dyn Any + 'static>>>>,
 }
 
 #[repr(C)]
@@ -59,7 +67,7 @@ impl TaskSource {
         callback: ffi::GSourceFunc,
         _user_data: ffi::gpointer,
     ) -> ffi::gboolean {
-        let source = &mut *(source as *mut TaskSource);
+        let source = &mut *(source as *mut Self);
         assert!(callback.is_none());
 
         // Poll the TaskSource and ensure we're never called again if the
@@ -72,7 +80,7 @@ impl TaskSource {
     }
 
     unsafe extern "C" fn finalize(source: *mut ffi::GSource) {
-        let source = source as *mut TaskSource;
+        let source = source as *mut Self;
 
         // This will panic if the future was a local future and is dropped from a different thread
         // than where it was created so try to drop it from the main context if we're on another
@@ -88,8 +96,7 @@ impl TaskSource {
                 ptr::drop_in_place(&mut (*source).future);
             }
             FutureWrapper::NonSend(ref mut future) => {
-                let context =
-                    ffi::g_source_get_context(source as *mut TaskSource as *mut ffi::GSource);
+                let context = ffi::g_source_get_context(source as *mut Self as *mut ffi::GSource);
                 if !context.is_null() {
                     let future = ptr::read(future);
                     let context = MainContext::from_glib_none(context);
@@ -158,7 +165,11 @@ unsafe impl Sync for WakerSource {}
 impl TaskSource {
     #[allow(clippy::new_ret_no_self)]
     // checker-ignore-item
-    fn new(priority: Priority, future: FutureWrapper) -> Source {
+    fn new(
+        priority: Priority,
+        future: FutureWrapper,
+        return_tx: Option<oneshot::Sender<thread::Result<Box<dyn Any + 'static>>>>,
+    ) -> Source {
         unsafe {
             static TASK_SOURCE_FUNCS: ffi::GSourceFuncs = ffi::GSourceFuncs {
                 check: None,
@@ -168,7 +179,6 @@ impl TaskSource {
                 closure_callback: None,
                 closure_marshal: None,
             };
-
             static WAKER_SOURCE_FUNCS: ffi::GSourceFuncs = ffi::GSourceFuncs {
                 check: None,
                 prepare: None,
@@ -180,7 +190,7 @@ impl TaskSource {
 
             let source = ffi::g_source_new(
                 mut_override(&TASK_SOURCE_FUNCS),
-                mem::size_of::<TaskSource>() as u32,
+                mem::size_of::<Self>() as u32,
             );
 
             let waker_source = ffi::g_source_new(
@@ -192,8 +202,9 @@ impl TaskSource {
             ffi::g_source_add_child_source(source, waker_source);
 
             {
-                let source = &mut *(source as *mut TaskSource);
+                let source = &mut *(source as *mut Self);
                 ptr::write(&mut source.future, future);
+                ptr::write(&mut source.return_tx, return_tx);
 
                 // This creates a new reference to the waker source.
                 let waker = Waker::from_raw(WakerSource::clone_raw(waker_source as *const ()));
@@ -230,19 +241,196 @@ impl TaskSource {
 
                 // This will panic if the future was a local future and is called from
                 // a different thread than where it was created.
-                Pin::new(&mut self.future).poll(&mut context)
+                if let Some(tx) = self.return_tx.take() {
+                    let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {
+                        Pin::new(&mut self.future).poll(&mut context)
+                    }));
+                    match res {
+                        Ok(Poll::Ready(res)) => {
+                            let _ = tx.send(Ok(res));
+                            Poll::Ready(())
+                        }
+                        Ok(Poll::Pending) => {
+                            self.return_tx.replace(tx);
+                            Poll::Pending
+                        }
+                        Err(e) => {
+                            let _ = tx.send(Err(e));
+                            Poll::Ready(())
+                        }
+                    }
+                } else {
+                    Pin::new(&mut self.future).poll(&mut context).map(|_| ())
+                }
             })
             .expect("current thread is not owner of the main context")
     }
 }
 
+// rustdoc-stripper-ignore-next
+/// A handle to a task running on a [`MainContext`].
+///
+/// Like [`std::thread::JoinHandle`] for a task rather than a thread. The return value from the
+/// task can be retrieved by awaiting on this object. Dropping the handle "detaches" the task,
+/// allowing it to complete but discarding the return value.
+#[derive(Debug)]
+pub struct JoinHandle<T> {
+    rx: oneshot::Receiver<std::thread::Result<Box<dyn Any + 'static>>>,
+    source: Source,
+    id: Cell<Option<NonZeroU32>>,
+    phantom: PhantomData<oneshot::Receiver<std::thread::Result<T>>>,
+}
+
+impl<T> JoinHandle<T> {
+    #[inline]
+    fn new(
+        ctx: &MainContext,
+        source: Source,
+        rx: oneshot::Receiver<std::thread::Result<Box<dyn Any + 'static>>>,
+    ) -> Self {
+        let id = source.attach(Some(ctx));
+        let id = Cell::new(Some(unsafe { NonZeroU32::new_unchecked(id.as_raw()) }));
+        Self {
+            rx,
+            source,
+            id,
+            phantom: PhantomData,
+        }
+    }
+    // rustdoc-stripper-ignore-next
+    /// Returns the internal source ID.
+    ///
+    /// Returns `None` if the handle was aborted already.
+    #[inline]
+    pub fn as_raw_source_id(&self) -> Option<u32> {
+        self.id.get().map(|i| i.get())
+    }
+    // rustdoc-stripper-ignore-next
+    /// Aborts the task associated with the handle.
+    #[inline]
+    pub fn abort(&self) {
+        self.source.destroy();
+        self.id.replace(None);
+    }
+    // rustdoc-stripper-ignore-next
+    /// Returns the [`Source`] associated with this handle.
+    #[inline]
+    pub fn source(&self) -> &Source {
+        &self.source
+    }
+    // rustdoc-stripper-ignore-next
+    /// Safely converts the handle into a [`SourceId`].
+    ///
+    /// Can be used to discard the return value while still retaining the ability to abort the
+    /// underlying task. Returns `Err(self)` if the handle was aborted already.
+    pub fn into_source_id(self) -> Result<SourceId, Self> {
+        if let Some(id) = self.id.take() {
+            Ok(unsafe { SourceId::from_glib(id.get()) })
+        } else {
+            Err(self)
+        }
+    }
+}
+
+impl<T: 'static> Future for JoinHandle<T> {
+    type Output = Result<T, JoinError>;
+    #[inline]
+    fn poll(
+        mut self: std::pin::Pin<&mut Self>,
+        cx: &mut std::task::Context<'_>,
+    ) -> std::task::Poll<Self::Output> {
+        std::pin::Pin::new(&mut self.rx).poll(cx).map(|r| match r {
+            Err(_) => Err(JoinErrorInner::Cancelled.into()),
+            Ok(Err(e)) => Err(JoinErrorInner::Panic(e).into()),
+            Ok(Ok(r)) => Ok(*r.downcast().unwrap()),
+        })
+    }
+}
+
+impl<T: 'static> futures_core::FusedFuture for JoinHandle<T> {
+    #[inline]
+    fn is_terminated(&self) -> bool {
+        self.rx.is_terminated()
+    }
+}
+
+// rustdoc-stripper-ignore-next
+/// Task failure from awaiting a [`JoinHandle`].
+#[derive(Debug)]
+pub struct JoinError(JoinErrorInner);
+
+impl JoinError {
+    // rustdoc-stripper-ignore-next
+    /// Returns `true` if the handle was cancelled.
+    #[inline]
+    pub fn is_cancelled(&self) -> bool {
+        matches!(self.0, JoinErrorInner::Cancelled)
+    }
+    // rustdoc-stripper-ignore-next
+    /// Returns `true` if the task terminated with a panic.
+    #[inline]
+    pub fn is_panic(&self) -> bool {
+        matches!(self.0, JoinErrorInner::Panic(_))
+    }
+    // rustdoc-stripper-ignore-next
+    /// Converts the error into a panic result.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the error is not a panic error. Use [`is_panic`](Self::is_panic) to check first
+    /// if the error represents a panic.
+    #[inline]
+    pub fn into_panic(self) -> Box<dyn Any + Send + 'static> {
+        self.try_into_panic()
+            .expect("`JoinError` is not a panic error")
+    }
+    // rustdoc-stripper-ignore-next
+    /// Attempts to convert the error into a panic result.
+    ///
+    /// Returns `Err(self)` if the error is not a panic result.
+    #[inline]
+    pub fn try_into_panic(self) -> Result<Box<dyn Any + Send + 'static>, Self> {
+        match self.0 {
+            JoinErrorInner::Panic(e) => Ok(e),
+            e => Err(Self(e)),
+        }
+    }
+}
+
+impl std::error::Error for JoinError {}
+
+impl std::fmt::Display for JoinError {
+    #[inline]
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        self.0.fmt(f)
+    }
+}
+
+#[derive(thiserror::Error, Debug)]
+enum JoinErrorInner {
+    #[error("task cancelled")]
+    Cancelled,
+    #[error("task panicked")]
+    Panic(Box<dyn Any + Send + 'static>),
+}
+
+impl From<JoinErrorInner> for JoinError {
+    #[inline]
+    fn from(e: JoinErrorInner) -> Self {
+        Self(e)
+    }
+}
+
 impl MainContext {
     // rustdoc-stripper-ignore-next
     /// Spawn a new infallible `Future` on the main context.
     ///
     /// This can be called from any thread and will execute the future from the thread
     /// where main context is running, e.g. via a `MainLoop`.
-    pub fn spawn<F: Future<Output = ()> + Send + 'static>(&self, f: F) -> SourceId {
+    pub fn spawn<R: Send + 'static, F: Future<Output = R> + Send + 'static>(
+        &self,
+        f: F,
+    ) -> JoinHandle<R> {
         self.spawn_with_priority(crate::PRIORITY_DEFAULT, f)
     }
 
@@ -254,7 +442,7 @@ impl MainContext {
     /// This can be called only from the thread where the main context is running, e.g.
     /// from any other `Future` that is executed on this main context, or after calling
     /// `with_thread_default` or `acquire` on the main context.
-    pub fn spawn_local<F: Future<Output = ()> + 'static>(&self, f: F) -> SourceId {
+    pub fn spawn_local<R: 'static, F: Future<Output = R> + 'static>(&self, f: F) -> JoinHandle<R> {
         self.spawn_local_with_priority(crate::PRIORITY_DEFAULT, f)
     }
 
@@ -263,14 +451,17 @@ impl MainContext {
     ///
     /// This can be called from any thread and will execute the future from the thread
     /// where main context is running, e.g. via a `MainLoop`.
-    pub fn spawn_with_priority<F: Future<Output = ()> + Send + 'static>(
+    pub fn spawn_with_priority<R: Send + 'static, F: Future<Output = R> + Send + 'static>(
         &self,
         priority: Priority,
         f: F,
-    ) -> SourceId {
-        let f = FutureObj::new(Box::new(f));
-        let source = TaskSource::new(priority, FutureWrapper::Send(f));
-        source.attach(Some(self))
+    ) -> JoinHandle<R> {
+        let f = FutureObj::new(Box::new(async move {
+            Box::new(f.await) as Box<dyn Any + Send + 'static>
+        }));
+        let (tx, rx) = oneshot::channel();
+        let source = TaskSource::new(priority, FutureWrapper::Send(f), Some(tx));
+        JoinHandle::new(self, source, rx)
     }
 
     // rustdoc-stripper-ignore-next
@@ -281,17 +472,24 @@ impl MainContext {
     /// This can be called only from the thread where the main context is running, e.g.
     /// from any other `Future` that is executed on this main context, or after calling
     /// `with_thread_default` or `acquire` on the main context.
-    pub fn spawn_local_with_priority<F: Future<Output = ()> + 'static>(
+    pub fn spawn_local_with_priority<R: 'static, F: Future<Output = R> + 'static>(
         &self,
         priority: Priority,
         f: F,
-    ) -> SourceId {
+    ) -> JoinHandle<R> {
         let _acquire = self
             .acquire()
             .expect("Spawning local futures only allowed on the thread owning the MainContext");
-        let f = LocalFutureObj::new(Box::new(f));
-        let source = TaskSource::new(priority, FutureWrapper::NonSend(ThreadGuard::new(f)));
-        source.attach(Some(self))
+        let f = LocalFutureObj::new(Box::new(async move {
+            Box::new(f.await) as Box<dyn Any + 'static>
+        }));
+        let (tx, rx) = oneshot::channel();
+        let source = TaskSource::new(
+            priority,
+            FutureWrapper::NonSend(ThreadGuard::new(f)),
+            Some(tx),
+        );
+        JoinHandle::new(self, source, rx)
     }
 
     // rustdoc-stripper-ignore-next
@@ -309,31 +507,47 @@ impl MainContext {
         let l_clone = l.clone();
 
         let f = async {
-            res = Some(f.await);
+            res = Some(panic::AssertUnwindSafe(f).catch_unwind().await);
             l_clone.quit();
         };
 
-        unsafe {
+        let f = unsafe {
             // Super-unsafe: We transmute here to get rid of the 'static lifetime
-            let f = LocalFutureObj::new(Box::new(f));
-            let f: LocalFutureObj<'static, ()> = mem::transmute(f);
+            let f = LocalFutureObj::new(Box::new(async move {
+                f.await;
+                Box::new(()) as Box<dyn Any + 'static>
+            }));
+            let f: LocalFutureObj<'static, Box<dyn Any + 'static>> = mem::transmute(f);
+            f
+        };
 
-            let source = TaskSource::new(
-                crate::PRIORITY_DEFAULT,
-                FutureWrapper::NonSend(ThreadGuard::new(f)),
-            );
-            source.attach(Some(self));
-        }
+        let source = TaskSource::new(
+            crate::PRIORITY_DEFAULT,
+            FutureWrapper::NonSend(ThreadGuard::new(f)),
+            None,
+        );
+        source.attach(Some(self));
 
         l.run();
 
-        res.unwrap()
+        match res.unwrap() {
+            Ok(v) => v,
+            Err(e) => panic::resume_unwind(e),
+        }
     }
 }
 
 impl Spawn for MainContext {
     fn spawn_obj(&self, f: FutureObj<'static, ()>) -> Result<(), SpawnError> {
-        let source = TaskSource::new(crate::PRIORITY_DEFAULT, FutureWrapper::Send(f));
+        let (tx, _) = oneshot::channel();
+        let source = TaskSource::new(
+            crate::PRIORITY_DEFAULT,
+            FutureWrapper::Send(FutureObj::new(Box::new(async move {
+                f.await;
+                Box::new(()) as Box<dyn Any + Send + 'static>
+            }))),
+            Some(tx),
+        );
         source.attach(Some(self));
         Ok(())
     }
@@ -341,9 +555,16 @@ impl Spawn for MainContext {
 
 impl LocalSpawn for MainContext {
     fn spawn_local_obj(&self, f: LocalFutureObj<'static, ()>) -> Result<(), SpawnError> {
+        let (tx, _) = oneshot::channel();
         let source = TaskSource::new(
             crate::PRIORITY_DEFAULT,
-            FutureWrapper::NonSend(ThreadGuard::new(f)),
+            FutureWrapper::NonSend(ThreadGuard::new(LocalFutureObj::new(Box::new(
+                async move {
+                    f.await;
+                    Box::new(()) as Box<dyn Any + 'static>
+                },
+            )))),
+            Some(tx),
         );
         source.attach(Some(self));
         Ok(())
@@ -425,4 +646,32 @@ mod tests {
 
         assert_eq!(v, Some(123));
     }
+
+    #[test]
+    fn test_spawn_return() {
+        let c = MainContext::new();
+        c.block_on(async {
+            let val = 1;
+            let ret = c
+                .spawn(async move { futures_util::future::ready(2).await + val })
+                .await;
+            assert_eq!(ret.unwrap(), 3);
+        });
+    }
+
+    #[test]
+    fn test_spawn_panic() {
+        let c = MainContext::new();
+        c.block_on(async {
+            let ret = c
+                .spawn(async {
+                    panic!("failed");
+                })
+                .await;
+            assert_eq!(
+                *ret.unwrap_err().into_panic().downcast::<&str>().unwrap(),
+                "failed"
+            );
+        });
+    }
 }
-- 
2.41.0

