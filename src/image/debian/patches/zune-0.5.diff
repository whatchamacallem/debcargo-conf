--- rust-image-0.25.8.orig/Cargo.toml
+++ rust-image-0.25.8/Cargo.toml
@@ -185,12 +185,14 @@ version = "0.10.3"
 optional = true
 
 [dependencies.zune-core]
-version = "0.4.12"
+#version = "0.4.12"
+version = "0.5"
 optional = true
 default-features = false
 
 [dependencies.zune-jpeg]
-version = "0.4.13"
+#version = "0.4.13"
+version = "0.5"
 optional = true
 
 [dev-dependencies.crc32fast]
--- rust-image-0.25.8.orig/src/codecs/jpeg/decoder.rs
+++ rust-image-0.25.8/src/codecs/jpeg/decoder.rs
@@ -11,2 +11,3 @@
 type ZuneColorSpace = zune_core::colorspace::ColorSpace;
+use zune_core::bytestream::ZCursor;
 
@@ -33,7 +34,7 @@ impl<R: BufRead + Seek> JpegDecoder<R> {
             .set_strict_mode(false)
             .set_max_width(usize::MAX)
             .set_max_height(usize::MAX);
-        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(input.as_slice(), options);
+        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(input.as_slice()), options);
         decoder.decode_headers().map_err(ImageError::from_jpeg)?;
         // now that we've decoded the headers we can `.unwrap()`
         // all these functions that only fail if called before decoding the headers
@@ -41,7 +42,7 @@ impl<R: BufRead + Seek> JpegDecoder<R> {
         // JPEG can only express dimensions up to 65535x65535, so this conversion cannot fail
         let width: u16 = width.try_into().unwrap();
         let height: u16 = height.try_into().unwrap();
-        let orig_color_space = decoder.get_output_colorspace().unwrap();
+        let orig_color_space = decoder.output_colorspace().unwrap();
         // Limits are disabled by default in the constructor for all decoders
         let limits = Limits::no_limits();
         Ok(JpegDecoder {
@@ -70,7 +71,7 @@ impl<R: BufRead + Seek> ImageDecoder for
             .set_strict_mode(false)
             .set_max_width(usize::MAX)
             .set_max_height(usize::MAX);
-        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(&self.input, options);
+        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(&self.input), options);
         decoder.decode_headers().map_err(ImageError::from_jpeg)?;
         Ok(decoder.icc_profile())
     }
@@ -80,7 +81,7 @@ impl<R: BufRead + Seek> ImageDecoder for
             .set_strict_mode(false)
             .set_max_width(usize::MAX)
             .set_max_height(usize::MAX);
-        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(&self.input, options);
+        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(&self.input), options);
         decoder.decode_headers().map_err(ImageError::from_jpeg)?;
         let exif = decoder.exif().cloned();
 
@@ -164,7 +165,7 @@ fn new_zune_decoder(
     input: &[u8],
     orig_color_space: ZuneColorSpace,
     limits: Limits,
-) -> zune_jpeg::JpegDecoder<&[u8]> {
+) -> zune_jpeg::JpegDecoder<ZCursor<&[u8]>> {
     let target_color_space = to_supported_color_space(orig_color_space);
     let mut options = zune_core::options::DecoderOptions::default()
         .jpeg_set_out_colorspace(target_color_space)
@@ -177,7 +178,7 @@ fn new_zune_decoder(
         Some(max_height) => max_height as usize, // u32 to usize never truncates
         None => usize::MAX,
     });
-    zune_jpeg::JpegDecoder::new_with_options(input, options)
+    zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(input), options)
 }
 
 impl ImageError {
