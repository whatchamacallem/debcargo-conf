--- a/Cargo.toml
+++ b/Cargo.toml
@@ -185,12 +185,12 @@ version = "0.10.3"
 optional = true
 
 [dependencies.zune-core]
-version = "0.4.12"
+version = "0.5.0"
 optional = true
 default-features = false
 
 [dependencies.zune-jpeg]
-version = "0.4.13"
+version = "0.5.5"
 optional = true
 
 [dev-dependencies.crc32fast]
--- a/src/codecs/jpeg/decoder.rs
+++ b/src/codecs/jpeg/decoder.rs
@@ -1,6 +1,8 @@
 use std::io::{BufRead, Seek};
 use std::marker::PhantomData;
 
+use zune_core::bytestream::ZCursor;
+
 use crate::color::ColorType;
 use crate::error::{
     DecodingError, ImageError, ImageResult, LimitError, UnsupportedError, UnsupportedErrorKind,
@@ -33,7 +35,8 @@ impl<R: BufRead + Seek> JpegDecoder<R> {
             .set_strict_mode(false)
             .set_max_width(usize::MAX)
             .set_max_height(usize::MAX);
-        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(input.as_slice(), options);
+        let mut decoder =
+            zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(input.as_slice()), options);
         decoder.decode_headers().map_err(ImageError::from_jpeg)?;
         // now that we've decoded the headers we can `.unwrap()`
         // all these functions that only fail if called before decoding the headers
@@ -41,7 +44,23 @@ impl<R: BufRead + Seek> JpegDecoder<R> {
         // JPEG can only express dimensions up to 65535x65535, so this conversion cannot fail
         let width: u16 = width.try_into().unwrap();
         let height: u16 = height.try_into().unwrap();
-        let orig_color_space = decoder.get_output_colorspace().unwrap();
+        let orig_color_space = decoder.output_colorspace().unwrap();
+        let orig_color_space = decoder.input_colorspace().expect("headers were decoded");
+
+        // Now configure the decoder color output.
+        decoder.set_options({
+            let requested_color = match orig_color_space {
+                ZuneColorSpace::RGB
+                | ZuneColorSpace::RGBA
+                | ZuneColorSpace::Luma
+                | ZuneColorSpace::LumaA => orig_color_space,
+                // Late failure
+                _ => ZuneColorSpace::RGB,
+            };
+
+            decoder.options().jpeg_set_out_colorspace(requested_color)
+        });
+
         // Limits are disabled by default in the constructor for all decoders
         let limits = Limits::no_limits();
         Ok(JpegDecoder {
@@ -70,7 +73,8 @@ impl<R: BufRead + Seek> ImageDecoder for JpegDecoder<R> {
             .set_strict_mode(false)
             .set_max_width(usize::MAX)
             .set_max_height(usize::MAX);
-        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(&self.input, options);
+        let mut decoder =
+            zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(&self.input), options);
         decoder.decode_headers().map_err(ImageError::from_jpeg)?;
         Ok(decoder.icc_profile())
     }
@@ -80,7 +84,8 @@ impl<R: BufRead + Seek> ImageDecoder for JpegDecoder<R> {
             .set_strict_mode(false)
             .set_max_width(usize::MAX)
             .set_max_height(usize::MAX);
-        let mut decoder = zune_jpeg::JpegDecoder::new_with_options(&self.input, options);
+        let mut decoder =
+            zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(&self.input), options);
         decoder.decode_headers().map_err(ImageError::from_jpeg)?;
         let exif = decoder.exif().cloned();
 
@@ -164,7 +169,7 @@ fn new_zune_decoder(
     input: &[u8],
     orig_color_space: ZuneColorSpace,
     limits: Limits,
-) -> zune_jpeg::JpegDecoder<&[u8]> {
+) -> zune_jpeg::JpegDecoder<ZCursor<&[u8]>> {
     let target_color_space = to_supported_color_space(orig_color_space);
     let mut options = zune_core::options::DecoderOptions::default()
         .jpeg_set_out_colorspace(target_color_space)
@@ -177,7 +182,7 @@ fn new_zune_decoder(
         Some(max_height) => max_height as usize, // u32 to usize never truncates
         None => usize::MAX,
     });
-    zune_jpeg::JpegDecoder::new_with_options(input, options)
+    zune_jpeg::JpegDecoder::new_with_options(ZCursor::new(input), options)
 }
 
 impl ImageError {
