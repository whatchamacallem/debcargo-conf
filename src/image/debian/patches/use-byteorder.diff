--- a/Cargo.toml
+++ b/Cargo.toml
@@ -86,8 +86,8 @@
 version = "1.8.0"
 features = ["extern_crate_alloc"]
 
-[dependencies.byteorder-lite]
-version = "0.1.0"
+[dependencies.byteorder]
+version = "1.5"
 
 [dependencies.color_quant]
 version = "1.1"
--- a/src/codecs/bmp/decoder.rs
+++ b/src/codecs/bmp/decoder.rs
@@ -4,7 +4,7 @@
 use std::slice::ChunksMut;
 use std::{error, fmt};
 
-use byteorder_lite::{LittleEndian, ReadBytesExt};
+use byteorder::{LittleEndian, ReadBytesExt};
 
 use crate::color::ColorType;
 use crate::error::{
--- a/src/codecs/bmp/encoder.rs
+++ b/src/codecs/bmp/encoder.rs
@@ -1,4 +1,4 @@
-use byteorder_lite::{LittleEndian, WriteBytesExt};
+use byteorder::{LittleEndian, WriteBytesExt};
 use std::io::{self, Write};
 
 use crate::error::{
--- a/src/codecs/dds.rs
+++ b/src/codecs/dds.rs
@@ -8,7 +8,7 @@
 use std::io::Read;
 use std::{error, fmt};
 
-use byteorder_lite::{LittleEndian, ReadBytesExt};
+use byteorder::{LittleEndian, ReadBytesExt};
 
 #[allow(deprecated)]
 use crate::codecs::dxt::{DxtDecoder, DxtVariant};
--- a/src/codecs/farbfeld.rs
+++ b/src/codecs/farbfeld.rs
@@ -315,7 +315,7 @@
 mod tests {
     use crate::codecs::farbfeld::FarbfeldDecoder;
     use crate::ImageDecoderRect;
-    use byteorder_lite::{ByteOrder, NativeEndian};
+    use byteorder::{ByteOrder, NativeEndian};
     use std::io::{Cursor, Seek, SeekFrom};
 
     static RECTANGLE_IN: &[u8] =     b"farbfeld\
--- a/src/codecs/ico/decoder.rs
+++ b/src/codecs/ico/decoder.rs
@@ -1,4 +1,4 @@
-use byteorder_lite::{LittleEndian, ReadBytesExt};
+use byteorder::{LittleEndian, ReadBytesExt};
 use std::io::{BufRead, Read, Seek, SeekFrom};
 use std::{error, fmt};
 
--- a/src/codecs/ico/encoder.rs
+++ b/src/codecs/ico/encoder.rs
@@ -1,4 +1,4 @@
-use byteorder_lite::{LittleEndian, WriteBytesExt};
+use byteorder::{LittleEndian, WriteBytesExt};
 use std::borrow::Cow;
 use std::io::{self, Write};
 
--- a/src/codecs/png.rs
+++ b/src/codecs/png.rs
@@ -178,7 +178,7 @@
     }
 
     fn read_image(mut self, buf: &mut [u8]) -> ImageResult<()> {
-        use byteorder_lite::{BigEndian, ByteOrder, NativeEndian};
+        use byteorder::{BigEndian, ByteOrder, NativeEndian};
 
         assert_eq!(u64::try_from(buf.len()), Ok(self.total_bytes()));
         self.reader.next_frame(buf).map_err(ImageError::from_png)?;
@@ -633,7 +633,7 @@
         height: u32,
         color_type: ExtendedColorType,
     ) -> ImageResult<()> {
-        use byteorder_lite::{BigEndian, ByteOrder, NativeEndian};
+        use byteorder::{BigEndian, ByteOrder, NativeEndian};
         use ExtendedColorType::*;
 
         let expected_buffer_len = color_type.buffer_size(width, height);
--- a/src/codecs/pnm/decoder.rs
+++ b/src/codecs/pnm/decoder.rs
@@ -14,7 +14,7 @@
 use crate::image::{ImageDecoder, ImageFormat};
 use crate::utils;
 
-use byteorder_lite::{BigEndian, ByteOrder, NativeEndian};
+use byteorder::{BigEndian, ByteOrder, NativeEndian};
 
 /// All errors that can occur when attempting to parse a PNM
 #[derive(Debug, Clone)]
--- a/src/codecs/pnm/encoder.rs
+++ b/src/codecs/pnm/encoder.rs
@@ -14,7 +14,7 @@
 };
 use crate::image::{ImageEncoder, ImageFormat};
 
-use byteorder_lite::{BigEndian, WriteBytesExt};
+use byteorder::{BigEndian, WriteBytesExt};
 
 enum HeaderStrategy {
     Dynamic,
--- a/src/codecs/pnm/mod.rs
+++ b/src/codecs/pnm/mod.rs
@@ -22,7 +22,7 @@
     use super::*;
     use crate::image::ImageDecoder;
     use crate::ExtendedColorType;
-    use byteorder_lite::{ByteOrder, NativeEndian};
+    use byteorder::{ByteOrder, NativeEndian};
 
     fn execute_roundtrip_default(buffer: &[u8], width: u32, height: u32, color: ExtendedColorType) {
         let mut encoded_buffer = Vec::new();
--- a/src/codecs/tga/decoder.rs
+++ b/src/codecs/tga/decoder.rs
@@ -6,7 +6,7 @@
     },
     image::{ImageDecoder, ImageFormat},
 };
-use byteorder_lite::ReadBytesExt;
+use byteorder::ReadBytesExt;
 use std::io::{self, Read};
 
 struct ColorMap {
--- a/src/codecs/tga/header.rs
+++ b/src/codecs/tga/header.rs
@@ -1,6 +1,6 @@
 use crate::error::{UnsupportedError, UnsupportedErrorKind};
 use crate::{ExtendedColorType, ImageError, ImageFormat, ImageResult};
-use byteorder_lite::{LittleEndian, ReadBytesExt, WriteBytesExt};
+use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
 use std::io::{Read, Write};
 
 pub(crate) const ALPHA_BIT_MASK: u8 = 0b1111;
--- a/src/metadata.rs
+++ b/src/metadata.rs
@@ -2,7 +2,7 @@
 
 use std::io::{Cursor, Read};
 
-use byteorder_lite::{BigEndian, LittleEndian, ReadBytesExt};
+use byteorder::{BigEndian, LittleEndian, ReadBytesExt};
 
 /// Describes the transformations to be applied to the image.
 /// Compatible with [Exif orientation](https://web.archive.org/web/20200412005226/https://www.impulseadventure.com/photo/exif-orientation.html).
