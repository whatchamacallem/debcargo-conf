--- a/Cargo.toml
+++ b/Cargo.toml
@@ -57,11 +57,2 @@
 [features]
-avif = [
-    "dep:ravif",
-    "dep:rgb",
-]
-avif-native = [
-    "dep:mp4parse",
-    "dep:dav1d",
-]
-benchmarks = []
 bmp = []
@@ -74,3 +74,2 @@
 default-formats = [
-    "avif",
     "bmp",
@@ -105,3 +105,2 @@
 ]
-nasm = ["ravif?/asm"]
 png = ["dep:png"]
@@ -223,3 +200,2 @@
     "dep:rayon",
-    "ravif?/threading",
 ]
@@ -158,6 +158,2 @@
 
-[dependencies.dav1d]
-version = "0.10.3"
-optional = true
-
 [dependencies.exr]
@@ -177,6 +177,2 @@
 
-[dependencies.mp4parse]
-version = "0.17.0"
-optional = true
-
 [dependencies.num-traits]
@@ -185,3 +185,3 @@
 [dependencies.png]
-version = "0.18.0"
+version = "0.17.16"
 optional = true
@@ -192,6 +192,2 @@
 
-[dependencies.ravif]
-version = "0.11.12"
-optional = true
-default-features = false
 
--- a/src/codecs/png.rs
+++ b/src/codecs/png.rs
@@ -305,13 +305,8 @@ impl<R: BufRead + Seek> ApngDecoder<R> {
         if self.has_thumbnail {
             // Clone the limits so that our one-off allocation that's destroyed after this scope doesn't persist
             let mut limits = self.inner.limits.clone();
-
-            let buffer_size = self.inner.reader.output_buffer_size().ok_or_else(|| {
-                ImageError::Limits(LimitError::from_kind(LimitErrorKind::InsufficientMemory))
-            })?;
-
-            limits.reserve_usize(buffer_size)?;
-            let mut buffer = vec![0; buffer_size];
+            limits.reserve_usize(self.inner.reader.output_buffer_size())?;
+            let mut buffer = vec![0; self.inner.reader.output_buffer_size()];
             // TODO: add `png::Reader::change_limits()` and call it here
             // to also constrain the internal buffer allocations in the PNG crate
             self.inner
@@ -368,10 +363,7 @@ impl<R: BufRead + Seek> ApngDecoder<R> {
         let mut limits = self.inner.limits.clone();
 
         // Read next frame data.
-        let raw_frame_size = self.inner.reader.output_buffer_size().ok_or_else(|| {
-            ImageError::Limits(LimitError::from_kind(LimitErrorKind::InsufficientMemory))
-        })?;
-
+        let raw_frame_size = self.inner.reader.output_buffer_size();
         limits.reserve_usize(raw_frame_size)?;
         let mut buffer = vec![0; raw_frame_size];
         // TODO: add `png::Reader::change_limits()` and call it here
@@ -604,20 +596,21 @@ impl<W: Write> PngEncoder<W> {
                 ))
             }
         };
-
         let comp = match self.compression {
-            CompressionType::Default => png::Compression::Balanced,
-            CompressionType::Best => png::Compression::High,
+            CompressionType::Default => png::Compression::Default,
+            CompressionType::Best => png::Compression::Best,
             _ => png::Compression::Fast,
         };
-
-        let filter = match self.filter {
-            FilterType::NoFilter => png::Filter::NoFilter,
-            FilterType::Sub => png::Filter::Sub,
-            FilterType::Up => png::Filter::Up,
-            FilterType::Avg => png::Filter::Avg,
-            FilterType::Paeth => png::Filter::Paeth,
-            FilterType::Adaptive => png::Filter::Adaptive,
+        let (filter, adaptive_filter) = match self.filter {
+            FilterType::NoFilter => (
+                png::FilterType::NoFilter,
+                png::AdaptiveFilterType::NonAdaptive,
+            ),
+            FilterType::Sub => (png::FilterType::Sub, png::AdaptiveFilterType::NonAdaptive),
+            FilterType::Up => (png::FilterType::Up, png::AdaptiveFilterType::NonAdaptive),
+            FilterType::Avg => (png::FilterType::Avg, png::AdaptiveFilterType::NonAdaptive),
+            FilterType::Paeth => (png::FilterType::Paeth, png::AdaptiveFilterType::NonAdaptive),
+            FilterType::Adaptive => (png::FilterType::Sub, png::AdaptiveFilterType::Adaptive),
         };
 
         let mut info = png::Info::with_size(width, height);
@@ -636,6 +629,7 @@ impl<W: Write> PngEncoder<W> {
         encoder.set_depth(bits);
         encoder.set_compression(comp);
         encoder.set_filter(filter);
+        encoder.set_adaptive_filter(adaptive_filter);
         let mut writer = encoder
             .write_header()
             .map_err(|e| ImageError::IoError(e.into()))?;
