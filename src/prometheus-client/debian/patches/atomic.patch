Index: rust-prometheus-client-0.22.2/src/metrics/counter.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/src/metrics/counter.rs
+++ rust-prometheus-client-0.22.2/src/metrics/counter.rs
@@ -6,7 +6,7 @@ use crate::encoding::{EncodeMetric, Metr
 
 use super::{MetricType, TypedMetric};
 use std::marker::PhantomData;
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 use std::sync::atomic::AtomicU64;
 use std::sync::atomic::{AtomicU32, Ordering};
 use std::sync::Arc;
@@ -40,7 +40,7 @@ use std::sync::Arc;
 /// counter.inc();
 /// let _value: f64 = counter.get();
 /// ```
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 #[derive(Debug)]
 pub struct Counter<N = u64, A = AtomicU64> {
     value: Arc<A>,
@@ -48,7 +48,7 @@ pub struct Counter<N = u64, A = AtomicU6
 }
 
 /// Open Metrics [`Counter`] to measure discrete events.
-#[cfg(any(target_arch = "mips", target_arch = "powerpc"))]
+#[cfg(not(target_has_atomic = "64"))]
 #[derive(Debug)]
 pub struct Counter<N = u32, A = AtomicU32> {
     value: Arc<A>,
@@ -114,7 +114,7 @@ pub trait Atomic<N> {
     fn get(&self) -> N;
 }
 
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 impl Atomic<u64> for AtomicU64 {
     fn inc(&self) -> u64 {
         self.inc_by(1)
@@ -143,7 +143,7 @@ impl Atomic<u32> for AtomicU32 {
     }
 }
 
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 impl Atomic<f64> for AtomicU64 {
     fn inc(&self) -> f64 {
         self.inc_by(1.0)
@@ -231,7 +231,7 @@ mod tests {
         assert_eq!(1, counter.get());
     }
 
-    #[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+    #[cfg(target_has_atomic = "64")]
     #[test]
     fn f64_stored_in_atomic_u64() {
         fn prop(fs: Vec<f64>) {
Index: rust-prometheus-client-0.22.2/src/metrics/exemplar.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/src/metrics/exemplar.rs
+++ rust-prometheus-client-0.22.2/src/metrics/exemplar.rs
@@ -11,9 +11,9 @@ use super::histogram::Histogram;
 use super::{MetricType, TypedMetric};
 use parking_lot::{MappedRwLockReadGuard, RwLock, RwLockReadGuard};
 use std::collections::HashMap;
-#[cfg(any(target_arch = "mips", target_arch = "powerpc"))]
+#[cfg(not(target_has_atomic = "64"))]
 use std::sync::atomic::AtomicU32;
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 use std::sync::atomic::AtomicU64;
 use std::sync::Arc;
 
@@ -65,7 +65,7 @@ pub struct Exemplar<S, V> {
 ///         }),
 ///     );
 /// ```
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 #[derive(Debug)]
 pub struct CounterWithExemplar<S, N = u64, A = AtomicU64> {
     pub(crate) inner: Arc<RwLock<CounterWithExemplarInner<S, N, A>>>,
@@ -77,7 +77,7 @@ impl<S> TypedMetric for CounterWithExemp
 
 /// Open Metrics [`Counter`] with an [`Exemplar`] to both measure discrete
 /// events and track references to data outside of the metric set.
-#[cfg(any(target_arch = "mips", target_arch = "powerpc"))]
+#[cfg(not(target_has_atomic = "64"))]
 #[derive(Debug)]
 pub struct CounterWithExemplar<S, N = u32, A = AtomicU32> {
     pub(crate) inner: Arc<RwLock<CounterWithExemplarInner<S, N, A>>>,
Index: rust-prometheus-client-0.22.2/src/metrics/gauge.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/src/metrics/gauge.rs
+++ rust-prometheus-client-0.22.2/src/metrics/gauge.rs
@@ -7,7 +7,7 @@ use crate::encoding::{EncodeGaugeValue,
 use super::{MetricType, TypedMetric};
 use std::marker::PhantomData;
 use std::sync::atomic::{AtomicI32, AtomicU32, Ordering};
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic="64")]
 use std::sync::atomic::{AtomicI64, AtomicU64};
 use std::sync::Arc;
 
@@ -40,7 +40,7 @@ use std::sync::Arc;
 /// gauge.set(42.0);
 /// let _value: f64 = gauge.get();
 /// ```
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic = "64")]
 #[derive(Debug)]
 pub struct Gauge<N = i64, A = AtomicI64> {
     value: Arc<A>,
@@ -48,7 +48,7 @@ pub struct Gauge<N = i64, A = AtomicI64>
 }
 
 /// Open Metrics [`Gauge`] to record current measurements.
-#[cfg(any(target_arch = "mips", target_arch = "powerpc"))]
+#[cfg(not(target_has_atomic = "64"))]
 #[derive(Debug)]
 pub struct Gauge<N = i32, A = AtomicI32> {
     value: Arc<A>,
@@ -186,7 +186,7 @@ impl Atomic<u32> for AtomicU32 {
     }
 }
 
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic="64")]
 impl Atomic<i64> for AtomicI64 {
     fn inc(&self) -> i64 {
         self.inc_by(1)
@@ -213,7 +213,7 @@ impl Atomic<i64> for AtomicI64 {
     }
 }
 
-#[cfg(not(any(target_arch = "mips", target_arch = "powerpc")))]
+#[cfg(target_has_atomic="64")]
 impl Atomic<f64> for AtomicU64 {
     fn inc(&self) -> f64 {
         self.inc_by(1.0)
Index: rust-prometheus-client-0.22.2/src/encoding/text.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/src/encoding/text.rs
+++ rust-prometheus-client-0.22.2/src/encoding/text.rs
@@ -574,6 +574,7 @@ mod tests {
     use std::sync::atomic::AtomicU32;
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn encode_counter() {
         let counter: Counter = Counter::default();
         let mut registry = Registry::default();
@@ -587,6 +588,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn encode_counter_with_unit() {
         let mut registry = Registry::default();
         let counter: Counter = Counter::default();
@@ -606,6 +608,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn encode_counter_with_exemplar() {
         let mut registry = Registry::default();
 
@@ -635,6 +638,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn encode_gauge() {
         let mut registry = Registry::default();
         let gauge: Gauge = Gauge::default();
@@ -650,6 +654,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn encode_counter_family() {
         let mut registry = Registry::default();
         let family = Family::<Vec<(String, String)>, Counter>::default();
@@ -670,6 +675,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn encode_counter_family_with_prefix_with_label() {
         let mut registry = Registry::default();
         let sub_registry = registry.sub_registry_with_prefix("my_prefix");
@@ -783,6 +789,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn sub_registry_with_prefix_and_label() {
         let top_level_metric_name = "my_top_level_metric";
         let mut registry = Registry::default();
@@ -876,7 +883,7 @@ mod tests {
                 &self,
                 mut encoder: crate::encoding::DescriptorEncoder,
             ) -> Result<(), std::fmt::Error> {
-                let counter = crate::metrics::counter::ConstCounter::new(42);
+                let counter = crate::metrics::counter::ConstCounter::new(42u64);
                 let metric_encoder = encoder.encode_descriptor(
                     &self.name,
                     "some help",
Index: rust-prometheus-client-0.22.2/benches/encoding/text.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/benches/encoding/text.rs
+++ rust-prometheus-client-0.22.2/benches/encoding/text.rs
@@ -8,6 +8,13 @@ use prometheus_client::metrics::histogra
 use prometheus_client::registry::Registry;
 use std::fmt::Write;
 
+
+#[cfg(not(target_has_atomic = "64"))]
+pub fn text(c: &mut Criterion) {
+    println!("bench disabled on architectures without 64-bit atomics");
+}
+
+#[cfg(target_has_atomic = "64")]
 pub fn text(c: &mut Criterion) {
     c.bench_function("encode", |b| {
         #[derive(Clone, Hash, PartialEq, Eq, EncodeLabelSet, Debug)]
Index: rust-prometheus-client-0.22.2/benches/encoding/proto.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/benches/encoding/proto.rs
+++ rust-prometheus-client-0.22.2/benches/encoding/proto.rs
@@ -9,6 +9,12 @@ use prometheus_client::metrics::histogra
 use prometheus_client::registry::Registry;
 use prometheus_client_derive_encode::{EncodeLabelSet, EncodeLabelValue};
 
+#[cfg(not(target_has_atomic = "64"))]
+pub fn proto(c: &mut Criterion) {
+    println!("bench disabled on architectures without 64-bit atomics")
+}
+
+#[cfg(target_has_atomic = "64")]
 pub fn proto(c: &mut Criterion) {
     c.bench_function("encode", |b| {
         #[derive(Clone, Hash, PartialEq, Eq, EncodeLabelSet, Debug)]
Index: rust-prometheus-client-0.22.2/src/encoding/protobuf.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/src/encoding/protobuf.rs
+++ rust-prometheus-client-0.22.2/src/encoding/protobuf.rs
@@ -441,6 +441,7 @@ impl<'a> std::fmt::Write for LabelValueE
 }
 
 #[cfg(test)]
+#[cfg(target_has_atomic = "64")]
 mod tests {
     use super::*;
     use crate::metrics::counter::Counter;
Index: rust-prometheus-client-0.22.2/src/encoding.rs
===================================================================
--- rust-prometheus-client-0.22.2.orig/src/encoding.rs
+++ rust-prometheus-client-0.22.2/src/encoding.rs
@@ -612,6 +612,13 @@ impl EncodeCounterValue for u64 {
     }
 }
 
+#[cfg(not(target_has_atomic = "64"))]
+impl EncodeCounterValue for u32 {
+    fn encode(&self, encoder: &mut CounterValueEncoder) -> Result<(), std::fmt::Error> {
+        encoder.encode_u64(*self as u64)
+    }
+}
+
 impl EncodeCounterValue for f64 {
     fn encode(&self, encoder: &mut CounterValueEncoder) -> Result<(), std::fmt::Error> {
         encoder.encode_f64(*self)
