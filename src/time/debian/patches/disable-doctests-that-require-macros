Index: time/src/date.rs
===================================================================
--- time.orig/src/date.rs
+++ time/src/date.rs
@@ -175,7 +175,7 @@ impl Date {
     /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is
     /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Date, macros::date};
     /// assert_eq!(Date::from_julian_day(0), Ok(date!(-4713 - 11 - 24)));
     /// assert_eq!(Date::from_julian_day(2_451_545), Ok(date!(2000 - 01 - 01)));
@@ -230,7 +230,7 @@ impl Date {
     // region: getters
     /// Get the year of the date.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).year(), 2019);
     /// assert_eq!(date!(2019 - 12 - 31).year(), 2019);
@@ -242,7 +242,7 @@ impl Date {
 
     /// Get the month.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{macros::date, Month};
     /// assert_eq!(date!(2019 - 01 - 01).month(), Month::January);
     /// assert_eq!(date!(2019 - 12 - 31).month(), Month::December);
@@ -255,7 +255,7 @@ impl Date {
     ///
     /// The returned value will always be in the range `1..=31`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).day(), 1);
     /// assert_eq!(date!(2019 - 12 - 31).day(), 31);
@@ -309,7 +309,7 @@ impl Date {
     ///
     /// The returned value will always be in the range `1..=366` (`1..=365` for common years).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).ordinal(), 1);
     /// assert_eq!(date!(2019 - 12 - 31).ordinal(), 365);
@@ -333,7 +333,7 @@ impl Date {
     ///
     /// The returned value will always be in the range `1..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).iso_week(), 1);
     /// assert_eq!(date!(2019 - 10 - 04).iso_week(), 40);
@@ -349,7 +349,7 @@ impl Date {
     ///
     /// The returned value will always be in the range `0..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).sunday_based_week(), 0);
     /// assert_eq!(date!(2020 - 01 - 01).sunday_based_week(), 0);
@@ -364,7 +364,7 @@ impl Date {
     ///
     /// The returned value will always be in the range `0..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).monday_based_week(), 0);
     /// assert_eq!(date!(2020 - 01 - 01).monday_based_week(), 0);
@@ -377,7 +377,7 @@ impl Date {
 
     /// Get the year, month, and day.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{macros::date, Month};
     /// assert_eq!(
     ///     date!(2019 - 01 - 01).to_calendar_date(),
@@ -391,7 +391,7 @@ impl Date {
 
     /// Get the year and ordinal day number.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(2019 - 01 - 01).to_ordinal_date(), (2019, 1));
     /// ```
@@ -401,7 +401,7 @@ impl Date {
 
     /// Get the ISO 8601 year, week number, and weekday.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Weekday::*, macros::date};
     /// assert_eq!(date!(2019 - 01 - 01).to_iso_week_date(), (2019, 1, Tuesday));
     /// assert_eq!(date!(2019 - 10 - 04).to_iso_week_date(), (2019, 40, Friday));
@@ -428,7 +428,7 @@ impl Date {
 
     /// Get the weekday.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Weekday::*, macros::date};
     /// assert_eq!(date!(2019 - 01 - 01).weekday(), Tuesday);
     /// assert_eq!(date!(2019 - 02 - 01).weekday(), Friday);
@@ -457,7 +457,7 @@ impl Date {
 
     /// Get the next calendar date.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Date, macros::date};
     /// assert_eq!(
     ///     date!(2019 - 01 - 01).next_day(),
@@ -489,7 +489,7 @@ impl Date {
 
     /// Get the previous calendar date.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Date, macros::date};
     /// assert_eq!(
     ///     date!(2019 - 01 - 02).previous_day(),
@@ -525,7 +525,7 @@ impl Date {
     /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is
     /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert_eq!(date!(-4713 - 11 - 24).to_julian_day(), 0);
     /// assert_eq!(date!(2000 - 01 - 01).to_julian_day(), 2_451_545);
@@ -545,7 +545,7 @@ impl Date {
     // region: checked arithmetic
     /// Computes `self + duration`, returning `None` if an overflow occurred.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration, macros::date};
     /// assert_eq!(Date::MAX.checked_add(1.days()), None);
     /// assert_eq!(Date::MIN.checked_add((-2).days()), None);
@@ -559,7 +559,7 @@ impl Date {
     ///
     /// This function only takes whole days into account.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration, macros::date};
     /// assert_eq!(Date::MAX.checked_add(23.hours()), Some(Date::MAX));
     /// assert_eq!(Date::MIN.checked_add((-23).hours()), Some(Date::MIN));
@@ -588,7 +588,7 @@ impl Date {
 
     /// Computes `self - duration`, returning `None` if an overflow occurred.
     ///
-    /// ```
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration, macros::date};
     /// assert_eq!(Date::MAX.checked_sub((-2).days()), None);
     /// assert_eq!(Date::MIN.checked_sub(1.days()), None);
@@ -602,7 +602,7 @@ impl Date {
     ///
     /// This function only takes whole days into account.
     ///
-    /// ```
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration, macros::date};
     /// assert_eq!(Date::MAX.checked_sub((-23).hours()), Some(Date::MAX));
     /// assert_eq!(Date::MIN.checked_sub(23.hours()), Some(Date::MIN));
@@ -637,7 +637,7 @@ impl Date {
     /// Create a [`PrimitiveDateTime`] using the existing date. The [`Time`] component will be set
     /// to midnight.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{date, datetime};
     /// assert_eq!(date!(1970-01-01).midnight(), datetime!(1970-01-01 0:00));
     /// ```
@@ -647,7 +647,7 @@ impl Date {
 
     /// Create a [`PrimitiveDateTime`] using the existing date and the provided [`Time`].
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{date, datetime, time};
     /// assert_eq!(
     ///     date!(1970-01-01).with_time(time!(0:00)),
@@ -660,7 +660,7 @@ impl Date {
 
     /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert!(date!(1970 - 01 - 01).with_hms(0, 0, 0).is_ok());
     /// assert!(date!(1970 - 01 - 01).with_hms(24, 0, 0).is_err());
@@ -679,7 +679,7 @@ impl Date {
 
     /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert!(date!(1970 - 01 - 01).with_hms_milli(0, 0, 0, 0).is_ok());
     /// assert!(date!(1970 - 01 - 01).with_hms_milli(24, 0, 0, 0).is_err());
@@ -699,7 +699,7 @@ impl Date {
 
     /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert!(date!(1970 - 01 - 01).with_hms_micro(0, 0, 0, 0).is_ok());
     /// assert!(date!(1970 - 01 - 01).with_hms_micro(24, 0, 0, 0).is_err());
@@ -719,7 +719,7 @@ impl Date {
 
     /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::date;
     /// assert!(date!(1970 - 01 - 01).with_hms_nano(0, 0, 0, 0).is_ok());
     /// assert!(date!(1970 - 01 - 01).with_hms_nano(24, 0, 0, 0).is_err());
@@ -753,7 +753,7 @@ impl Date {
 
     /// Format the `Date` using the provided [format description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::date};
     /// let format = format_description::parse("[year]-[month]-[day]")?;
     /// assert_eq!(date!(2020 - 01 - 02).format(&format)?, "2020-01-02");
@@ -769,7 +769,7 @@ impl Date {
     /// Parse a `Date` from the input using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::date, Date};
     /// let format = format_description::parse("[year]-[month]-[day]")?;
     /// assert_eq!(Date::parse("2020-01-02", &format)?, date!(2020 - 01 - 02));
Index: time/src/offset_date_time.rs
===================================================================
--- time.orig/src/offset_date_time.rs
+++ time/src/offset_date_time.rs
@@ -38,7 +38,7 @@ pub struct OffsetDateTime {
 impl OffsetDateTime {
     /// Midnight, 1 January, 1970 (UTC).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{OffsetDateTime, macros::datetime};
     /// assert_eq!(OffsetDateTime::UNIX_EPOCH, datetime!(1970-01-01 0:00 UTC),);
     /// ```
@@ -49,7 +49,7 @@ impl OffsetDateTime {
     // region: now
     /// Create a new `OffsetDateTime` with the current date and time in UTC.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{OffsetDateTime, macros::offset};
     /// assert!(OffsetDateTime::now_utc().year() >= 2019);
     /// assert_eq!(OffsetDateTime::now_utc().offset(), offset!(UTC));
@@ -79,7 +79,7 @@ impl OffsetDateTime {
 
     /// Convert the `OffsetDateTime` from the current [`UtcOffset`] to the provided [`UtcOffset`].
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(
     ///     datetime!(2000-01-01 0:00 UTC)
@@ -109,7 +109,7 @@ impl OffsetDateTime {
     /// Create an `OffsetDateTime` from the provided Unix timestamp. Calling `.offset()` on the
     /// resulting value is guaranteed to return UTC.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{OffsetDateTime, macros::datetime};
     /// assert_eq!(
     ///     OffsetDateTime::from_unix_timestamp(0),
@@ -163,7 +163,7 @@ impl OffsetDateTime {
     /// Construct an `OffsetDateTime` from the provided Unix timestamp (in nanoseconds). Calling
     /// `.offset()` on the resulting value is guaranteed to return UTC.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{OffsetDateTime, macros::datetime};
     /// assert_eq!(
     ///     OffsetDateTime::from_unix_timestamp_nanos(0),
@@ -194,7 +194,7 @@ impl OffsetDateTime {
     // region: getters
     /// Get the [`UtcOffset`].
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).offset(), offset!(UTC));
     /// assert_eq!(datetime!(2019-01-01 0:00 +1).offset(), offset!(+1));
@@ -205,7 +205,7 @@ impl OffsetDateTime {
 
     /// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(1970-01-01 0:00 UTC).unix_timestamp(), 0);
     /// assert_eq!(datetime!(1970-01-01 0:00 -1).unix_timestamp(), 3_600);
@@ -221,7 +221,7 @@ impl OffsetDateTime {
 
     /// Get the Unix timestamp in nanoseconds.
     ///
-    /// ```rust
+    /// ```ignore
     /// use time::macros::datetime;
     /// assert_eq!(datetime!(1970-01-01 0:00 UTC).unix_timestamp_nanos(), 0);
     /// assert_eq!(
@@ -235,7 +235,7 @@ impl OffsetDateTime {
 
     /// Get the [`Date`] in the stored offset.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{date, datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).date(), date!(2019-01-01));
     /// assert_eq!(
@@ -261,7 +261,7 @@ impl OffsetDateTime {
 
     /// Get the [`Time`] in the stored offset.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset, time};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).time(), time!(0:00));
     /// assert_eq!(
@@ -290,7 +290,7 @@ impl OffsetDateTime {
     // region: date getters
     /// Get the year of the date in the stored offset.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).year(), 2019);
     /// assert_eq!(
@@ -317,7 +317,7 @@ impl OffsetDateTime {
 
     /// Get the month of the date in the stored offset.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::Month;
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).month(), Month::January);
@@ -336,7 +336,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `1..=31`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).day(), 1);
     /// assert_eq!(
@@ -354,7 +354,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `1..=366`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).ordinal(), 1);
     /// assert_eq!(
@@ -382,7 +382,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `1..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).iso_week(), 1);
     /// assert_eq!(datetime!(2020-01-01 0:00 UTC).iso_week(), 1);
@@ -397,7 +397,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).sunday_based_week(), 0);
     /// assert_eq!(datetime!(2020-01-01 0:00 UTC).sunday_based_week(), 0);
@@ -412,7 +412,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).monday_based_week(), 0);
     /// assert_eq!(datetime!(2020-01-01 0:00 UTC).monday_based_week(), 0);
@@ -425,7 +425,7 @@ impl OffsetDateTime {
 
     /// Get the year, month, and day.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{macros::datetime, Month};
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00 UTC).to_calendar_date(),
@@ -438,7 +438,7 @@ impl OffsetDateTime {
 
     /// Get the year and ordinal day number.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00 UTC).to_ordinal_date(),
@@ -451,7 +451,7 @@ impl OffsetDateTime {
 
     /// Get the ISO 8601 year, week number, and weekday.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Weekday::*, macros::datetime};
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00 UTC).to_iso_week_date(),
@@ -480,7 +480,7 @@ impl OffsetDateTime {
 
     /// Get the weekday of the date in the stored offset.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Weekday::*, macros::datetime};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).weekday(), Tuesday);
     /// assert_eq!(datetime!(2019-02-01 0:00 UTC).weekday(), Friday);
@@ -495,7 +495,7 @@ impl OffsetDateTime {
     /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is
     /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(-4713-11-24 0:00 UTC).to_julian_day(), 0);
     /// assert_eq!(datetime!(2000-01-01 0:00 UTC).to_julian_day(), 2_451_545);
@@ -510,7 +510,7 @@ impl OffsetDateTime {
     // region: time getters
     /// Get the clock hour, minute, and second.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2020-01-01 0:00:00 UTC).to_hms(), (0, 0, 0));
     /// assert_eq!(datetime!(2020-01-01 23:59:59 UTC).to_hms(), (23, 59, 59));
@@ -521,7 +521,7 @@ impl OffsetDateTime {
 
     /// Get the clock hour, minute, second, and millisecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(
     ///     datetime!(2020-01-01 0:00:00 UTC).to_hms_milli(),
@@ -538,7 +538,7 @@ impl OffsetDateTime {
 
     /// Get the clock hour, minute, second, and microsecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(
     ///     datetime!(2020-01-01 0:00:00 UTC).to_hms_micro(),
@@ -555,7 +555,7 @@ impl OffsetDateTime {
 
     /// Get the clock hour, minute, second, and nanosecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(
     ///     datetime!(2020-01-01 0:00:00 UTC).to_hms_nano(),
@@ -574,7 +574,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..24`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).hour(), 0);
     /// assert_eq!(
@@ -598,7 +598,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..60`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).minute(), 0);
     /// assert_eq!(
@@ -620,7 +620,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..60`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).second(), 0);
     /// assert_eq!(
@@ -642,7 +642,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..1_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).millisecond(), 0);
     /// assert_eq!(datetime!(2019-01-01 23:59:59.999 UTC).millisecond(), 999);
@@ -655,7 +655,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..1_000_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).microsecond(), 0);
     /// assert_eq!(
@@ -671,7 +671,7 @@ impl OffsetDateTime {
     ///
     /// The returned value will always be in the range `0..1_000_000_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00 UTC).nanosecond(), 0);
     /// assert_eq!(
@@ -688,7 +688,7 @@ impl OffsetDateTime {
     // region: checked arithmetic
     /// Computes `self + duration`, returning `None` if an overflow occurred.
     ///
-    /// ```
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration};
     /// # use time::macros::{datetime, offset};
     /// let datetime = Date::MIN.midnight().assume_offset(offset!(+10:00));
@@ -709,7 +709,7 @@ impl OffsetDateTime {
 
     /// Computes `self - duration`, returning `None` if an overflow occurred.
     ///
-    /// ```
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration};
     /// # use time::macros::{datetime, offset};
     /// let datetime = Date::MIN.midnight().assume_offset(offset!(+10:00));
@@ -737,7 +737,7 @@ impl OffsetDateTime {
     /// Replace the time, which is assumed to be in the stored offset. The date and offset
     /// components are unchanged.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, time};
     /// assert_eq!(
     ///     datetime!(2020-01-01 5:00 UTC).replace_time(time!(12:00)),
@@ -763,7 +763,7 @@ impl OffsetDateTime {
     /// Replace the date, which is assumed to be in the stored offset. The time and offset
     /// components are unchanged.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, date};
     /// assert_eq!(
     ///     datetime!(2020-01-01 12:00 UTC).replace_date(date!(2020-01-30)),
@@ -785,7 +785,7 @@ impl OffsetDateTime {
     /// Replace the date and time, which are assumed to be in the stored offset. The offset
     /// component remains unchanged.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(
     ///     datetime!(2020-01-01 12:00 UTC).replace_date_time(datetime!(2020-01-30 16:00)),
@@ -803,7 +803,7 @@ impl OffsetDateTime {
 
     /// Replace the offset. The date and time components remain unchanged.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(
     ///     datetime!(2020-01-01 0:00 UTC).replace_offset(offset!(-5)),
@@ -839,7 +839,7 @@ impl OffsetDateTime {
     /// Format the `OffsetDateTime` using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::datetime};
     /// let format = format_description::parse(
     ///     "[year]-[month]-[day] [hour]:[minute]:[second] [offset_hour \
@@ -862,7 +862,7 @@ impl OffsetDateTime {
     /// Parse an `OffsetDateTime` from the input using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::datetime, OffsetDateTime};
     /// let format = format_description::parse(
     ///     "[year]-[month]-[day] [hour]:[minute]:[second] [offset_hour \
Index: time/src/primitive_date_time.rs
===================================================================
--- time.orig/src/primitive_date_time.rs
+++ time/src/primitive_date_time.rs
@@ -26,7 +26,7 @@ pub struct PrimitiveDateTime {
 impl PrimitiveDateTime {
     /// Create a new `PrimitiveDateTime` from the provided [`Date`] and [`Time`].
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{PrimitiveDateTime, macros::{date, datetime, time}};
     /// assert_eq!(
     ///     PrimitiveDateTime::new(date!(2019-01-01), time!(0:00)),
@@ -40,7 +40,7 @@ impl PrimitiveDateTime {
     // region: component getters
     /// Get the [`Date`] component of the `PrimitiveDateTime`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{date, datetime};
     /// assert_eq!(datetime!(2019-01-01 0:00).date(), date!(2019-01-01));
     /// ```
@@ -50,7 +50,7 @@ impl PrimitiveDateTime {
 
     /// Get the [`Time`] component of the `PrimitiveDateTime`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, time};
     /// assert_eq!(datetime!(2019-01-01 0:00).time(), time!(0:00));
     pub const fn time(self) -> Time {
@@ -61,7 +61,7 @@ impl PrimitiveDateTime {
     // region: date getters
     /// Get the year of the date.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).year(), 2019);
     /// assert_eq!(datetime!(2019-12-31 0:00).year(), 2019);
@@ -73,7 +73,7 @@ impl PrimitiveDateTime {
 
     /// Get the month of the date.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{macros::datetime, Month};
     /// assert_eq!(datetime!(2019-01-01 0:00).month(), Month::January);
     /// assert_eq!(datetime!(2019-12-31 0:00).month(), Month::December);
@@ -86,7 +86,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `1..=31`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).day(), 1);
     /// assert_eq!(datetime!(2019-12-31 0:00).day(), 31);
@@ -99,7 +99,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `1..=366` (`1..=365` for common years).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).ordinal(), 1);
     /// assert_eq!(datetime!(2019-12-31 0:00).ordinal(), 365);
@@ -112,7 +112,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `1..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).iso_week(), 1);
     /// assert_eq!(datetime!(2019-10-04 0:00).iso_week(), 40);
@@ -128,7 +128,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).sunday_based_week(), 0);
     /// assert_eq!(datetime!(2020-01-01 0:00).sunday_based_week(), 0);
@@ -143,7 +143,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..=53`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).monday_based_week(), 0);
     /// assert_eq!(datetime!(2020-01-01 0:00).monday_based_week(), 0);
@@ -156,7 +156,7 @@ impl PrimitiveDateTime {
 
     /// Get the year, month, and day.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{macros::datetime, Month};
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00).to_calendar_date(),
@@ -169,7 +169,7 @@ impl PrimitiveDateTime {
 
     /// Get the year and ordinal day number.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).to_ordinal_date(), (2019, 1));
     /// ```
@@ -179,7 +179,7 @@ impl PrimitiveDateTime {
 
     /// Get the ISO 8601 year, week number, and weekday.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Weekday::*, macros::datetime};
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00).to_iso_week_date(),
@@ -208,7 +208,7 @@ impl PrimitiveDateTime {
 
     /// Get the weekday.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Weekday::*, macros::datetime};
     /// assert_eq!(datetime!(2019-01-01 0:00).weekday(), Tuesday);
     /// assert_eq!(datetime!(2019-02-01 0:00).weekday(), Friday);
@@ -232,7 +232,7 @@ impl PrimitiveDateTime {
     /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is
     /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(-4713-11-24 0:00).to_julian_day(), 0);
     /// assert_eq!(datetime!(2000-01-01 0:00).to_julian_day(), 2_451_545);
@@ -247,7 +247,7 @@ impl PrimitiveDateTime {
     // region: time getters
     /// Get the clock hour, minute, and second.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms(), (0, 0, 0));
     /// assert_eq!(datetime!(2020-01-01 23:59:59).as_hms(), (23, 59, 59));
@@ -258,7 +258,7 @@ impl PrimitiveDateTime {
 
     /// Get the clock hour, minute, second, and millisecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_milli(), (0, 0, 0, 0));
     /// assert_eq!(
@@ -272,7 +272,7 @@ impl PrimitiveDateTime {
 
     /// Get the clock hour, minute, second, and microsecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_micro(), (0, 0, 0, 0));
     /// assert_eq!(
@@ -286,7 +286,7 @@ impl PrimitiveDateTime {
 
     /// Get the clock hour, minute, second, and nanosecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_nano(), (0, 0, 0, 0));
     /// assert_eq!(
@@ -302,7 +302,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..24`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).hour(), 0);
     /// assert_eq!(datetime!(2019-01-01 23:59:59).hour(), 23);
@@ -315,7 +315,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..60`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).minute(), 0);
     /// assert_eq!(datetime!(2019-01-01 23:59:59).minute(), 59);
@@ -328,7 +328,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..60`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).second(), 0);
     /// assert_eq!(datetime!(2019-01-01 23:59:59).second(), 59);
@@ -341,7 +341,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..1_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).millisecond(), 0);
     /// assert_eq!(datetime!(2019-01-01 23:59:59.999).millisecond(), 999);
@@ -354,7 +354,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..1_000_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).microsecond(), 0);
     /// assert_eq!(
@@ -370,7 +370,7 @@ impl PrimitiveDateTime {
     ///
     /// The returned value will always be in the range `0..1_000_000_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(datetime!(2019-01-01 0:00).nanosecond(), 0);
     /// assert_eq!(
@@ -387,7 +387,7 @@ impl PrimitiveDateTime {
     /// Assuming that the existing `PrimitiveDateTime` represents a moment in the provided
     /// [`UtcOffset`], return an [`OffsetDateTime`].
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, offset};
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00)
@@ -412,7 +412,7 @@ impl PrimitiveDateTime {
     /// Assuming that the existing `PrimitiveDateTime` represents a moment in UTC, return an
     /// [`OffsetDateTime`].
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::datetime;
     /// assert_eq!(
     ///     datetime!(2019-01-01 0:00).assume_utc().unix_timestamp(),
@@ -430,7 +430,7 @@ impl PrimitiveDateTime {
     // region: checked arithmetic
     /// Computes `self + duration`, returning `None` if an overflow occurred.
     ///
-    /// ```
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration};
     /// # use time::macros::datetime;
     /// let datetime = Date::MIN.midnight();
@@ -460,7 +460,7 @@ impl PrimitiveDateTime {
 
     /// Computes `self - duration`, returning `None` if an overflow occurred.
     ///
-    /// ```
+    /// ```ignore
     /// # use time::{Date, ext::NumericalDuration};
     /// # use time::macros::datetime;
     /// let datetime = Date::MIN.midnight();
@@ -495,7 +495,7 @@ impl PrimitiveDateTime {
 impl PrimitiveDateTime {
     /// Replace the time, preserving the date.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, time};
     /// assert_eq!(
     ///     datetime!(2020-01-01 17:00).replace_time(time!(5:00)),
@@ -509,7 +509,7 @@ impl PrimitiveDateTime {
 
     /// Replace the date, preserving the time.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::{datetime, date};
     /// assert_eq!(
     ///     datetime!(2020-01-01 12:00).replace_date(date!(2020-01-30)),
@@ -578,7 +578,7 @@ impl PrimitiveDateTime {
     /// Format the `PrimitiveDateTime` using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::datetime};
     /// let format = format_description::parse("[year]-[month]-[day] [hour]:[minute]:[second]")?;
     /// assert_eq!(
@@ -597,7 +597,7 @@ impl PrimitiveDateTime {
     /// Parse a `PrimitiveDateTime` from the input using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::datetime, PrimitiveDateTime};
     /// let format = format_description::parse("[year]-[month]-[day] [hour]:[minute]:[second]")?;
     /// assert_eq!(
Index: time/src/time.rs
===================================================================
--- time.orig/src/time.rs
+++ time/src/time.rs
@@ -56,7 +56,7 @@ impl fmt::Debug for Time {
 impl Time {
     /// Create a `Time` that is exactly midnight.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{Time, macros::time};
     /// assert_eq!(Time::MIDNIGHT, time!(0:00));
     /// ```
@@ -197,7 +197,7 @@ impl Time {
     // region: getters
     /// Get the clock hour, minute, and second.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).as_hms(), (0, 0, 0));
     /// assert_eq!(time!(23:59:59).as_hms(), (23, 59, 59));
@@ -208,7 +208,7 @@ impl Time {
 
     /// Get the clock hour, minute, second, and millisecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).as_hms_milli(), (0, 0, 0, 0));
     /// assert_eq!(time!(23:59:59.999).as_hms_milli(), (23, 59, 59, 999));
@@ -224,7 +224,7 @@ impl Time {
 
     /// Get the clock hour, minute, second, and microsecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).as_hms_micro(), (0, 0, 0, 0));
     /// assert_eq!(
@@ -238,7 +238,7 @@ impl Time {
 
     /// Get the clock hour, minute, second, and nanosecond.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).as_hms_nano(), (0, 0, 0, 0));
     /// assert_eq!(
@@ -254,7 +254,7 @@ impl Time {
     ///
     /// The returned value will always be in the range `0..24`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).hour(), 0);
     /// assert_eq!(time!(23:59:59).hour(), 23);
@@ -267,7 +267,7 @@ impl Time {
     ///
     /// The returned value will always be in the range `0..60`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).minute(), 0);
     /// assert_eq!(time!(23:59:59).minute(), 59);
@@ -280,7 +280,7 @@ impl Time {
     ///
     /// The returned value will always be in the range `0..60`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00:00).second(), 0);
     /// assert_eq!(time!(23:59:59).second(), 59);
@@ -293,7 +293,7 @@ impl Time {
     ///
     /// The returned value will always be in the range `0..1_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00).millisecond(), 0);
     /// assert_eq!(time!(23:59:59.999).millisecond(), 999);
@@ -306,7 +306,7 @@ impl Time {
     ///
     /// The returned value will always be in the range `0..1_000_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00).microsecond(), 0);
     /// assert_eq!(time!(23:59:59.999_999).microsecond(), 999_999);
@@ -319,7 +319,7 @@ impl Time {
     ///
     /// The returned value will always be in the range `0..1_000_000_000`.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::time;
     /// assert_eq!(time!(0:00).nanosecond(), 0);
     /// assert_eq!(time!(23:59:59.999_999_999).nanosecond(), 999_999_999);
@@ -454,7 +454,7 @@ impl Time {
 
     /// Format the `Time` using the provided [format description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::time};
     /// let format = format_description::parse("[hour]:[minute]:[second]")?;
     /// assert_eq!(time!(12:00).format(&format)?, "12:00:00");
@@ -473,7 +473,7 @@ impl Time {
     /// Parse a `Time` from the input using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::time, Time};
     /// let format = format_description::parse("[hour]:[minute]:[second]")?;
     /// assert_eq!(Time::parse("12:00:00", &format)?, time!(12:00));
@@ -519,7 +519,7 @@ impl Add<Duration> for Time {
 
     /// Add the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{ext::NumericalDuration, macros::time};
     /// assert_eq!(time!(12:00) + 2.hours(), time!(14:00));
     /// assert_eq!(time!(0:00:01) + (-2).seconds(), time!(23:59:59));
@@ -534,7 +534,7 @@ impl Add<StdDuration> for Time {
 
     /// Add the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{ext::NumericalStdDuration, macros::time};
     /// assert_eq!(time!(12:00) + 2.std_hours(), time!(14:00));
     /// assert_eq!(time!(23:59:59) + 2.std_seconds(), time!(0:00:01));
@@ -551,7 +551,7 @@ impl Sub<Duration> for Time {
 
     /// Subtract the sub-day time of the [`Duration`] from the `Time`. Wraps on overflow.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{ext::NumericalDuration, macros::time};
     /// assert_eq!(time!(14:00) - 2.hours(), time!(12:00));
     /// assert_eq!(time!(23:59:59) - (-2).seconds(), time!(0:00:01));
@@ -566,7 +566,7 @@ impl Sub<StdDuration> for Time {
 
     /// Subtract the sub-day time of the [`std::time::Duration`] from the `Time`. Wraps on overflow.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{ext::NumericalStdDuration, macros::time};
     /// assert_eq!(time!(14:00) - 2.std_hours(), time!(12:00));
     /// assert_eq!(time!(0:00:01) - 2.std_seconds(), time!(23:59:59));
@@ -584,7 +584,7 @@ impl Sub for Time {
     /// Subtract two `Time`s, returning the [`Duration`] between. This assumes both `Time`s are in
     /// the same calendar day.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{ext::NumericalDuration, macros::time};
     /// assert_eq!(time!(0:00) - time!(0:00), 0.seconds());
     /// assert_eq!(time!(1:00) - time!(0:00), 1.hours());
Index: time/src/utc_offset.rs
===================================================================
--- time.orig/src/utc_offset.rs
+++ time/src/utc_offset.rs
@@ -33,7 +33,7 @@ pub struct UtcOffset {
 impl UtcOffset {
     /// A `UtcOffset` that is UTC.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{UtcOffset, macros::offset};
     /// assert_eq!(UtcOffset::UTC, offset!(UTC));
     /// ```
@@ -109,7 +109,7 @@ impl UtcOffset {
     /// Obtain the UTC offset as its hours, minutes, and seconds. The sign of all three components
     /// will always match. A positive value indicates an offset to the east; a negative to the west.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert_eq!(offset!(+1:02:03).as_hms(), (1, 2, 3));
     /// assert_eq!(offset!(-1:02:03).as_hms(), (-1, -2, -3));
@@ -121,7 +121,7 @@ impl UtcOffset {
     /// Obtain the number of whole hours the offset is from UTC. A positive value indicates an
     /// offset to the east; a negative to the west.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert_eq!(offset!(+1:02:03).whole_hours(), 1);
     /// assert_eq!(offset!(-1:02:03).whole_hours(), -1);
@@ -133,7 +133,7 @@ impl UtcOffset {
     /// Obtain the number of whole minutes the offset is from UTC. A positive value indicates an
     /// offset to the east; a negative to the west.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert_eq!(offset!(+1:02:03).whole_minutes(), 62);
     /// assert_eq!(offset!(-1:02:03).whole_minutes(), -62);
@@ -145,7 +145,7 @@ impl UtcOffset {
     /// Obtain the number of minutes past the hour the offset is from UTC. A positive value
     /// indicates an offset to the east; a negative to the west.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert_eq!(offset!(+1:02:03).minutes_past_hour(), 2);
     /// assert_eq!(offset!(-1:02:03).minutes_past_hour(), -2);
@@ -157,7 +157,7 @@ impl UtcOffset {
     /// Obtain the number of whole seconds the offset is from UTC. A positive value indicates an
     /// offset to the east; a negative to the west.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert_eq!(offset!(+1:02:03).whole_seconds(), 3723);
     /// assert_eq!(offset!(-1:02:03).whole_seconds(), -3723);
@@ -171,7 +171,7 @@ impl UtcOffset {
     /// Obtain the number of seconds past the minute the offset is from UTC. A positive value
     /// indicates an offset to the east; a negative to the west.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert_eq!(offset!(+1:02:03).seconds_past_minute(), 3);
     /// assert_eq!(offset!(-1:02:03).seconds_past_minute(), -3);
@@ -185,7 +185,7 @@ impl UtcOffset {
     /// Check if the offset is exactly UTC.
     ///
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert!(!offset!(+1:02:03).is_utc());
     /// assert!(!offset!(-1:02:03).is_utc());
@@ -197,7 +197,7 @@ impl UtcOffset {
 
     /// Check if the offset is positive, or east of UTC.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert!(offset!(+1:02:03).is_positive());
     /// assert!(!offset!(-1:02:03).is_positive());
@@ -209,7 +209,7 @@ impl UtcOffset {
 
     /// Check if the offset is negative, or west of UTC.
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::macros::offset;
     /// assert!(!offset!(+1:02:03).is_negative());
     /// assert!(offset!(-1:02:03).is_negative());
@@ -268,7 +268,7 @@ impl UtcOffset {
 
     /// Format the `UtcOffset` using the provided [format description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::offset};
     /// let format = format_description::parse("[offset_hour sign:mandatory]:[offset_minute]")?;
     /// assert_eq!(offset!(+1).format(&format)?, "+01:00");
@@ -284,7 +284,7 @@ impl UtcOffset {
     /// Parse a `UtcOffset` from the input using the provided [format
     /// description](crate::format_description).
     ///
-    /// ```rust
+    /// ```ignore
     /// # use time::{format_description, macros::offset, UtcOffset};
     /// let format = format_description::parse("[offset_hour]:[offset_minute]")?;
     /// assert_eq!(UtcOffset::parse("-03:42", &format)?, offset!(-3:42));
