diff --git a/Cargo.toml b/Cargo.toml
index e4b943e..a418eef 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -41,8 +41,8 @@ path = "examples/cfg_config.rs"
 [[example]]
 name = "output-config"
 path = "examples/output_config.rs"
-[dependencies.ansi_term]
-version = "0.12.0"
+[dependencies.nu-ansi-term]
+version = "0.50"
 
 [dependencies.atty]
 version = "0.2"
diff --git a/examples/cfg_config.rs b/examples/cfg_config.rs
index a55fa97..f2e5949 100644
--- a/examples/cfg_config.rs
+++ b/examples/cfg_config.rs
@@ -10,7 +10,7 @@
 //! The [clap](https://crates.io/crates/clap) argument parser is used in this example, but loggerv
 //! works with any argument parser.
 
-extern crate ansi_term;
+extern crate nu_ansi_term;
 #[macro_use] extern crate log;
 extern crate loggerv;
 
@@ -22,7 +22,7 @@ fn main() {
     // but it must be enabled first using the `ansi_term::enable_ansi_support()` function. It is
     // conditionally compiled and only exists for Windows builds. To avoid build errors on
     // non-windows platforms, a cfg guard should be put in place.
-    #[cfg(windows)] ansi_term::enable_ansi_support().unwrap();
+    #[cfg(windows)] nu_ansi_term::enable_ansi_support().unwrap();
 
     // This is the correct way to determine the build profile using the `cfg` macro according to
     // this [discussion](https://users.rust-lang.org/t/conditional-compilation-for-debug-release/1098)
diff --git a/examples/compile_time_config.rs b/examples/compile_time_config.rs
index 2318f39..9832248 100644
--- a/examples/compile_time_config.rs
+++ b/examples/compile_time_config.rs
@@ -8,7 +8,7 @@
 //! The [clap](https://crates.io/crates/clap) argument parser is used in this example, but loggerv
 //! works with any argument parser.
 
-extern crate ansi_term;
+extern crate nu_ansi_term;
 #[macro_use] extern crate log;
 extern crate loggerv;
 
@@ -20,7 +20,7 @@ fn main() {
     // but it must be enabled first using the `ansi_term::enable_ansi_support()` function. It is
     // conditionally compiled and only exists for Windows builds. To avoid build errors on
     // non-windows platforms, a cfg guard should be put in place.
-    #[cfg(windows)] ansi_term::enable_ansi_support().unwrap();
+    #[cfg(windows)] nu_ansi_term::enable_ansi_support().unwrap();
 
     loggerv::Logger::new()
         .max_level(log::Level::Info)
diff --git a/examples/output_config.rs b/examples/output_config.rs
index c9801c2..ff7a959 100644
--- a/examples/output_config.rs
+++ b/examples/output_config.rs
@@ -7,7 +7,7 @@
 //! The [clap](https://crates.io/crates/clap) argument parser is used in this example, but loggerv
 //! works with any argument parser.
 
-extern crate ansi_term;
+extern crate nu_ansi_term;
 #[macro_use] extern crate log;
 extern crate loggerv;
 extern crate clap;
@@ -23,7 +23,7 @@ fn main() {
     // but it must be enabled first using the `ansi_term::enable_ansi_support()` function. It is
     // conditionally compiled and only exists for Windows builds. To avoid build errors on
     // non-windows platforms, a cfg guard should be put in place.
-    #[cfg(windows)] ansi_term::enable_ansi_support().unwrap();
+    #[cfg(windows)] nu_ansi_term::enable_ansi_support().unwrap();
 
     let args = App::new("app")
        .arg(Arg::with_name("v")
diff --git a/examples/quick.rs b/examples/quick.rs
index 8cf4052..e19478b 100644
--- a/examples/quick.rs
+++ b/examples/quick.rs
@@ -8,7 +8,7 @@
 //! The [clap](https://crates.io/crates/clap) argument parser is used in this example, but loggerv
 //! works with any argument parser.
 
-extern crate ansi_term;
+extern crate nu_ansi_term;
 #[macro_use] extern crate log;
 extern crate loggerv;
 extern crate clap;
@@ -23,7 +23,7 @@ fn main() {
     // but it must be enabled first using the `ansi_term::enable_ansi_support()` function. It is
     // conditionally compiled and only exists for Windows builds. To avoid build errors on
     // non-windows platforms, a cfg guard should be put in place.
-    #[cfg(windows)] ansi_term::enable_ansi_support().unwrap();
+    #[cfg(windows)] nu_ansi_term::enable_ansi_support().unwrap();
 
     let args = App::new("app")
        .arg(Arg::with_name("v")
diff --git a/examples/run_time_config.rs b/examples/run_time_config.rs
index da7298a..3ab297e 100644
--- a/examples/run_time_config.rs
+++ b/examples/run_time_config.rs
@@ -8,7 +8,7 @@
 //! The [clap](https://crates.io/crates/clap) argument parser is used in this example, but loggerv
 //! works with any argument parser.
 
-extern crate ansi_term;
+extern crate nu_ansi_term;
 #[macro_use] extern crate log;
 extern crate loggerv;
 extern crate clap;
@@ -20,10 +20,10 @@ fn main() {
     // colorized output on Windows 10. 
     //
     // Based on documentation for the ansi_term crate, Windows 10 supports ANSI escape characters,
-    // but it must be enabled first using the `ansi_term::enable_ansi_support()` function. It is
+    // but it must be enabled first using the `nu_ansi_term::enable_ansi_support()` function. It is
     // conditionally compiled and only exists for Windows builds. To avoid build errors on
     // non-windows platforms, a cfg guard should be put in place.
-    #[cfg(windows)] ansi_term::enable_ansi_support().unwrap();
+    #[cfg(windows)] nu_ansi_term::enable_ansi_support().unwrap();
 
     let args = App::new("app")
        .arg(Arg::with_name("v")
diff --git a/src/lib.rs b/src/lib.rs
index c2cf366..5180fda 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,5 @@
 //! A simple `io::stdout` and `io::stderr` writing `Logger` implementation from the
-//! `log` crate, using the `ansi_term` crate for colors and configured at runtime via a verbosity
+//! `log` crate, using the `nu_ansi_term` crate for colors and configured at runtime via a verbosity
 //! or at compile time with simple function calls. Designed for simple Command Line Interfaces
 //! (CLIs).
 //!
@@ -123,24 +123,24 @@
 extern crate log;
 
 extern crate atty;
-extern crate ansi_term;
+extern crate nu_ansi_term;
 
 use log::{SetLoggerError};
 use std::io::{self, Write};
-use ansi_term::Colour;
+use nu_ansi_term::Color;
 
 pub const DEFAULT_COLORS: bool = true;
-pub const DEFAULT_DEBUG_COLOR: Colour = Colour::Fixed(7); // light grey
-pub const DEFAULT_ERROR_COLOR: Colour = Colour::Fixed(9); // bright red
+pub const DEFAULT_DEBUG_COLOR: Color = Color::Fixed(7); // light grey
+pub const DEFAULT_ERROR_COLOR: Color = Color::Fixed(9); // bright red
 pub const DEFAULT_INCLUDE_LEVEL: bool = false;
 pub const DEFAULT_INCLUDE_LINE_NUMBERS: bool = false;
 pub const DEFAULT_INCLUDE_MODULE_PATH: bool = true;
-pub const DEFAULT_INFO_COLOR: Colour = Colour::Fixed(10); // bright green
+pub const DEFAULT_INFO_COLOR: Color = Color::Fixed(10); // bright green
 pub const DEFAULT_LEVEL: log::Level = log::Level::Warn;
 pub const DEFAULT_OFFSET: u64 = 1;
 pub const DEFAULT_SEPARATOR: &str = ": ";
-pub const DEFAULT_TRACE_COLOR: Colour = Colour::Fixed(8); // grey
-pub const DEFAULT_WARN_COLOR: Colour = Colour::Fixed(11); // bright yellow
+pub const DEFAULT_TRACE_COLOR: Color = Color::Fixed(8); // grey
+pub const DEFAULT_WARN_COLOR: Color = Color::Fixed(11); // bright yellow
 pub const MODULE_PATH_UNKNOWN: &str = "unknown";
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
@@ -152,7 +152,7 @@ pub enum Output {
 #[derive(Debug, Clone, Copy, PartialEq)]
 struct Level {
     output: Output,
-    color: Colour,
+    color: Color,
 }
 
 #[derive(Debug, Clone, PartialEq)]
@@ -228,21 +228,21 @@ impl Logger {
     /// ```
     /// #[macro_use] extern crate log;
     /// extern crate loggerv;
-    /// extern crate ansi_term;
+    /// extern crate nu_ansi_term;
     ///
     /// use log::Level;
-    /// use ansi_term::Colour;
+    /// use nu_ansi_term::Color;
     ///
     /// fn main() {
     ///     loggerv::Logger::new()
-    ///         .color(&Level::Error, Colour::Fixed(7))
+    ///         .color(&Level::Error, Color::Fixed(7))
     ///         .init()
     ///         .unwrap();
     ///
     ///     error!("This is printed in light grey instead of bright red");
     /// }
     /// ```
-    pub fn color(mut self, l: &log::Level, c: Colour) -> Self {
+    pub fn color(mut self, l: &log::Level, c: Color) -> Self {
         match *l {
             log::Level::Error => self.error.color = c,
             log::Level::Warn => self.warn.color = c,
@@ -740,7 +740,7 @@ impl Logger {
     }
 
     /// Gets the color to use for the log statement's tag based on level.
-    fn select_color(&self, l: &log::Level) -> Colour {
+    fn select_color(&self, l: &log::Level) -> Color {
         match *l {
             log::Level::Error => self.error.color,
             log::Level::Warn => self.warn.color,
@@ -867,7 +867,7 @@ pub fn init_quiet() -> Result<(), SetLoggerError> {
 #[cfg(test)]
 mod tests {
     use log;
-    use ansi_term::Colour;
+    use nu_ansi_term::Color;
     use super::*;
 
     #[test]
@@ -888,8 +888,8 @@ mod tests {
 
     #[test]
     fn color_works() {
-        let logger = Logger::new().color(&log::Level::Trace, Colour::Fixed(11));
-        assert_eq!(logger.trace.color, Colour::Fixed(11));
+        let logger = Logger::new().color(&log::Level::Trace, Color::Fixed(11));
+        assert_eq!(logger.trace.color, Color::Fixed(11));
     }
 
     #[test]
