only in patch2:
--- a/zstd.h
+++ b/zstd.h
@@ -1,16 +1,2 @@
-#ifdef PKG_CONFIG
-
 /* Just use installed headers */
 #include <zstd.h>
-// Don't use experimental features like zstdmt
-
-#else // #ifdef PKG_CONFIG
-
-#include "zstd/lib/zstd.h"
-
-#endif // #ifdef PKG_CONFIG
-
-
-/* This file is used to generate bindings for both headers.
- * Check update_bindings.sh to see how to use it.
- * Or use the `bindgen` feature, which will create the bindings automatically. */
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -57,16 +57,9 @@
     "runtime",
     "which-rustfmt",
 ]
-optional = true
-default-features = false
-
-[build-dependencies.cc]
-version = "1.0.45"
-features = ["parallel"]
 
 [build-dependencies.pkg-config]
 version = "0.3"
-optional = true
 
 [features]
 debug = []
--- a/build.rs
+++ b/build.rs
@@ -2,7 +2,6 @@
 use std::path::{Path, PathBuf};
 use std::{env, fs};
 
-#[cfg(feature = "bindgen")]
 fn generate_bindings(defs: Vec<&str>, headerpaths: Vec<PathBuf>) {
     let bindings = bindgen::Builder::default().header("zstd.h");
     #[cfg(feature = "zdict_builder")]
@@ -35,10 +34,6 @@
         .expect("Could not write bindings");
 }
 
-#[cfg(not(feature = "bindgen"))]
-fn generate_bindings(_: Vec<&str>, _: Vec<PathBuf>) {}
-
-#[cfg(feature = "pkg-config")]
 fn pkg_config() -> (Vec<&'static str>, Vec<PathBuf>) {
     let library = pkg_config::Config::new()
         .statik(true)
@@ -48,6 +43,7 @@
     (vec!["PKG_CONFIG"], library.include_paths)
 }
 
+/*
 #[cfg(not(feature = "pkg-config"))]
 fn pkg_config() -> (Vec<&'static str>, Vec<PathBuf>) {
     unimplemented!()
@@ -216,6 +212,7 @@
     println!("cargo:root={}", dst.display());
 }
 
+*/
 fn main() {
     let target_arch =
         std::env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();
@@ -226,21 +223,7 @@
     }
 
     // println!("cargo:rustc-link-lib=zstd");
-    let (defs, headerpaths) = if cfg!(feature = "pkg-config") {
-        pkg_config()
-    } else {
-        if !Path::new("zstd/lib").exists() {
-            panic!("Folder 'zstd/lib' does not exists. Maybe you forgot to clone the 'zstd' submodule?");
-        }
-
-        let manifest_dir = PathBuf::from(
-            env::var("CARGO_MANIFEST_DIR")
-                .expect("Manifest dir is always set by cargo"),
-        );
-
-        compile_zstd();
-        (vec![], vec![manifest_dir.join("zstd/lib")])
-    };
+    let (defs, headerpaths) = pkg_config();
 
     let includes: Vec<_> = headerpaths
         .iter()
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -13,9 +13,9 @@
 mod wasm_shim;
 
 // If running bindgen, we'll end up with the correct bindings anyway.
-#[cfg(feature = "bindgen")]
 include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
 
+/*
 // The bindings used depend on a few feature flags.
 
 // No-std (libc-based)
@@ -80,3 +80,4 @@
     not(feature = "bindgen")
 ))]
 include!("bindings_zdict_std_experimental.rs");
+*/
--- a/zdict.h
+++ b/zdict.h
@@ -1,17 +1,2 @@
-#ifdef PKG_CONFIG
-
 /* Just use installed headers */
 #include <zdict.h>
-// Don't use experimental features like zstdmt
-
-#else // #ifdef PKG_CONFIG
-
-#include "zstd/lib/zdict.h"
-
-#endif // #ifdef PKG_CONFIG
-
-
-/* This file is used to generate bindings for both headers.
- * Check update_bindings.sh to see how to use it.
- * Or use the `bindgen` feature, which will create the bindings automatically. */
-
