Index: indexmap/Cargo.toml
===================================================================
--- indexmap.orig/Cargo.toml
+++ indexmap/Cargo.toml
@@ -99,7 +99,7 @@ version = "1.0"
 default-features = false
 
 [dependencies.hashbrown]
-version = "0.15.0"
+version = ">= 0.14, < 0.16"
 default-features = false
 
 [disabled.dependencies.quickcheck]
Index: indexmap/src/map/core.rs
===================================================================
--- indexmap.orig/src/map/core.rs
+++ indexmap/src/map/core.rs
@@ -512,6 +512,25 @@ impl<K, V> IndexMapCore<K, V> {
     }
 }
 
+trait MyFrom<T>: Sized {
+    fn myfrom(value: T) -> Self;
+}
+
+impl<T> MyFrom<T> for T {
+    fn myfrom(t: T) -> T {
+        t
+    }
+}
+
+impl<T> MyFrom<Option<[T; 2]>> for [Option<T>; 2] {
+    fn myfrom(t: Option<[T; 2]>) -> [Option<T>; 2] {
+        match t {
+            Some([a,b]) => [Some(a),Some(b)],
+            None => [None,None],
+        }
+    }
+}
+
 impl<'a, K, V> RefMut<'a, K, V> {
     #[inline]
     fn new(indices: &'a mut Indices, entries: &'a mut Entries<K, V>) -> Self {
@@ -699,10 +718,11 @@ impl<'a, K, V> RefMut<'a, K, V> {
 
         // We'll get a "nice" bounds-check from indexing `entries`,
         // and then we expect to find it in the table as well.
-        match self.indices.get_many_mut(
+        let res : [Option<&mut usize>;2] = MyFrom::myfrom(self.indices.get_many_mut(
             [self.entries[a].hash.get(), self.entries[b].hash.get()],
             move |i, &x| if i == 0 { x == a } else { x == b },
-        ) {
+        ));
+        match res {
             [Some(ref_a), Some(ref_b)] => {
                 mem::swap(ref_a, ref_b);
                 self.entries.swap(a, b);
