Index: zip/Cargo.toml
===================================================================
--- zip.orig/Cargo.toml
+++ zip/Cargo.toml
@@ -37,7 +37,7 @@ name = "read_metadata"
 harness = false
 
 [dependencies.aes]
-version = "0.7.5"
+version = "0.6.0"
 optional = true
 
 [dependencies.byteorder]
Index: zip/src/aes_ctr.rs
===================================================================
--- zip.orig/src/aes_ctr.rs
+++ zip/src/aes_ctr.rs
@@ -5,7 +5,7 @@
 //! See [AesCtrZipKeyStream](./struct.AesCtrZipKeyStream.html) for more information.
 
 use aes::cipher::generic_array::GenericArray;
-use aes::{BlockEncrypt, NewBlockCipher};
+use aes::{BlockCipher, NewBlockCipher};
 use byteorder::WriteBytesExt;
 use std::{any, fmt};
 
@@ -102,7 +102,7 @@ where
 impl<C> AesCipher for AesCtrZipKeyStream<C>
 where
     C: AesKind,
-    C::Cipher: BlockEncrypt,
+    C::Cipher: BlockCipher,
 {
     /// Decrypt or encrypt `target`.
     #[inline]
@@ -150,14 +150,14 @@ fn xor(dest: &mut [u8], src: &[u8]) {
 #[cfg(test)]
 mod tests {
     use super::{Aes128, Aes192, Aes256, AesCipher, AesCtrZipKeyStream, AesKind};
-    use aes::{BlockEncrypt, NewBlockCipher};
+    use aes::{BlockCipher, NewBlockCipher};
 
     /// Checks whether `crypt_in_place` produces the correct plaintext after one use and yields the
     /// cipertext again after applying it again.
     fn roundtrip<Aes>(key: &[u8], ciphertext: &mut [u8], expected_plaintext: &[u8])
     where
         Aes: AesKind,
-        Aes::Cipher: NewBlockCipher + BlockEncrypt,
+        Aes::Cipher: NewBlockCipher + BlockCipher,
     {
         let mut key_stream = AesCtrZipKeyStream::<Aes>::new(key);
 
