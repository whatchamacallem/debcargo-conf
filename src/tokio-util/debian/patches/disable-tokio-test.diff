Index: tokio-util/Cargo.toml
===================================================================
--- tokio-util.orig/Cargo.toml
+++ tokio-util/Cargo.toml
@@ -82,9 +82,6 @@ features = ["full"]
 [dev-dependencies.tokio-stream]
 version = "0.1"
 
-[dev-dependencies.tokio-test]
-version = "0.4.0"
-
 [features]
 __docs_rs = ["futures-util"]
 codec = ["tracing"]
Index: tokio-util/src/sync/tests/loom_cancellation_token.rs
===================================================================
--- tokio-util.orig/src/sync/tests/loom_cancellation_token.rs
+++ tokio-util/src/sync/tests/loom_cancellation_token.rs
@@ -19,8 +19,8 @@ fn cancel_token() {
             token.cancel();
         });
 
-        assert_ok!(th1.join());
-        assert_ok!(th2.join());
+        assert!(th1.join().is_ok());
+        assert!(th2.join().is_ok());
     });
 }
 
@@ -48,9 +48,9 @@ fn cancel_with_child() {
             });
         });
 
-        assert_ok!(th1.join());
-        assert_ok!(th2.join());
-        assert_ok!(th3.join());
+        assert!(th1.join().is_ok());
+        assert!(th2.join().is_ok());
+        assert!(th3.join().is_ok());
     });
 }
 
@@ -73,9 +73,9 @@ fn drop_token_no_child() {
             drop(token);
         });
 
-        assert_ok!(th1.join());
-        assert_ok!(th2.join());
-        assert_ok!(th3.join());
+        assert!(th1.join().is_ok());
+        assert!(th2.join().is_ok());
+        assert!(th3.join().is_ok());
     });
 }
 
@@ -98,9 +98,9 @@ fn drop_token_with_childs() {
             drop(child_token2);
         });
 
-        assert_ok!(th1.join());
-        assert_ok!(th2.join());
-        assert_ok!(th3.join());
+        assert!(th1.join().is_ok());
+        assert!(th2.join().is_ok());
+        assert!(th3.join().is_ok());
     });
 }
 
@@ -123,9 +123,9 @@ fn drop_and_cancel_token() {
             drop(child_token);
         });
 
-        assert_ok!(th1.join());
-        assert_ok!(th2.join());
-        assert_ok!(th3.join());
+        assert!(th1.join().is_ok());
+        assert!(th2.join().is_ok());
+        assert!(th3.join().is_ok());
     });
 }
 
@@ -148,8 +148,8 @@ fn cancel_parent_and_child() {
             child_token.cancel();
         });
 
-        assert_ok!(th1.join());
-        assert_ok!(th2.join());
-        assert_ok!(th3.join());
+        assert!(th1.join().is_ok());
+        assert!(th2.join().is_ok());
+        assert!(th3.join().is_ok());
     });
 }
Index: tokio-util/tests/framed.rs
===================================================================
--- tokio-util.orig/tests/framed.rs
+++ tokio-util/tests/framed.rs
@@ -1,7 +1,7 @@
 #![warn(rust_2018_idioms)]
 
 use tokio_stream::StreamExt;
-use tokio_test::assert_ok;
+//use tokio_test::assert_ok;
 use tokio_util::codec::{Decoder, Encoder, Framed, FramedParts};
 
 use bytes::{Buf, BufMut, BytesMut};
@@ -103,8 +103,9 @@ async fn can_read_from_existing_buf() {
     parts.read_buf = BytesMut::from(&[0, 0, 0, 42][..]);
 
     let mut framed = Framed::from_parts(parts);
-    let num = assert_ok!(framed.next().await.unwrap());
-
+    let num = framed.next().await.unwrap();
+    assert!(num.is_ok());
+    let num = num.unwrap();
     assert_eq!(num, 42);
     assert_eq!(framed.codec().read_bytes, 4);
 }
@@ -115,7 +116,7 @@ async fn can_read_from_existing_buf_afte
     parts.read_buf = BytesMut::from(&[0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 84][..]);
 
     let mut framed = Framed::from_parts(parts);
-    let num = assert_ok!(framed.next().await.unwrap());
+    let num = framed.next().await.unwrap().unwrap();
 
     assert_eq!(num, 42);
     assert_eq!(framed.codec().read_bytes, 4);
@@ -123,7 +124,7 @@ async fn can_read_from_existing_buf_afte
     let mut framed = framed.map_codec(|codec| U64Codec {
         read_bytes: codec.read_bytes,
     });
-    let num = assert_ok!(framed.next().await.unwrap());
+    let num = framed.next().await.unwrap().unwrap();
 
     assert_eq!(num, 84);
     assert_eq!(framed.codec().read_bytes, 12);
Index: tokio-util/tests/framed_stream.rs
===================================================================
--- tokio-util.orig/tests/framed_stream.rs
+++ tokio-util/tests/framed_stream.rs
@@ -1,4 +1,4 @@
-use futures_core::stream::Stream;
+/*use futures_core::stream::Stream;
 use std::{io, pin::Pin};
 use tokio_test::{assert_ready, io::Builder, task};
 use tokio_util::codec::{BytesCodec, FramedRead};
@@ -35,4 +35,4 @@ async fn return_none_after_error() {
         assert!(assert_ready!(pin!(io).poll_next(cx)).is_none());
         assert_read!(pin!(io).poll_next(cx), b"more data".to_vec());
     })
-}
+}*/
Index: tokio-util/tests/time_delay_queue.rs
===================================================================
--- tokio-util.orig/tests/time_delay_queue.rs
+++ tokio-util/tests/time_delay_queue.rs
@@ -3,7 +3,7 @@
 #![cfg(feature = "full")]
 
 use tokio::time::{self, sleep, sleep_until, Duration, Instant};
-use tokio_test::{assert_pending, assert_ready, task};
+//use tokio_test::{assert_pending, assert_ready, task};
 use tokio_util::time::DelayQueue;
 
 macro_rules! poll {
@@ -12,16 +12,16 @@ macro_rules! poll {
     };
 }
 
-macro_rules! assert_ready_some {
+/*macro_rules! assert_ready_some {
     ($e:expr) => {{
         match assert_ready!($e) {
             Some(v) => v,
             None => panic!("None"),
         }
     }};
-}
+}*/
 
-#[tokio::test]
+/*#[tokio::test]
 async fn single_immediate_delay() {
     time::pause();
 
@@ -276,9 +276,9 @@ async fn repeatedly_reset_entry_inserted
 
     let entry = assert_ready!(poll!(queue));
     assert!(entry.is_none());
-}
+}*/
 
-#[tokio::test]
+/*#[tokio::test]
 async fn remove_expired_item() {
     time::pause();
 
@@ -292,13 +292,13 @@ async fn remove_expired_item() {
 
     let entry = queue.remove(&key);
     assert_eq!(entry.into_inner(), "foo");
-}
+}*/
 
 /// Regression test: it should be possible to remove entries which fall in the
 /// 0th slot of the internal timer wheel â€” that is, entries whose expiration
 /// (a) falls at the beginning of one of the wheel's hierarchical levels and (b)
 /// is equal to the wheel's current elapsed time.
-#[tokio::test]
+/*#[tokio::test]
 async fn remove_at_timer_wheel_threshold() {
     time::pause();
 
@@ -516,7 +516,7 @@ async fn insert_after_ready_poll() {
     assert_eq!("3", res[2]);
 }
 
-#[tokio::test]
+/*#[tokio::test]
 async fn reset_later_after_slot_starts() {
     time::pause();
 
@@ -551,7 +551,7 @@ async fn reset_later_after_slot_starts()
 
     let entry = assert_ready_some!(poll!(queue)).into_inner();
     assert_eq!(entry, "foo");
-}
+}*/
 
 #[tokio::test]
 async fn reset_inserted_expired() {
@@ -644,7 +644,7 @@ async fn delay_queue_poll_expired_when_e
     assert!(assert_ready!(poll!(delay_queue)).is_none());
 }
 
-#[tokio::test(start_paused = true)]
+/*#[tokio::test(start_paused = true)]
 async fn compact_expire_empty() {
     let mut queue = task::spawn(DelayQueue::new());
 
@@ -665,7 +665,7 @@ async fn compact_expire_empty() {
 
     assert_eq!(queue.len(), 0);
     assert_eq!(queue.capacity(), 0);
-}
+}*/
 
 #[tokio::test(start_paused = true)]
 async fn compact_remove_empty() {
@@ -811,7 +811,7 @@ async fn remove_after_compact_poll() {
         queue.remove(&foo_key);
     }));
     assert!(panic.is_err());
-}
+}*/
 
 fn ms(n: u64) -> Duration {
     Duration::from_millis(n)
Index: tokio-util/tests/framed_read.rs
===================================================================
--- tokio-util.orig/tests/framed_read.rs
+++ tokio-util/tests/framed_read.rs
@@ -1,8 +1,8 @@
 #![warn(rust_2018_idioms)]
 
 use tokio::io::{AsyncRead, ReadBuf};
-use tokio_test::assert_ready;
-use tokio_test::task;
+//use tokio_test::assert_ready;
+//use tokio_test::task;
 use tokio_util::codec::{Decoder, FramedRead};
 
 use bytes::{Buf, BytesMut};
@@ -21,12 +21,12 @@ macro_rules! mock {
     }};
 }
 
-macro_rules! assert_read {
+/*macro_rules! assert_read {
     ($e:expr, $n:expr) => {{
         let val = assert_ready!($e);
         assert_eq!(val.unwrap().unwrap(), $n);
     }};
-}
+}*/
 
 macro_rules! pin {
     ($id:ident) => {
@@ -66,7 +66,7 @@ impl Decoder for U64Decoder {
     }
 }
 
-#[test]
+/*#[test]
 fn read_multi_frame_in_packet() {
     let mut task = task::spawn(());
     let mock = mock! {
@@ -337,3 +337,4 @@ impl AsyncRead for Mock {
         }
     }
 }
+*/
Index: tokio-util/tests/framed_write.rs
===================================================================
--- tokio-util.orig/tests/framed_write.rs
+++ tokio-util/tests/framed_write.rs
@@ -1,7 +1,7 @@
-#![warn(rust_2018_idioms)]
+/*#![warn(rust_2018_idioms)]
 
 use tokio::io::AsyncWrite;
-use tokio_test::{assert_ready, task};
+//use tokio_test::{assert_ready, task};
 use tokio_util::codec::{Encoder, FramedWrite};
 
 use bytes::{BufMut, BytesMut};
@@ -52,7 +52,7 @@ impl Encoder<u64> for U64Encoder {
     }
 }
 
-#[test]
+/*#[test]
 fn write_multi_frame_in_packet() {
     let mut task = task::spawn(());
     let mock = mock! {
@@ -76,9 +76,9 @@ fn write_multi_frame_in_packet() {
 
         assert_eq!(0, framed.get_ref().calls.len());
     });
-}
+}*/
 
-#[test]
+/#[test]
 fn write_multi_frame_after_codec_changed() {
     let mut task = task::spawn(());
     let mock = mock! {
@@ -208,4 +208,4 @@ impl AsyncWrite for Mock {
     fn poll_shutdown(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Result<(), io::Error>> {
         unimplemented!()
     }
-}
+}*/
Index: tokio-util/tests/length_delimited.rs
===================================================================
--- tokio-util.orig/tests/length_delimited.rs
+++ tokio-util/tests/length_delimited.rs
@@ -1,4 +1,4 @@
-#![warn(rust_2018_idioms)]
+/*#![warn(rust_2018_idioms)]
 
 use tokio::io::{AsyncRead, AsyncWrite, ReadBuf};
 use tokio_test::task;
@@ -776,4 +776,4 @@ fn data(bytes: &[u8]) -> Poll<io::Result
 
 fn flush() -> Poll<io::Result<Op>> {
     Ready(Ok(Flush))
-}
+}*/
Index: tokio-util/tests/mpsc.rs
===================================================================
--- tokio-util.orig/tests/mpsc.rs
+++ tokio-util/tests/mpsc.rs
@@ -1,10 +1,10 @@
 use futures::future::poll_fn;
 use tokio::sync::mpsc::channel;
-use tokio_test::task::spawn;
-use tokio_test::{assert_pending, assert_ready, assert_ready_err, assert_ready_ok};
+//use tokio_test::task::spawn;
+//use tokio_test::{assert_pending, assert_ready, assert_ready_err, assert_ready_ok};
 use tokio_util::sync::PollSender;
 
-#[tokio::test]
+/*#[tokio::test]
 async fn simple() {
     let (send, mut recv) = channel(3);
     let mut send = PollSender::new(send);
@@ -212,7 +212,7 @@ async fn closed_when_receiver_drops() {
 
     let mut reserve = spawn(poll_fn(|cx| send.poll_reserve(cx)));
     assert_ready_err!(reserve.poll());
-}
+}*/
 
 #[should_panic]
 #[test]
@@ -223,7 +223,7 @@ fn start_send_panics_when_idle() {
     send.send_item(1).unwrap();
 }
 
-#[should_panic]
+/*#[should_panic]
 #[test]
 fn start_send_panics_when_acquiring() {
     let (send, _) = channel::<i32>(1);
@@ -236,4 +236,4 @@ fn start_send_panics_when_acquiring() {
     let mut reserve = spawn(poll_fn(|cx| send.poll_reserve(cx)));
     assert_pending!(reserve.poll());
     send.send_item(2).unwrap();
-}
+}*/
Index: tokio-util/tests/poll_semaphore.rs
===================================================================
--- tokio-util.orig/tests/poll_semaphore.rs
+++ tokio-util/tests/poll_semaphore.rs
@@ -1,4 +1,4 @@
-use std::future::Future;
+/*use std::future::Future;
 use std::sync::Arc;
 use std::task::Poll;
 use tokio::sync::{OwnedSemaphorePermit, Semaphore};
@@ -33,4 +33,4 @@ async fn it_works() {
     // Check that it is fused.
     assert!(semaphore_poll(&mut poll_sem).await.is_none());
     assert!(semaphore_poll(&mut poll_sem).await.is_none());
-}
+}*/
