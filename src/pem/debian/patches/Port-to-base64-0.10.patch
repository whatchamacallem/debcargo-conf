Description: Port to base64 v0.10
Origin: vendor
Forwarded: https://github.com/jcreekmore/pem-rs/pull/16
Author: Nicolas Braud-Santoni <nicoo@debian.org>
Last-Update: 2019-08-06
Applied-Upstream: no

--- a/Cargo.toml
+++ b/Cargo.toml
@@ -26,7 +26,7 @@
 name = "pem_benchmark"
 harness = false
 [dependencies.base64]
-version = "0.9.0"
+version = "^0.10"
 
 [dependencies.failure]
 version = "0.1"
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -110,6 +110,7 @@
 
 pub use errors::PemError;
 use regex::bytes::{Captures, Regex};
+use std::str;
 
 /// The `pem` result type.
 pub type Result<T> = ::std::result::Result<T, PemError>;
@@ -117,6 +118,9 @@
 const REGEX_STR: &'static str =
     r"(?s)-----BEGIN (?P<begin>.*?)-----\s*(?P<data>.*?)-----END (?P<end>.*?)-----\s*";
 
+/// The line length for PEM encoding
+const LINE_WRAP: usize = 64;
+
 lazy_static! {
     static ref ASCII_ARMOR: Regex = Regex::new(REGEX_STR).unwrap();
 }
@@ -133,7 +137,7 @@
 impl Pem {
     fn new_from_captures(caps: Captures) -> Result<Pem> {
         fn as_utf8<'a>(bytes: &'a [u8]) -> Result<&'a str> {
-            Ok(std::str::from_utf8(bytes).map_err(PemError::NotUtf8)?)
+            Ok(str::from_utf8(bytes).map_err(PemError::NotUtf8)?)
         }
 
         // Verify that the begin section exists
@@ -158,12 +162,18 @@
         }
 
         // If they did, then we can grab the data section
-        let data = as_utf8(caps.name("data")
+        let raw_data = as_utf8(caps.name("data")
                                .ok_or_else(|| PemError::MissingData)?
                                .as_bytes())?;
 
+        // We need to get rid of newlines for base64::decode
+        // As base64 requires an AsRef<[u8]>, this must involve a copy
+        let data : String = raw_data
+            .lines().map(str::trim_end)
+            .collect();
+
         // And decode it from Base64 into a vector of u8
-        let contents = base64::decode_config(&data, base64::MIME)
+        let contents = base64::decode_config(&data, base64::STANDARD)
                            .map_err(PemError::InvalidData)?;
 
         Ok(Pem {
@@ -321,13 +331,14 @@
         contents = base64::encode_config(&pem.contents, base64::Config::new(
             base64::CharacterSet::Standard,
             true,
-            true,
-            base64::LineWrap::Wrap(64, base64::LineEnding::CRLF)
         ));
     }
 
     output.push_str(&format!("-----BEGIN {}-----\r\n", pem.tag));
-    output.push_str(&format!("{}\r\n", contents));
+    for c in contents.as_bytes().chunks(LINE_WRAP) {
+        output.push_str(str::from_utf8(c).unwrap());
+        output.push_str("\r\n");
+    }
     output.push_str(&format!("-----END {}-----\r\n", pem.tag));
 
     output
