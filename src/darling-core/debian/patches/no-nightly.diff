Index: darling-core/src/error/kind.rs
===================================================================
--- darling-core.orig/src/error/kind.rs
+++ darling-core/src/error/kind.rs
@@ -128,23 +128,6 @@ impl ErrorUnknownField {
     {
         ErrorUnknownField::new(field, did_you_mean(field, alternates))
     }
-
-    #[cfg(feature = "diagnostics")]
-    pub fn to_diagnostic(self, span: Option<::proc_macro2::Span>) -> ::proc_macro::Diagnostic {
-        let base = span
-            .unwrap_or_else(::proc_macro2::Span::call_site)
-            .unwrap()
-            .error(self.top_line());
-        match self.did_you_mean {
-            Some(alt_name) => base.help(format!("did you mean `{}`?", alt_name)),
-            None => base,
-        }
-    }
-
-    #[cfg(feature = "diagnostics")]
-    fn top_line(&self) -> String {
-        format!("Unknown field: `{}`", self.name)
-    }
 }
 
 impl From<String> for ErrorUnknownField {
Index: darling-core/src/error/mod.rs
===================================================================
--- darling-core.orig/src/error/mod.rs
+++ darling-core/src/error/mod.rs
@@ -295,83 +295,18 @@ impl Error {
     /// }
     /// ```
     pub fn write_errors(self) -> TokenStream {
-        #[cfg(feature = "diagnostics")]
-        {
-            self.emit();
-            quote!()
-        }
-
-        #[cfg(not(feature = "diagnostics"))]
-        {
-            self.flatten()
-                .into_iter()
-                .map(|e| e.single_to_syn_error().to_compile_error())
-                .collect()
-        }
+        self.flatten()
+            .into_iter()
+            .map(|e| e.single_to_syn_error().to_compile_error())
+            .collect()
     }
 
-    #[cfg(not(feature = "diagnostics"))]
     fn single_to_syn_error(self) -> ::syn::Error {
         match self.span {
             Some(span) => ::syn::Error::new(span, self.kind),
             None => ::syn::Error::new(Span::call_site(), self),
         }
     }
-
-    #[cfg(feature = "diagnostics")]
-    fn single_to_diagnostic(self) -> ::proc_macro::Diagnostic {
-        use proc_macro::{Diagnostic, Level};
-
-        // Delegate to dedicated error formatters when applicable.
-        //
-        // If span information is available, don't include the error property path
-        // since it's redundant and not consistent with native compiler diagnostics.
-        match self.kind {
-            ErrorKind::UnknownField(euf) => euf.to_diagnostic(self.span),
-            _ => match self.span {
-                Some(span) => span.unwrap().error(self.kind.to_string()),
-                None => Diagnostic::new(Level::Error, self.to_string()),
-            },
-        }
-    }
-
-    /// Transform this error and its children into a list of compiler diagnostics
-    /// and emit them. If the `Error` has associated span information, the diagnostics
-    /// will identify the correct location in source code automatically.
-    ///
-    /// # Stability
-    /// This is only available on `nightly` until the compiler `proc_macro_diagnostic`
-    /// feature stabilizes. Until then, it may break at any time.
-    #[cfg(feature = "diagnostics")]
-    pub fn emit(self) {
-        for error in self.flatten() {
-            error.single_to_diagnostic().emit()
-        }
-    }
-
-    /// Transform the error into a compiler diagnostic and - if the diagnostic points to
-    /// a specific code location - add a spanned help child diagnostic that points to the
-    /// parent derived trait.
-    ///
-    /// This is experimental and therefore not exposed outside the crate.
-    #[cfg(feature = "diagnostics")]
-    #[allow(dead_code)]
-    fn emit_with_macro_help_span(self) {
-        use proc_macro::Diagnostic;
-
-        for error in self.flatten() {
-            let needs_help = error.has_span();
-            let diagnostic = error.single_to_diagnostic();
-            Diagnostic::emit(if needs_help {
-                diagnostic.span_help(
-                    Span::call_site().unwrap(),
-                    "Encountered as part of this derive-mode-macro",
-                )
-            } else {
-                diagnostic
-            })
-        }
-    }
 }
 
 impl StdError for Error {
Index: darling-core/src/lib.rs
===================================================================
--- darling-core.orig/src/lib.rs
+++ darling-core/src/lib.rs
@@ -1,5 +1,4 @@
 #![recursion_limit = "256"]
-#![cfg_attr(feature = "diagnostics", feature(proc_macro_diagnostic))]
 
 #[macro_use]
 extern crate quote;
@@ -7,8 +6,6 @@ extern crate quote;
 extern crate syn;
 extern crate fnv;
 extern crate ident_case;
-#[cfg(feature = "diagnostics")]
-extern crate proc_macro;
 extern crate proc_macro2;
 #[cfg(feature = "suggestions")]
 extern crate strsim;
