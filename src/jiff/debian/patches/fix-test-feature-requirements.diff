Index: jiff/src/civil/date.rs
===================================================================
--- jiff.orig/src/civil/date.rs
+++ jiff/src/civil/date.rs
@@ -4049,6 +4049,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn civil_date_deserialize_yaml() {
         let expected = date(2024, 10, 31);
 
Index: jiff/src/civil/datetime.rs
===================================================================
--- jiff.orig/src/civil/datetime.rs
+++ jiff/src/civil/datetime.rs
@@ -4399,6 +4399,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn civil_datetime_deserialize_yaml() {
         let expected = datetime(2024, 10, 31, 16, 33, 53, 123456789);
 
Index: jiff/src/civil/time.rs
===================================================================
--- jiff.orig/src/civil/time.rs
+++ jiff/src/civil/time.rs
@@ -3388,6 +3388,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn civil_time_deserialize_yaml() {
         let expected = time(16, 35, 4, 987654321);
 
Index: jiff/src/signed_duration.rs
===================================================================
--- jiff.orig/src/signed_duration.rs
+++ jiff/src/signed_duration.rs
@@ -2615,6 +2615,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn signed_duration_deserialize_yaml() {
         let expected = SignedDuration::from_secs(123456789);
 
@@ -2636,6 +2637,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn from_str() {
         let p = |s: &str| -> Result<SignedDuration, Error> { s.parse() };
 
@@ -2679,6 +2681,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(all(feature = "serde", feature = "alloc"))]
     fn serde_deserialize() {
         let p = |s: &str| -> Result<SignedDuration, serde_json::Error> {
             serde_json::from_str(&alloc::format!("\"{s}\""))
Index: jiff/src/span.rs
===================================================================
--- jiff.orig/src/span.rs
+++ jiff/src/span.rs
@@ -7030,6 +7030,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn span_deserialize_yaml() {
         let expected = Span::new()
             .years(1)
@@ -7134,6 +7135,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn from_str() {
         let p = |s: &str| -> Result<Span, Error> { s.parse() };
 
@@ -7177,6 +7179,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(all(feature = "serde", feature = "alloc"))]
     fn serde_deserialize() {
         let p = |s: &str| -> Result<Span, serde_json::Error> {
             serde_json::from_str(&alloc::format!("\"{s}\""))
Index: jiff/src/timestamp.rs
===================================================================
--- jiff.orig/src/timestamp.rs
+++ jiff/src/timestamp.rs
@@ -3742,6 +3742,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn timestamp_deserialize_yaml() {
         let expected = datetime(2024, 10, 31, 16, 33, 53, 123456789)
             .to_zoned(TimeZone::UTC)
Index: jiff/src/zoned.rs
===================================================================
--- jiff.orig/src/zoned.rs
+++ jiff/src/zoned.rs
@@ -5396,6 +5396,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn zoned_deserialize_yaml() {
         if crate::tz::db().is_definitively_empty() {
             return;
@@ -5453,6 +5454,8 @@ mod tests {
     ///
     /// See: <https://github.com/BurntSushi/jiff/issues/211>
     #[test]
+    // US/Eastern doesn't seem to exist in Debian's timezone db
+    #[cfg(feature = "tzdb-bundle-always")]
     fn zoned_with_time_dst_us_eastern() {
         if crate::tz::db().is_definitively_empty() {
             return;
Index: jiff/Cargo.toml
===================================================================
--- jiff.orig/Cargo.toml
+++ jiff/Cargo.toml
@@ -85,7 +85,7 @@ tzdb-bundle-always = [
 tzdb-bundle-platform = [
     "alloc",
 ]
-tzdb-concatenated = ["std"]
+tzdb-concatenated = ["std", "tzdb-zoneinfo"]
 tzdb-zoneinfo = ["std"]
 
 [lib]
Index: jiff/src/fmt/offset.rs
===================================================================
--- jiff.orig/src/fmt/offset.rs
+++ jiff/src/fmt/offset.rs
@@ -815,6 +815,7 @@ mod tests {
     // that if it's called, then the caller expects a numeric UTC offset at
     // that position.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_empty() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"").unwrap_err(),
@@ -824,6 +825,7 @@ mod tests {
 
     // A numeric offset always has to begin with a '+' or a '-'.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_notsign() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"*").unwrap_err(),
@@ -833,6 +835,7 @@ mod tests {
 
     // The hours component must be at least two bytes.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_hours_too_short() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+a").unwrap_err(),
@@ -842,6 +845,7 @@ mod tests {
 
     // The hours component must be at least two ASCII digits.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_hours_invalid_digits() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+ab").unwrap_err(),
@@ -851,6 +855,7 @@ mod tests {
 
     // The hours component must be in range.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_hours_out_of_range() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-26").unwrap_err(),
@@ -860,6 +865,7 @@ mod tests {
 
     // The minutes component must be at least two bytes.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_minutes_too_short() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:a").unwrap_err(),
@@ -869,6 +875,7 @@ mod tests {
 
     // The minutes component must be at least two ASCII digits.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_minutes_invalid_digits() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:ab").unwrap_err(),
@@ -878,6 +885,7 @@ mod tests {
 
     // The minutes component must be in range.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_minutes_out_of_range() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-05:60").unwrap_err(),
@@ -887,6 +895,7 @@ mod tests {
 
     // The seconds component must be at least two bytes.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_seconds_too_short() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:30:a").unwrap_err(),
@@ -896,6 +905,7 @@ mod tests {
 
     // The seconds component must be at least two ASCII digits.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_seconds_invalid_digits() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:30:ab").unwrap_err(),
@@ -905,6 +915,7 @@ mod tests {
 
     // The seconds component must be in range.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_seconds_out_of_range() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-05:30:60").unwrap_err(),
@@ -915,6 +926,7 @@ mod tests {
     // The fraction component, if present as indicated by a separator, must be
     // non-empty.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_fraction_non_empty() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-05:30:44.").unwrap_err(),
@@ -950,6 +962,7 @@ mod tests {
     // requested, but that it is has been forcefully disabled. This error is
     // meant to make what is likely a subtle failure mode more explicit.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_subminute_disabled_but_desired() {
         insta::assert_snapshot!(
             Parser::new().subminute(false).parse_numeric(b"-05:59:32").unwrap_err(),
@@ -960,6 +973,7 @@ mod tests {
     // Another special case where Zulu parsing has been explicitly disabled,
     // but a Zulu string was found.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_zulu_disabled_but_desired() {
         insta::assert_snapshot!(
             Parser::new().zulu(false).parse(b"Z").unwrap_err(),
@@ -976,6 +990,7 @@ mod tests {
     // isn't true is when there is a fractional nanosecond part along with
     // maximal
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_too_big_for_offset() {
         let numeric = Numeric {
             sign: t::Sign::MAX_SELF,
@@ -1001,6 +1016,7 @@ mod tests {
 
     // Same as numeric_too_big_for_offset, but at the minimum boundary.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_too_small_for_offset() {
         let numeric = Numeric {
             sign: t::Sign::MIN_SELF,
Index: jiff/src/fmt/rfc2822.rs
===================================================================
--- jiff.orig/src/fmt/rfc2822.rs
+++ jiff/src/fmt/rfc2822.rs
@@ -1688,6 +1688,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_invalid() {
         let p = |input| {
             DateTimeParser::new().parse_zoned(input).unwrap_err().to_string()
@@ -1716,6 +1717,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_incomplete() {
         let p = |input| {
             DateTimeParser::new().parse_zoned(input).unwrap_err().to_string()
@@ -1800,6 +1802,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_comment() {
         let p = |input| {
             DateTimeParser::new().parse_zoned(input).unwrap_err().to_string()
Index: jiff/src/fmt/rfc9557.rs
===================================================================
--- jiff.orig/src/fmt/rfc9557.rs
+++ jiff/src/fmt/rfc9557.rs
@@ -900,6 +900,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_iana() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[0/Foo]").unwrap_err(),
@@ -912,6 +913,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_offset() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[+").unwrap_err(),
@@ -936,6 +938,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_critical_unsupported() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[!u-ca=chinese]").unwrap_err(),
@@ -944,6 +947,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_key_leading_char() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[").unwrap_err(),
@@ -964,6 +968,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_separator() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[abc").unwrap_err(),
@@ -992,6 +997,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_value() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[abc=").unwrap_err(),
@@ -1012,6 +1018,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_close() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[abc=123").unwrap_err(),
Index: jiff/src/fmt/friendly/parser.rs
===================================================================
--- jiff.orig/src/fmt/friendly/parser.rs
+++ jiff/src/fmt/friendly/parser.rs
@@ -1065,6 +1065,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_basic() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1103,6 +1104,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_sign() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1125,6 +1127,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_overflow_fraction() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap();
         let pe = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
@@ -1157,6 +1160,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_overflow_units() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1207,6 +1211,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_fraction() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1221,6 +1226,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_hms() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1252,6 +1258,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn parse_duration_negate() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap();
         let perr = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
@@ -1297,6 +1304,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn parse_duration_boundaries() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap();
         let pe = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
@@ -1357,6 +1365,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_basic() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
@@ -1399,6 +1408,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_sign() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
@@ -1421,6 +1431,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_overflow_fraction() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap();
         let pe = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
@@ -1439,6 +1450,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_fraction() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
@@ -1449,6 +1461,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_hms() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
Index: jiff/src/fmt/strtime/format.rs
===================================================================
--- jiff.orig/src/fmt/strtime/format.rs
+++ jiff/src/fmt/strtime/format.rs
@@ -1171,6 +1171,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_format_subsec_nanosecond() {
         let f = |fmt: &str, time: Time| format(fmt, time).unwrap_err();
         let mk = |subsec| time(0, 0, 0, subsec);
@@ -1182,6 +1183,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_format_timestamp() {
         let f = |fmt: &str, dt: DateTime| format(fmt, dt).unwrap_err();
 
Index: jiff/src/fmt/strtime/parse.rs
===================================================================
--- jiff.orig/src/fmt/strtime/parse.rs
+++ jiff/src/fmt/strtime/parse.rs
@@ -1776,6 +1776,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse() {
         let p = |fmt: &str, input: &str| {
             BrokenDownTime::parse_mono(fmt.as_bytes(), input.as_bytes())
@@ -1968,6 +1969,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_date() {
         let p = |fmt: &str, input: &str| {
             BrokenDownTime::parse_mono(fmt.as_bytes(), input.as_bytes())
@@ -2030,6 +2032,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_time() {
         let p = |fmt: &str, input: &str| {
             BrokenDownTime::parse_mono(fmt.as_bytes(), input.as_bytes())
Index: jiff/src/fmt/temporal/mod.rs
===================================================================
--- jiff.orig/src/fmt/temporal/mod.rs
+++ jiff/src/fmt/temporal/mod.rs
@@ -1989,6 +1989,7 @@ mod tests {
     // This test ensures that strings like `2024-07-15+02` fail to parse.
     // Note though that `2024-07-15[America/New_York]` is okay!
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_temporal_datetime_offset() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date(b"2024-07-15+02").unwrap_err(),
@@ -2001,6 +2002,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn year_zero() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date("0000-01-01").unwrap(),
Index: jiff/src/fmt/temporal/parser.rs
===================================================================
--- jiff.orig/src/fmt/temporal/parser.rs
+++ jiff/src/fmt/temporal/parser.rs
@@ -1471,6 +1471,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_signed_duration() {
         let p = |input| {
             SpanParser::new().parse_signed_duration(input).unwrap_err()
@@ -2198,6 +2199,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_temporal_time_ambiguous() {
         let p = |input| {
             DateTimeParser::new().parse_temporal_time(input).unwrap_err()
@@ -2214,6 +2216,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_temporal_time_missing_time() {
         let p = |input| {
             DateTimeParser::new().parse_temporal_time(input).unwrap_err()
@@ -2315,6 +2318,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_empty() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"").unwrap_err(),
@@ -2323,6 +2327,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_year() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"123").unwrap_err(),
@@ -2364,6 +2369,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_month() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"2024-").unwrap_err(),
@@ -2384,6 +2390,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_day() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"2024-12-").unwrap_err(),
@@ -2412,6 +2419,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_separator() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"2024-1231").unwrap_err(),
@@ -2545,6 +2553,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_empty() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"").unwrap_err(),
@@ -2553,6 +2562,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_hour() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"a").unwrap_err(),
@@ -2569,6 +2579,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_minute() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"01:").unwrap_err(),
@@ -2589,6 +2600,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_second() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"01:02:").unwrap_err(),
@@ -2609,6 +2621,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_fractional() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"01:02:03.").unwrap_err(),
