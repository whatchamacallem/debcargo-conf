Index: jiff/src/civil/date.rs
===================================================================
--- jiff.orig/src/civil/date.rs
+++ jiff/src/civil/date.rs
@@ -4039,6 +4039,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn civil_date_deserialize_yaml() {
         let expected = date(2024, 10, 31);
 
Index: jiff/src/civil/datetime.rs
===================================================================
--- jiff.orig/src/civil/datetime.rs
+++ jiff/src/civil/datetime.rs
@@ -4548,6 +4548,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn civil_datetime_deserialize_yaml() {
         let expected = datetime(2024, 10, 31, 16, 33, 53, 123456789);
 
Index: jiff/src/civil/time.rs
===================================================================
--- jiff.orig/src/civil/time.rs
+++ jiff/src/civil/time.rs
@@ -3504,6 +3504,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn civil_time_deserialize_yaml() {
         let expected = time(16, 35, 4, 987654321);
 
Index: jiff/src/signed_duration.rs
===================================================================
--- jiff.orig/src/signed_duration.rs
+++ jiff/src/signed_duration.rs
@@ -2698,6 +2698,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn signed_duration_deserialize_yaml() {
         let expected = SignedDuration::from_secs(123456789);
 
@@ -2719,6 +2720,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn from_str() {
         let p = |s: &str| -> Result<SignedDuration, Error> { s.parse() };
 
@@ -2762,6 +2764,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(all(feature = "serde", feature = "alloc"))]
     fn serde_deserialize() {
         let p = |s: &str| -> Result<SignedDuration, serde_json::Error> {
             serde_json::from_str(&alloc::format!("\"{s}\""))
Index: jiff/src/span.rs
===================================================================
--- jiff.orig/src/span.rs
+++ jiff/src/span.rs
@@ -7134,6 +7134,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn span_deserialize_yaml() {
         let expected = Span::new()
             .years(1)
@@ -7238,6 +7239,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn from_str() {
         let p = |s: &str| -> Result<Span, Error> { s.parse() };
 
@@ -7281,6 +7283,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(all(feature = "serde", feature = "alloc"))]
     fn serde_deserialize() {
         let p = |s: &str| -> Result<Span, serde_json::Error> {
             serde_json::from_str(&alloc::format!("\"{s}\""))
Index: jiff/src/timestamp.rs
===================================================================
--- jiff.orig/src/timestamp.rs
+++ jiff/src/timestamp.rs
@@ -3849,6 +3849,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "std")]
     fn timestamp_saturating_add() {
         insta::assert_snapshot!(
             Timestamp::MIN.saturating_add(Span::new().days(1)).unwrap_err(),
@@ -3857,6 +3858,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "std")]
     fn timestamp_saturating_sub() {
         insta::assert_snapshot!(
             Timestamp::MAX.saturating_sub(Span::new().days(1)).unwrap_err(),
@@ -3910,6 +3912,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn timestamp_deserialize_yaml() {
         let expected = datetime(2024, 10, 31, 16, 33, 53, 123456789)
             .to_zoned(TimeZone::UTC)
Index: jiff/src/zoned.rs
===================================================================
--- jiff.orig/src/zoned.rs
+++ jiff/src/zoned.rs
@@ -5578,6 +5578,7 @@ mod tests {
     /// - <https://github.com/BurntSushi/jiff/issues/138>
     /// - <https://github.com/BurntSushi/jiff/discussions/148>
     #[test]
+    #[cfg(feature = "serde")]
     fn zoned_deserialize_yaml() {
         if crate::tz::db().is_definitively_empty() {
             return;
@@ -5635,6 +5636,8 @@ mod tests {
     ///
     /// See: <https://github.com/BurntSushi/jiff/issues/211>
     #[test]
+    // US/Eastern doesn't seem to exist in Debian's timezone db
+    #[cfg(feature = "tzdb-bundle-always")]
     fn zoned_with_time_dst_us_eastern() {
         if crate::tz::db().is_definitively_empty() {
             return;
Index: jiff/Cargo.toml
===================================================================
--- jiff.orig/Cargo.toml
+++ jiff/Cargo.toml
@@ -94,7 +94,7 @@ tzdb-bundle-always = [
 tzdb-bundle-platform = [
     "alloc",
 ]
-tzdb-concatenated = ["std"]
+tzdb-concatenated = ["std", "tzdb-zoneinfo"]
 tzdb-zoneinfo = ["std"]
 
 [lib]
Index: jiff/src/fmt/offset.rs
===================================================================
--- jiff.orig/src/fmt/offset.rs
+++ jiff/src/fmt/offset.rs
@@ -932,6 +932,7 @@ mod tests {
     // that if it's called, then the caller expects a numeric UTC offset at
     // that position.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_empty() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"").unwrap_err(),
@@ -941,6 +942,7 @@ mod tests {
 
     // A numeric offset always has to begin with a '+' or a '-'.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_notsign() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"*").unwrap_err(),
@@ -950,6 +952,7 @@ mod tests {
 
     // The hours component must be at least two bytes.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_hours_too_short() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+a").unwrap_err(),
@@ -959,6 +962,7 @@ mod tests {
 
     // The hours component must be at least two ASCII digits.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_hours_invalid_digits() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+ab").unwrap_err(),
@@ -968,6 +972,7 @@ mod tests {
 
     // The hours component must be in range.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_hours_out_of_range() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-26").unwrap_err(),
@@ -977,6 +982,7 @@ mod tests {
 
     // The minutes component must be at least two bytes.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_minutes_too_short() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:a").unwrap_err(),
@@ -986,6 +992,7 @@ mod tests {
 
     // The minutes component must be at least two ASCII digits.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_minutes_invalid_digits() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:ab").unwrap_err(),
@@ -995,6 +1002,7 @@ mod tests {
 
     // The minutes component must be in range.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_minutes_out_of_range() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-05:60").unwrap_err(),
@@ -1004,6 +1012,7 @@ mod tests {
 
     // The seconds component must be at least two bytes.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_seconds_too_short() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:30:a").unwrap_err(),
@@ -1013,6 +1022,7 @@ mod tests {
 
     // The seconds component must be at least two ASCII digits.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_seconds_invalid_digits() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"+05:30:ab").unwrap_err(),
@@ -1022,6 +1032,7 @@ mod tests {
 
     // The seconds component must be in range.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_seconds_out_of_range() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-05:30:60").unwrap_err(),
@@ -1032,6 +1043,7 @@ mod tests {
     // The fraction component, if present as indicated by a separator, must be
     // non-empty.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_fraction_non_empty() {
         insta::assert_snapshot!(
             Parser::new().parse_numeric(b"-05:30:44.").unwrap_err(),
@@ -1067,6 +1079,7 @@ mod tests {
     // requested, but that it is has been forcefully disabled. This error is
     // meant to make what is likely a subtle failure mode more explicit.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_subminute_disabled_but_desired() {
         insta::assert_snapshot!(
             Parser::new().subminute(false).parse_numeric(b"-05:59:32").unwrap_err(),
@@ -1077,6 +1090,7 @@ mod tests {
     // Another special case where Zulu parsing has been explicitly disabled,
     // but a Zulu string was found.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_zulu_disabled_but_desired() {
         insta::assert_snapshot!(
             Parser::new().zulu(false).parse(b"Z").unwrap_err(),
@@ -1093,6 +1107,7 @@ mod tests {
     // isn't true is when there is a fractional nanosecond part along with
     // maximal
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_too_big_for_offset() {
         let numeric = Numeric {
             sign: t::Sign::MAX_SELF,
@@ -1118,6 +1133,7 @@ mod tests {
 
     // Same as numeric_too_big_for_offset, but at the minimum boundary.
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_numeric_too_small_for_offset() {
         let numeric = Numeric {
             sign: t::Sign::MIN_SELF,
Index: jiff/src/fmt/rfc2822.rs
===================================================================
--- jiff.orig/src/fmt/rfc2822.rs
+++ jiff/src/fmt/rfc2822.rs
@@ -1736,6 +1736,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_invalid() {
         let p = |input| {
             DateTimeParser::new().parse_zoned(input).unwrap_err().to_string()
@@ -1769,6 +1770,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_incomplete() {
         let p = |input| {
             DateTimeParser::new().parse_zoned(input).unwrap_err().to_string()
@@ -1865,6 +1867,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_comment() {
         let p = |input| {
             DateTimeParser::new().parse_zoned(input).unwrap_err().to_string()
Index: jiff/src/fmt/rfc9557.rs
===================================================================
--- jiff.orig/src/fmt/rfc9557.rs
+++ jiff/src/fmt/rfc9557.rs
@@ -891,6 +891,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_iana() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[0/Foo]").unwrap_err(),
@@ -903,6 +904,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_offset() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[+").unwrap_err(),
@@ -927,6 +929,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_critical_unsupported() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[!u-ca=chinese]").unwrap_err(),
@@ -935,6 +938,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_key_leading_char() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[").unwrap_err(),
@@ -955,6 +959,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_separator() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[abc").unwrap_err(),
@@ -983,6 +988,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_value() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[abc=").unwrap_err(),
@@ -1003,6 +1009,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_close() {
         insta::assert_snapshot!(
             Parser::new().parse(b"[abc=123").unwrap_err(),
Index: jiff/src/fmt/friendly/parser.rs
===================================================================
--- jiff.orig/src/fmt/friendly/parser.rs
+++ jiff/src/fmt/friendly/parser.rs
@@ -1069,6 +1069,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_basic() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1107,6 +1108,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_sign() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1129,6 +1131,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_overflow_fraction() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap();
         let pe = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
@@ -1161,6 +1164,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_overflow_units() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1211,6 +1215,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_fraction() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1225,6 +1230,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_span_hms() {
         let p = |s: &str| SpanParser::new().parse_span(s).unwrap_err();
 
@@ -1256,6 +1262,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn parse_duration_negate() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap();
         let perr = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
@@ -1301,6 +1308,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn parse_duration_boundaries() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap();
         let pe = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
@@ -1361,6 +1369,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_basic() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
@@ -1403,6 +1412,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_sign() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
@@ -1425,6 +1435,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_overflow_fraction() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap();
         let pe = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
@@ -1443,6 +1454,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_fraction() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
@@ -1453,6 +1465,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_duration_hms() {
         let p = |s: &str| SpanParser::new().parse_duration(s).unwrap_err();
 
Index: jiff/src/fmt/strtime/format.rs
===================================================================
--- jiff.orig/src/fmt/strtime/format.rs
+++ jiff/src/fmt/strtime/format.rs
@@ -1489,6 +1489,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_format_subsec_nanosecond() {
         let f = |fmt: &str, time: Time| format(fmt, time).unwrap_err();
         let mk = |subsec| time(0, 0, 0, subsec);
@@ -1500,6 +1501,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_format_timestamp() {
         let f = |fmt: &str, dt: DateTime| format(fmt, dt).unwrap_err();
 
Index: jiff/src/fmt/strtime/parse.rs
===================================================================
--- jiff.orig/src/fmt/strtime/parse.rs
+++ jiff/src/fmt/strtime/parse.rs
@@ -1816,6 +1816,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse() {
         let p = |fmt: &str, input: &str| {
             BrokenDownTime::parse_mono(fmt.as_bytes(), input.as_bytes())
@@ -2020,6 +2021,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_date() {
         let p = |fmt: &str, input: &str| {
             BrokenDownTime::parse_mono(fmt.as_bytes(), input.as_bytes())
@@ -2082,6 +2084,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_parse_time() {
         let p = |fmt: &str, input: &str| {
             BrokenDownTime::parse_mono(fmt.as_bytes(), input.as_bytes())
Index: jiff/src/fmt/temporal/mod.rs
===================================================================
--- jiff.orig/src/fmt/temporal/mod.rs
+++ jiff/src/fmt/temporal/mod.rs
@@ -2330,6 +2330,7 @@ mod tests {
     // This test ensures that strings like `2024-07-15+02` fail to parse.
     // Note though that `2024-07-15[America/New_York]` is okay!
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_temporal_datetime_offset() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date(b"2024-07-15+02").unwrap_err(),
@@ -2342,6 +2343,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn year_zero() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date("0000-01-01").unwrap(),
Index: jiff/src/fmt/temporal/parser.rs
===================================================================
--- jiff.orig/src/fmt/temporal/parser.rs
+++ jiff/src/fmt/temporal/parser.rs
@@ -1671,6 +1671,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_signed_duration() {
         let p = |input| {
             SpanParser::new().parse_signed_duration(input).unwrap_err()
@@ -2398,6 +2399,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_temporal_time_ambiguous() {
         let p = |input| {
             DateTimeParser::new().parse_temporal_time(input).unwrap_err()
@@ -2414,6 +2416,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_temporal_time_missing_time() {
         let p = |input| {
             DateTimeParser::new().parse_temporal_time(input).unwrap_err()
@@ -2515,6 +2518,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_empty() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"").unwrap_err(),
@@ -2523,6 +2527,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_year() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"123").unwrap_err(),
@@ -2564,6 +2569,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_month() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"2024-").unwrap_err(),
@@ -2584,6 +2590,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_day() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"2024-12-").unwrap_err(),
@@ -2612,6 +2619,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_date_separator() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_date_spec(b"2024-1231").unwrap_err(),
@@ -2745,6 +2753,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_empty() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"").unwrap_err(),
@@ -2753,6 +2762,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_hour() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"a").unwrap_err(),
@@ -2769,6 +2779,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_minute() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"01:").unwrap_err(),
@@ -2789,6 +2800,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_second() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"01:02:").unwrap_err(),
@@ -2809,6 +2821,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn err_time_fractional() {
         insta::assert_snapshot!(
             DateTimeParser::new().parse_time_spec(b"01:02:03.").unwrap_err(),
