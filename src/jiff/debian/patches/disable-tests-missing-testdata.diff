Index: jiff/src/tz/concatenated.rs
===================================================================
--- jiff.orig/src/tz/concatenated.rs
+++ jiff/src/tz/concatenated.rs
@@ -477,7 +477,7 @@ mod tests {
     use crate::{
         civil::date,
         tz::{
-            offset, testdata::ANDROID_CONCATENATED_TZIF, AmbiguousOffset,
+            offset, AmbiguousOffset,
             Offset,
         },
         Timestamp,
@@ -799,7 +799,7 @@ mod tests {
                 ],
             ),
         ];
-        let db = ConcatenatedTzif::open(ANDROID_CONCATENATED_TZIF).unwrap();
+        /* let db = ConcatenatedTzif::open(ANDROID_CONCATENATED_TZIF).unwrap();
         let (mut buf1, mut buf2) = (alloc::vec![], alloc::vec![]);
         for &(tzname, datetimes_to_ambiguous) in tests {
             let tz = db.get(tzname, &mut buf1, &mut buf2).unwrap().unwrap();
@@ -815,11 +815,11 @@ mod tests {
                      {hour:02}:{min:02}:{sec:02}.{nano:09}",
                 );
             }
-        }
+        } */
     }
 
     // Copied from src/tz/mod.rs.
-    #[test]
+    /*#[test]
     fn time_zone_tzif_to_datetime() {
         let o = |hours| offset(hours);
         let tests: &[(&str, &[_])] = &[
@@ -1114,9 +1114,9 @@ mod tests {
                 );
             }
         }
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     #[cfg(not(miri))]
     fn read_all_time_zones() {
         let db = ConcatenatedTzif::open(ANDROID_CONCATENATED_TZIF).unwrap();
@@ -1137,5 +1137,5 @@ mod tests {
             let (x1, x2) = (&window[0], &window[1]);
             assert!(x1 < x2, "{x1} is not less than {x2}");
         }
-    }
+    }*/
 }
Index: jiff/src/tz/mod.rs
===================================================================
--- jiff.orig/src/tz/mod.rs
+++ jiff/src/tz/mod.rs
@@ -143,8 +143,8 @@ mod offset;
 pub(crate) mod posix;
 #[cfg(feature = "tz-system")]
 mod system;
-#[cfg(all(test, feature = "alloc"))]
-mod testdata;
+//#[cfg(all(test, feature = "alloc"))]
+//mod testdata;
 mod timezone;
 pub(crate) mod tzif;
 // See module comment for WIP status. :-(
Index: jiff/src/tz/timezone.rs
===================================================================
--- jiff.orig/src/tz/timezone.rs
+++ jiff/src/tz/timezone.rs
@@ -2471,8 +2471,8 @@ mod repr {
 
 #[cfg(test)]
 mod tests {
-    #[cfg(feature = "alloc")]
-    use crate::tz::testdata::TzifTestFile;
+    //#[cfg(feature = "alloc")]
+    //use crate::tz::testdata::TzifTestFile;
     use crate::{civil::date, tz::offset};
 
     use super::*;
@@ -2791,7 +2791,7 @@ mod tests {
                 ],
             ),
         ];
-        for &(tzname, datetimes_to_ambiguous) in tests {
+        /*for &(tzname, datetimes_to_ambiguous) in tests {
             let test_file = TzifTestFile::get(tzname);
             let tz = TimeZone::tzif(test_file.name, test_file.data).unwrap();
             for &(datetime, ambiguous_kind) in datetimes_to_ambiguous {
@@ -2806,10 +2806,10 @@ mod tests {
                      {hour:02}:{min:02}:{sec:02}.{nano:09}",
                 );
             }
-        }
+        }*/
     }
 
-    #[cfg(feature = "alloc")]
+    /*#[cfg(feature = "alloc")]
     #[test]
     fn time_zone_tzif_to_datetime() {
         let o = |hours| offset(hours);
@@ -3104,7 +3104,7 @@ mod tests {
                 );
             }
         }
-    }
+    } */
 
     #[cfg(feature = "alloc")]
     #[test]
@@ -3508,7 +3508,7 @@ mod tests {
                 &[("2024-03-10 08Z", Some("2019-02-17 02Z"))],
             ),
         ];
-        for &(tzname, prev_trans) in tests {
+        /* for &(tzname, prev_trans) in tests {
             if tzname != "America/Sao_Paulo" {
                 continue;
             }
@@ -3521,7 +3521,7 @@ mod tests {
                 let got = tz.previous_transition(given).map(|t| t.timestamp());
                 assert_eq!(got, expected, "\nTZ: {tzname}\ngiven: {given}");
             }
-        }
+        }*/
     }
 
     #[cfg(feature = "alloc")]
@@ -3598,7 +3598,7 @@ mod tests {
                 &[("2024-03-10 08Z", None)],
             ),
         ];
-        for &(tzname, next_trans) in tests {
+        /*for &(tzname, next_trans) in tests {
             let test_file = TzifTestFile::get(tzname);
             let tz = TimeZone::tzif(test_file.name, test_file.data).unwrap();
             for (given, expected) in next_trans {
@@ -3608,7 +3608,7 @@ mod tests {
                 let got = tz.next_transition(given).map(|t| t.timestamp());
                 assert_eq!(got, expected, "\nTZ: {tzname}\ngiven: {given}");
             }
-        }
+        }*/
     }
 
     #[cfg(feature = "alloc")]
@@ -3830,13 +3830,13 @@ mod tests {
             let tz = TimeZone::posix("EST5").unwrap();
             assert!(tz.to_fixed_offset().is_err());
 
-            let test_file = TzifTestFile::get("America/New_York");
+            /*let test_file = TzifTestFile::get("America/New_York");
             let tz = TimeZone::tzif(test_file.name, test_file.data).unwrap();
-            assert!(tz.to_fixed_offset().is_err());
+            assert!(tz.to_fixed_offset().is_err());*/
         }
     }
 
-    /// This tests that `TimeZone::following` correctly returns a final time
+    /* /// This tests that `TimeZone::following` correctly returns a final time
     /// zone transition.
     #[cfg(feature = "alloc")]
     #[test]
@@ -3865,5 +3865,5 @@ mod tests {
         // being found here, despite the fact that it existed and was found
         // by `preceding`.
         assert_eq!(transitions, last4);
-    }
+    }*/
 }
Index: jiff/src/tz/tzif.rs
===================================================================
--- jiff.orig/src/tz/tzif.rs
+++ jiff/src/tz/tzif.rs
@@ -594,7 +594,7 @@ mod tests {
     use alloc::{string::ToString, vec};
 
     #[cfg(not(miri))]
-    use crate::tz::testdata::TZIF_TEST_FILES;
+    //use crate::tz::testdata::TZIF_TEST_FILES;
 
     use super::*;
 
@@ -700,7 +700,7 @@ mod tests {
     /// as a TZif and then dump debug data about the file in a human readable
     /// plain text format.
     #[cfg(feature = "std")]
-    #[test]
+    /*#[test]
     fn debug_tzif() -> anyhow::Result<()> {
         use anyhow::Context;
 
@@ -727,9 +727,9 @@ mod tests {
                 tzif_to_human_readable(&tzif_test.parse())
             );
         }
-    }
+    }*/
 
-    #[cfg(not(miri))]
+    /*#[cfg(not(miri))]
     #[test]
     fn tzif_parse_v1() {
         for tzif_test in TZIF_TEST_FILES {
@@ -738,7 +738,7 @@ mod tests {
                 tzif_to_human_readable(&tzif_test.parse_v1())
             );
         }
-    }
+    }*/
 
     /// This tests walks the /usr/share/zoneinfo directory (if it exists) and
     /// tries to parse every TZif formatted file it can find. We don't really
Index: jiff/src/tz/zic.rs
===================================================================
--- jiff.orig/src/tz/zic.rs
+++ jiff/src/tz/zic.rs
@@ -1594,7 +1594,7 @@ mod tests {
     }
 
     #[cfg(not(miri))]
-    #[test]
+    /*#[test]
     fn parse_zic_man1() {
         // An example from `man zic`.
         let data = "
@@ -1636,7 +1636,7 @@ mod tests {
         let mut zic = ZicP::default();
         zic.parse(data).unwrap();
         insta::assert_debug_snapshot!(zic);
-    }
+    }*/
 
     #[test]
     fn parse_zic_err() {
