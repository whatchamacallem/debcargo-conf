--- a/tests/dfa/suite.rs
+++ b/tests/dfa/suite.rs
@@ -15,12 +15,12 @@
     },
 };
 
-use crate::{create_input, suite, untestify_kind};
+use crate::{create_input, untestify_kind};
 
 const EXPANSIONS: &[&str] = &["is_match", "find", "which"];
 
 /// Runs the test suite with the default configuration.
-#[test]
+/*#[test]
 fn unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     TestRunner::new()?
@@ -29,11 +29,11 @@
         .test_iter(suite()?.iter(), dense_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite with the default configuration and a prefilter enabled,
 /// if one can be built.
-#[test]
+/*#[test]
 fn unminimized_prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -60,10 +60,10 @@
         .test_iter(suite()?.iter(), my_compiler)
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite with start states specialized.
-#[test]
+/*#[test]
 fn unminimized_specialized_start_states() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().specialize_start_states(true));
@@ -74,10 +74,10 @@
         .test_iter(suite()?.iter(), dense_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite with byte classes disabled.
-#[test]
+/*#[test]
 fn unminimized_no_byte_class() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().byte_classes(false));
@@ -88,10 +88,10 @@
         .test_iter(suite()?.iter(), dense_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite with NFA shrinking enabled.
-#[test]
+/*#[test]
 fn unminimized_nfa_shrink() -> Result<()> {
     let mut builder = Regex::builder();
     builder.thompson(thompson::Config::new().shrink(true));
@@ -102,11 +102,11 @@
         .test_iter(suite()?.iter(), dense_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite on a minimized DFA with an otherwise default
 /// configuration.
-#[test]
+/*#[test]
 fn minimized_default() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().minimize(true));
@@ -116,10 +116,10 @@
         .test_iter(suite()?.iter(), dense_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite on a minimized DFA with byte classes disabled.
-#[test]
+/*#[test]
 fn minimized_no_byte_class() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().minimize(true).byte_classes(false));
@@ -130,10 +130,10 @@
         .test_iter(suite()?.iter(), dense_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite on a sparse unminimized DFA.
-#[test]
+/*#[test]
 fn sparse_unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     TestRunner::new()?
@@ -142,10 +142,10 @@
         .test_iter(suite()?.iter(), sparse_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Runs the test suite on a sparse unminimized DFA with prefilters enabled.
-#[test]
+/*#[test]
 fn sparse_unminimized_prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -175,11 +175,11 @@
         .test_iter(suite()?.iter(), my_compiler)
         .assert();
     Ok(())
-}
+}*/
 
 /// Another basic sanity test that checks we can serialize and then deserialize
 /// a regex, and that the resulting regex can be used for searching correctly.
-#[test]
+/*#[test]
 fn serialization_unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     let my_compiler = |builder| {
@@ -204,12 +204,12 @@
         .test_iter(suite()?.iter(), my_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// A basic sanity test that checks we can serialize and then deserialize a
 /// regex using sparse DFAs, and that the resulting regex can be used for
 /// searching correctly.
-#[test]
+/*#[test]
 fn sparse_serialization_unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     let my_compiler = |builder| {
@@ -233,7 +233,7 @@
         .test_iter(suite()?.iter(), my_compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 fn dense_compiler(
     builder: dfa::regex::Builder,
--- a/tests/hybrid/suite.rs
+++ b/tests/hybrid/suite.rs
@@ -15,12 +15,12 @@
     },
 };
 
-use crate::{create_input, suite, untestify_kind};
+use crate::{create_input, untestify_kind};
 
 const EXPANSIONS: &[&str] = &["is_match", "find", "which"];
 
 /// Tests the default configuration of the hybrid NFA/DFA.
-#[test]
+/*#[test]
 fn default() -> Result<()> {
     let builder = Regex::builder();
     TestRunner::new()?
@@ -30,10 +30,10 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the hybrid NFA/DFA with prefilters enabled.
-#[test]
+/*#[test]
 fn prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -57,7 +57,7 @@
         .test_iter(suite()?.iter(), my_compiler)
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the hybrid NFA/DFA with NFA shrinking enabled.
 ///
@@ -71,7 +71,7 @@
 /// Nevertheless, we test to make sure everything is OK with NFA shrinking. As
 /// a bonus, there are some tests we don't need to skip because they now fit in
 /// the default cache capacity.
-#[test]
+/*#[test]
 fn nfa_shrink() -> Result<()> {
     let mut builder = Regex::builder();
     builder.thompson(thompson::Config::new().shrink(true));
@@ -80,11 +80,11 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the hybrid NFA/DFA when 'starts_for_each_pattern' is enabled for all
 /// tests.
-#[test]
+/*#[test]
 fn starts_for_each_pattern() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().starts_for_each_pattern(true));
@@ -95,10 +95,10 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the hybrid NFA/DFA when 'specialize_start_states' is enabled.
-#[test]
+/*#[test]
 fn specialize_start_states() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().specialize_start_states(true));
@@ -109,14 +109,14 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the hybrid NFA/DFA when byte classes are disabled.
 ///
 /// N.B. Disabling byte classes doesn't avoid any indirection at search time.
 /// All it does is cause every byte value to be its own distinct equivalence
 /// class.
-#[test]
+/*#[test]
 fn no_byte_classes() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().byte_classes(false));
@@ -127,7 +127,7 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests that hybrid NFA/DFA never clears its cache for any test with the
 /// default capacity.
@@ -135,7 +135,7 @@
 /// N.B. If a regex suite test is added that causes the cache to be cleared,
 /// then this should just skip that test. (Which can be done by calling the
 /// 'blacklist' method on 'TestRunner'.)
-#[test]
+/*#[test]
 fn no_cache_clearing() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().minimum_cache_clear_count(Some(0)));
@@ -146,10 +146,10 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the hybrid NFA/DFA when the minimum cache capacity is set.
-#[test]
+/*#[test]
 fn min_cache_capacity() -> Result<()> {
     let mut builder = Regex::builder();
     builder
@@ -159,7 +159,7 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 fn compiler(
     mut builder: regex::Builder,
--- a/tests/lib.rs
+++ b/tests/lib.rs
@@ -28,7 +28,7 @@
 #[cfg(any(feature = "nfa-backtrack", feature = "nfa-pikevm"))]
 mod nfa;
 
-fn suite() -> anyhow::Result<regex_test::RegexTests> {
+/*fn suite() -> anyhow::Result<regex_test::RegexTests> {
     let _ = env_logger::try_init();
 
     let mut tests = regex_test::RegexTests::new();
@@ -67,7 +67,7 @@
     load!("fowler/repetition");
 
     Ok(tests)
-}
+}*/
 
 /// Configure a regex_automata::Input with the given test configuration.
 fn create_input<'h>(
--- a/tests/meta/suite.rs
+++ b/tests/meta/suite.rs
@@ -11,7 +11,7 @@
     },
 };
 
-use crate::{create_input, suite, testify_captures};
+use crate::{create_input, testify_captures};
 
 const BLACKLIST: &[&str] = &[
     // These 'earliest' tests are blacklisted because the meta searcher doesn't
@@ -27,7 +27,7 @@
 ];
 
 /// Tests the default configuration of the meta regex engine.
-#[test]
+/*#[test]
 fn default() -> Result<()> {
     let builder = Regex::builder();
     let mut runner = TestRunner::new()?;
@@ -37,10 +37,10 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the default configuration minus the full DFA.
-#[test]
+/*#[test]
 fn no_dfa() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(Regex::config().dfa(false));
@@ -51,10 +51,10 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the default configuration minus the full DFA and lazy DFA.
-#[test]
+/*#[test]
 fn no_dfa_hybrid() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(Regex::config().dfa(false).hybrid(false));
@@ -65,11 +65,11 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the default configuration minus the full DFA, lazy DFA and one-pass
 /// DFA.
-#[test]
+/*#[test]
 fn no_dfa_hybrid_onepass() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(Regex::config().dfa(false).hybrid(false).onepass(false));
@@ -80,11 +80,11 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 /// Tests the default configuration minus the full DFA, lazy DFA, one-pass
 /// DFA and backtracker.
-#[test]
+/*#[test]
 fn no_dfa_hybrid_onepass_backtrack() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(
@@ -101,7 +101,7 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
 fn compiler(
     mut builder: meta::Builder,
--- a/tests/nfa/thompson/backtrack/suite.rs
+++ b/tests/nfa/thompson/backtrack/suite.rs
@@ -15,10 +15,10 @@
     },
 };
 
-use crate::{create_input, suite, testify_captures};
+use crate::{create_input, testify_captures};
 
 /// Tests the default configuration of the bounded backtracker.
-#[test]
+/*#[test]
 fn default() -> Result<()> {
     let builder = BoundedBacktracker::builder();
     let mut runner = TestRunner::new()?;
@@ -34,10 +34,10 @@
     runner.blacklist("expensive/backtrack-blow-visited-capacity");
     runner.test_iter(suite()?.iter(), compiler(builder)).assert();
     Ok(())
-}
+}*/
 
 /// Tests the backtracker with prefilters enabled.
-#[test]
+/*#[test]
 fn prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -60,11 +60,11 @@
     runner.blacklist("expensive/backtrack-blow-visited-capacity");
     runner.test_iter(suite()?.iter(), my_compiler).assert();
     Ok(())
-}
+}*/
 
 /// Tests the bounded backtracker when its visited capacity is set to its
 /// minimum amount.
-#[test]
+/*#[test]
 fn min_visited_capacity() -> Result<()> {
     let mut runner = TestRunner::new()?;
     runner.expand(&["is_match", "find", "captures"], |test| test.compiles());
@@ -95,7 +95,7 @@
         })
         .assert();
     Ok(())
-}
+}*/
 
 fn compiler(
     mut builder: backtrack::Builder,
--- a/tests/nfa/thompson/pikevm/suite.rs
+++ b/tests/nfa/thompson/pikevm/suite.rs
@@ -14,20 +14,20 @@
     },
 };
 
-use crate::{create_input, suite, testify_captures, untestify_kind};
+use crate::{create_input, testify_captures, untestify_kind};
 
 /// Tests the default configuration of the hybrid NFA/DFA.
-#[test]
+/*#[test]
 fn default() -> Result<()> {
     let builder = PikeVM::builder();
     let mut runner = TestRunner::new()?;
     runner.expand(&["is_match", "find", "captures"], |test| test.compiles());
     runner.test_iter(suite()?.iter(), compiler(builder)).assert();
     Ok(())
-}
+}*/
 
 /// Tests the PikeVM with prefilters enabled.
-#[test]
+/*#[test]
 fn prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -48,7 +48,7 @@
     runner.expand(&["is_match", "find", "captures"], |test| test.compiles());
     runner.test_iter(suite()?.iter(), my_compiler).assert();
     Ok(())
-}
+}*/
 
 fn compiler(
     mut builder: pikevm::Builder,
