--- a/tests/dfa/onepass/suite.rs
+++ b/tests/dfa/onepass/suite.rs
@@ -5,17 +5,17 @@
         nfa::thompson,
         util::{iter, syntax},
     },
-    regex_test::{
+    /*regex_test::{
         CompiledRegex, Match, RegexTest, SearchKind, Span, TestResult,
         TestRunner,
-    },
+    },*/
 };
 
-use crate::{create_input, suite, testify_captures, untestify_kind};
+//use crate::{create_input, testify_captures, untestify_kind};
 
 const EXPANSIONS: &[&str] = &["is_match", "find", "captures"];
 
-/// Tests the default configuration of the hybrid NFA/DFA.
+/* /// Tests the default configuration of the hybrid NFA/DFA.
 #[test]
 fn default() -> Result<()> {
     let builder = DFA::builder();
@@ -24,9 +24,9 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
-/// Tests the hybrid NFA/DFA when 'starts_for_each_pattern' is enabled for all
+/* /// Tests the hybrid NFA/DFA when 'starts_for_each_pattern' is enabled for all
 /// tests.
 #[test]
 fn starts_for_each_pattern() -> Result<()> {
@@ -37,9 +37,9 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
-/// Tests the hybrid NFA/DFA when byte classes are disabled.
+/* /// Tests the hybrid NFA/DFA when byte classes are disabled.
 ///
 /// N.B. Disabling byte classes doesn't avoid any indirection at search time.
 /// All it does is cause every byte value to be its own distinct equivalence
@@ -53,9 +53,9 @@
         .test_iter(suite()?.iter(), compiler(builder))
         .assert();
     Ok(())
-}
+}*/
 
-fn compiler(
+/*fn compiler(
     mut builder: onepass::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     move |test, regexes| {
@@ -90,9 +90,9 @@
             run_test(&re, &mut cache, test)
         }))
     }
-}
+}*/
 
-fn run_test(
+/*fn run_test(
     re: &DFA,
     cache: &mut onepass::Cache,
     test: &RegexTest,
@@ -153,9 +153,9 @@
         },
         name => TestResult::fail(&format!("unrecognized test name: {name}")),
     }
-}
+}*/
 
-/// Configures the given regex builder with all relevant settings on the given
+/* /// Configures the given regex builder with all relevant settings on the given
 /// regex test.
 ///
 /// If the regex test has a setting that is unsupported, then this returns
@@ -178,20 +178,20 @@
         .syntax(config_syntax(test))
         .thompson(config_thompson(test));
     true
-}
+}*/
 
-/// Configuration of a Thompson NFA compiler from a regex test.
+/* /// Configuration of a Thompson NFA compiler from a regex test.
 fn config_thompson(test: &RegexTest) -> thompson::Config {
     let mut lookm = regex_automata::util::look::LookMatcher::new();
     lookm.set_line_terminator(test.line_terminator());
     thompson::Config::new().utf8(test.utf8()).look_matcher(lookm)
-}
+}*/
 
-/// Configuration of the regex parser from a regex test.
+/* /// Configuration of the regex parser from a regex test.
 fn config_syntax(test: &RegexTest) -> syntax::Config {
     syntax::Config::new()
         .case_insensitive(test.case_insensitive())
         .unicode(test.unicode())
         .utf8(test.utf8())
         .line_terminator(test.line_terminator())
-}
+}*/
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -191,9 +191,6 @@
 version = "1.0.3"
 default-features = false
 
-[dev-dependencies.regex-test]
-version = "0.1.0"
-
 [lints.rust.unexpected_cfgs]
 level = "allow"
 priority = 0
--- a/tests/dfa/suite.rs
+++ b/tests/dfa/suite.rs
@@ -9,18 +9,18 @@
         util::{prefilter::Prefilter, syntax},
         Anchored, Input, PatternSet,
     },
-    regex_test::{
+    /*regex_test::{
         CompiledRegex, Match, RegexTest, SearchKind, Span, TestResult,
         TestRunner,
-    },
+    },*/
 };
 
-use crate::{create_input, untestify_kind};
+//use crate::{create_input, untestify_kind};
 
 const EXPANSIONS: &[&str] = &["is_match", "find", "which"];
 
-/// Runs the test suite with the default configuration.
-/*#[test]
+/* /// Runs the test suite with the default configuration.
+#[test]
 fn unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     TestRunner::new()?
@@ -31,9 +31,9 @@
     Ok(())
 }*/
 
-/// Runs the test suite with the default configuration and a prefilter enabled,
+/* /// Runs the test suite with the default configuration and a prefilter enabled,
 /// if one can be built.
-/*#[test]
+#[test]
 fn unminimized_prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -62,8 +62,8 @@
     Ok(())
 }*/
 
-/// Runs the test suite with start states specialized.
-/*#[test]
+/* /// Runs the test suite with start states specialized.
+#[test]
 fn unminimized_specialized_start_states() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().specialize_start_states(true));
@@ -76,8 +76,8 @@
     Ok(())
 }*/
 
-/// Runs the test suite with byte classes disabled.
-/*#[test]
+/* /// Runs the test suite with byte classes disabled.
+#[test]
 fn unminimized_no_byte_class() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().byte_classes(false));
@@ -90,8 +90,8 @@
     Ok(())
 }*/
 
-/// Runs the test suite with NFA shrinking enabled.
-/*#[test]
+/* /// Runs the test suite with NFA shrinking enabled.
+#[test]
 fn unminimized_nfa_shrink() -> Result<()> {
     let mut builder = Regex::builder();
     builder.thompson(thompson::Config::new().shrink(true));
@@ -104,9 +104,9 @@
     Ok(())
 }*/
 
-/// Runs the test suite on a minimized DFA with an otherwise default
+/* /// Runs the test suite on a minimized DFA with an otherwise default
 /// configuration.
-/*#[test]
+#[test]
 fn minimized_default() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().minimize(true));
@@ -118,8 +118,8 @@
     Ok(())
 }*/
 
-/// Runs the test suite on a minimized DFA with byte classes disabled.
-/*#[test]
+/* /// Runs the test suite on a minimized DFA with byte classes disabled.
+#[test]
 fn minimized_no_byte_class() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dense(dense::Config::new().minimize(true).byte_classes(false));
@@ -132,8 +132,8 @@
     Ok(())
 }*/
 
-/// Runs the test suite on a sparse unminimized DFA.
-/*#[test]
+/* /// Runs the test suite on a sparse unminimized DFA.
+#[test]
 fn sparse_unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     TestRunner::new()?
@@ -144,8 +144,7 @@
     Ok(())
 }*/
 
-/// Runs the test suite on a sparse unminimized DFA with prefilters enabled.
-/*#[test]
+/* #[test]
 fn sparse_unminimized_prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -177,9 +176,9 @@
     Ok(())
 }*/
 
-/// Another basic sanity test that checks we can serialize and then deserialize
+/* /// Another basic sanity test that checks we can serialize and then deserialize
 /// a regex, and that the resulting regex can be used for searching correctly.
-/*#[test]
+#[test]
 fn serialization_unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     let my_compiler = |builder| {
@@ -206,10 +205,10 @@
     Ok(())
 }*/
 
-/// A basic sanity test that checks we can serialize and then deserialize a
+/* /// A basic sanity test that checks we can serialize and then deserialize a
 /// regex using sparse DFAs, and that the resulting regex can be used for
 /// searching correctly.
-/*#[test]
+#[test]
 fn sparse_serialization_unminimized_default() -> Result<()> {
     let builder = Regex::builder();
     let my_compiler = |builder| {
@@ -235,7 +234,7 @@
     Ok(())
 }*/
 
-fn dense_compiler(
+/* fn dense_compiler(
     builder: dfa::regex::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     compiler(builder, |_, _, re| {
@@ -243,9 +242,9 @@
             run_test(&re, test)
         }))
     })
-}
+}*/
 
-fn sparse_compiler(
+/*fn sparse_compiler(
     builder: dfa::regex::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     compiler(builder, |builder, _, re| {
@@ -256,9 +255,9 @@
             run_test(&re, test)
         }))
     })
-}
+}*/
 
-fn compiler(
+/* fn compiler(
     mut builder: dfa::regex::Builder,
     mut create_matcher: impl FnMut(
         &dfa::regex::Builder,
@@ -294,9 +293,9 @@
         }
         create_matcher(&builder, pre, builder.build_many(&regexes)?)
     }
-}
+}*/
 
-fn run_test<A: Automaton>(re: &Regex<A>, test: &RegexTest) -> TestResult {
+/*fn run_test<A: Automaton>(re: &Regex<A>, test: &RegexTest) -> TestResult {
     let input = create_input(test);
     match test.additional_name() {
         "is_match" => TestResult::matched(re.is_match(input.earliest(true))),
@@ -332,9 +331,9 @@
         },
         name => TestResult::fail(&format!("unrecognized test name: {name}")),
     }
-}
+}*/
 
-/// Configures the given regex builder with all relevant settings on the given
+/* /// Configures the given regex builder with all relevant settings on the given
 /// regex test.
 ///
 /// If the regex test has a setting that is unsupported, then this returns
@@ -379,18 +378,18 @@
     let mut lookm = regex_automata::util::look::LookMatcher::new();
     lookm.set_line_terminator(test.line_terminator());
     thompson::Config::new().utf8(test.utf8()).look_matcher(lookm)
-}
+}*/
 
-/// Configuration of the regex syntax from a regex test.
+/* /// Configuration of the regex syntax from a regex test.
 fn config_syntax(test: &RegexTest) -> syntax::Config {
     syntax::Config::new()
         .case_insensitive(test.case_insensitive())
         .unicode(test.unicode())
         .utf8(test.utf8())
         .line_terminator(test.line_terminator())
-}
+}*/
 
-/// Execute an overlapping search, and for each match found, also find its
+/* /// Execute an overlapping search, and for each match found, also find its
 /// overlapping starting positions.
 ///
 /// N.B. This routine used to be part of the crate API, but 1) it wasn't clear
@@ -440,4 +439,4 @@
         }
     }
     Ok(TestResult::matches(matches))
-}
+}*/
--- a/tests/hybrid/suite.rs
+++ b/tests/hybrid/suite.rs
@@ -9,18 +9,18 @@
         util::{prefilter::Prefilter, syntax},
         Anchored, Input, PatternSet,
     },
-    regex_test::{
+    /*regex_test::{
         CompiledRegex, Match, RegexTest, SearchKind, Span, TestResult,
         TestRunner,
-    },
+    },*/
 };
 
-use crate::{create_input, untestify_kind};
+//use crate::{create_input, untestify_kind};
 
 const EXPANSIONS: &[&str] = &["is_match", "find", "which"];
 
-/// Tests the default configuration of the hybrid NFA/DFA.
-/*#[test]
+/* /// Tests the default configuration of the hybrid NFA/DFA.
+#[test]
 fn default() -> Result<()> {
     let builder = Regex::builder();
     TestRunner::new()?
@@ -32,8 +32,8 @@
     Ok(())
 }*/
 
-/// Tests the hybrid NFA/DFA with prefilters enabled.
-/*#[test]
+/* /// Tests the hybrid NFA/DFA with prefilters enabled.
+#[test]
 fn prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -59,7 +59,7 @@
     Ok(())
 }*/
 
-/// Tests the hybrid NFA/DFA with NFA shrinking enabled.
+/* /// Tests the hybrid NFA/DFA with NFA shrinking enabled.
 ///
 /// This is *usually* not the configuration one wants for a lazy DFA. NFA
 /// shrinking is mostly only advantageous when building a full DFA since it
@@ -71,7 +71,7 @@
 /// Nevertheless, we test to make sure everything is OK with NFA shrinking. As
 /// a bonus, there are some tests we don't need to skip because they now fit in
 /// the default cache capacity.
-/*#[test]
+#[test]
 fn nfa_shrink() -> Result<()> {
     let mut builder = Regex::builder();
     builder.thompson(thompson::Config::new().shrink(true));
@@ -82,9 +82,9 @@
     Ok(())
 }*/
 
-/// Tests the hybrid NFA/DFA when 'starts_for_each_pattern' is enabled for all
+/* /// Tests the hybrid NFA/DFA when 'starts_for_each_pattern' is enabled for all
 /// tests.
-/*#[test]
+#[test]
 fn starts_for_each_pattern() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().starts_for_each_pattern(true));
@@ -97,8 +97,8 @@
     Ok(())
 }*/
 
-/// Tests the hybrid NFA/DFA when 'specialize_start_states' is enabled.
-/*#[test]
+/* /// Tests the hybrid NFA/DFA when 'specialize_start_states' is enabled.
+#[test]
 fn specialize_start_states() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().specialize_start_states(true));
@@ -111,12 +111,12 @@
     Ok(())
 }*/
 
-/// Tests the hybrid NFA/DFA when byte classes are disabled.
+/* /// Tests the hybrid NFA/DFA when byte classes are disabled.
 ///
 /// N.B. Disabling byte classes doesn't avoid any indirection at search time.
 /// All it does is cause every byte value to be its own distinct equivalence
 /// class.
-/*#[test]
+#[test]
 fn no_byte_classes() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().byte_classes(false));
@@ -129,13 +129,13 @@
     Ok(())
 }*/
 
-/// Tests that hybrid NFA/DFA never clears its cache for any test with the
+/* /// Tests that hybrid NFA/DFA never clears its cache for any test with the
 /// default capacity.
 ///
 /// N.B. If a regex suite test is added that causes the cache to be cleared,
 /// then this should just skip that test. (Which can be done by calling the
 /// 'blacklist' method on 'TestRunner'.)
-/*#[test]
+#[test]
 fn no_cache_clearing() -> Result<()> {
     let mut builder = Regex::builder();
     builder.dfa(DFA::config().minimum_cache_clear_count(Some(0)));
@@ -148,8 +148,8 @@
     Ok(())
 }*/
 
-/// Tests the hybrid NFA/DFA when the minimum cache capacity is set.
-/*#[test]
+/* /// Tests the hybrid NFA/DFA when the minimum cache capacity is set.
+#[test]
 fn min_cache_capacity() -> Result<()> {
     let mut builder = Regex::builder();
     builder
@@ -161,7 +161,7 @@
     Ok(())
 }*/
 
-fn compiler(
+/* fn compiler(
     mut builder: regex::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     move |test, regexes| {
@@ -189,9 +189,9 @@
             run_test(&re, &mut cache, test)
         }))
     }
-}
+} */
 
-fn run_test(
+/*fn run_test(
     re: &Regex,
     cache: &mut regex::Cache,
     test: &RegexTest,
@@ -234,9 +234,9 @@
         },
         name => TestResult::fail(&format!("unrecognized test name: {name}")),
     }
-}
+}*/
 
-/// Configures the given regex builder with all relevant settings on the given
+/* /// Configures the given regex builder with all relevant settings on the given
 /// regex test.
 ///
 /// If the regex test has a setting that is unsupported, then this returns
@@ -266,25 +266,25 @@
         .thompson(config_thompson(test))
         .dfa(dfa_config);
     true
-}
+}*/
 
-/// Configuration of a Thompson NFA compiler from a regex test.
+/* /// Configuration of a Thompson NFA compiler from a regex test.
 fn config_thompson(test: &RegexTest) -> thompson::Config {
     let mut lookm = regex_automata::util::look::LookMatcher::new();
     lookm.set_line_terminator(test.line_terminator());
     thompson::Config::new().utf8(test.utf8()).look_matcher(lookm)
-}
+}*/
 
-/// Configuration of the regex parser from a regex test.
+/* /// Configuration of the regex parser from a regex test.
 fn config_syntax(test: &RegexTest) -> syntax::Config {
     syntax::Config::new()
         .case_insensitive(test.case_insensitive())
         .unicode(test.unicode())
         .utf8(test.utf8())
         .line_terminator(test.line_terminator())
-}
+}*/
 
-/// Execute an overlapping search, and for each match found, also find its
+/* /// Execute an overlapping search, and for each match found, also find its
 /// overlapping starting positions.
 ///
 /// N.B. This routine used to be part of the crate API, but 1) it wasn't clear
@@ -344,4 +344,4 @@
         }
     }
     Ok(TestResult::matches(matches))
-}
+}*/
--- a/tests/lib.rs
+++ b/tests/lib.rs
@@ -69,7 +69,7 @@
     Ok(tests)
 }*/
 
-/// Configure a regex_automata::Input with the given test configuration.
+/* /// Configure a regex_automata::Input with the given test configuration.
 fn create_input<'h>(
     test: &'h regex_test::RegexTest,
 ) -> regex_automata::Input<'h> {
@@ -80,9 +80,9 @@
     regex_automata::Input::new(test.haystack())
         .range(bounds.start..bounds.end)
         .anchored(anchored)
-}
+}*/
 
-/// Convert capture matches into the test suite's capture values.
+/* /// Convert capture matches into the test suite's capture values.
 ///
 /// The given captures must represent a valid match, where the first capturing
 /// group has a non-None span. Otherwise this panics.
@@ -98,9 +98,9 @@
     // group being non-None.
     regex_test::Captures::new(caps.pattern().unwrap().as_usize(), spans)
         .unwrap()
-}
+}*/
 
-/// Convert a test harness match kind to a regex-automata match kind. If
+/* /// Convert a test harness match kind to a regex-automata match kind. If
 /// regex-automata doesn't support the harness kind, then `None` is returned.
 fn untestify_kind(
     kind: regex_test::MatchKind,
@@ -112,4 +112,4 @@
         }
         regex_test::MatchKind::LeftmostLongest => None,
     }
-}
+}*/
--- a/tests/meta/suite.rs
+++ b/tests/meta/suite.rs
@@ -5,13 +5,13 @@
         util::syntax,
         MatchKind, PatternSet,
     },
-    regex_test::{
+    /*regex_test::{
         CompiledRegex, Match, RegexTest, SearchKind, Span, TestResult,
         TestRunner,
-    },
+    },*/
 };
 
-use crate::{create_input, testify_captures};
+//use crate::{create_input, testify_captures};
 
 const BLACKLIST: &[&str] = &[
     // These 'earliest' tests are blacklisted because the meta searcher doesn't
@@ -26,8 +26,8 @@
     "earliest/",
 ];
 
-/// Tests the default configuration of the meta regex engine.
-/*#[test]
+/* /// Tests the default configuration of the meta regex engine.
+#[test]
 fn default() -> Result<()> {
     let builder = Regex::builder();
     let mut runner = TestRunner::new()?;
@@ -39,8 +39,8 @@
     Ok(())
 }*/
 
-/// Tests the default configuration minus the full DFA.
-/*#[test]
+/* /// Tests the default configuration minus the full DFA.
+#[test]
 fn no_dfa() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(Regex::config().dfa(false));
@@ -53,8 +53,8 @@
     Ok(())
 }*/
 
-/// Tests the default configuration minus the full DFA and lazy DFA.
-/*#[test]
+/* /// Tests the default configuration minus the full DFA and lazy DFA.
+#[test]
 fn no_dfa_hybrid() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(Regex::config().dfa(false).hybrid(false));
@@ -67,9 +67,9 @@
     Ok(())
 }*/
 
-/// Tests the default configuration minus the full DFA, lazy DFA and one-pass
+/* /// Tests the default configuration minus the full DFA, lazy DFA and one-pass
 /// DFA.
-/*#[test]
+#[test]
 fn no_dfa_hybrid_onepass() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(Regex::config().dfa(false).hybrid(false).onepass(false));
@@ -82,9 +82,9 @@
     Ok(())
 }*/
 
-/// Tests the default configuration minus the full DFA, lazy DFA, one-pass
+/* /// Tests the default configuration minus the full DFA, lazy DFA, one-pass
 /// DFA and backtracker.
-/*#[test]
+#[test]
 fn no_dfa_hybrid_onepass_backtrack() -> Result<()> {
     let mut builder = Regex::builder();
     builder.configure(
@@ -103,7 +103,7 @@
     Ok(())
 }*/
 
-fn compiler(
+/*fn compiler(
     mut builder: meta::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     move |test, regexes| {
@@ -115,9 +115,9 @@
             run_test(&re, test)
         }))
     }
-}
+}*/
 
-fn run_test(re: &Regex, test: &RegexTest) -> TestResult {
+/*fn run_test(re: &Regex, test: &RegexTest) -> TestResult {
     let input = create_input(test);
     match test.additional_name() {
         "is_match" => TestResult::matched(re.is_match(input)),
@@ -188,13 +188,13 @@
         .line_terminator(test.line_terminator());
     builder.configure(meta_config).syntax(config_syntax(test));
     true
-}
+}*/
 
-/// Configuration of the regex parser from a regex test.
+/* /// Configuration of the regex parser from a regex test.
 fn config_syntax(test: &RegexTest) -> syntax::Config {
     syntax::Config::new()
         .case_insensitive(test.case_insensitive())
         .unicode(test.unicode())
         .utf8(test.utf8())
         .line_terminator(test.line_terminator())
-}
+}*/
--- a/tests/nfa/thompson/backtrack/suite.rs
+++ b/tests/nfa/thompson/backtrack/suite.rs
@@ -9,16 +9,16 @@
         util::{prefilter::Prefilter, syntax},
         Input,
     },
-    regex_test::{
+    /*regex_test::{
         CompiledRegex, Match, MatchKind, RegexTest, SearchKind, Span,
         TestResult, TestRunner,
-    },
+    },*/
 };
 
-use crate::{create_input, testify_captures};
+//use crate::{create_input, testify_captures};
 
-/// Tests the default configuration of the bounded backtracker.
-/*#[test]
+/* /// Tests the default configuration of the bounded backtracker.
+#[test]
 fn default() -> Result<()> {
     let builder = BoundedBacktracker::builder();
     let mut runner = TestRunner::new()?;
@@ -36,8 +36,8 @@
     Ok(())
 }*/
 
-/// Tests the backtracker with prefilters enabled.
-/*#[test]
+/* /// Tests the backtracker with prefilters enabled.
+#[test]
 fn prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -62,9 +62,9 @@
     Ok(())
 }*/
 
-/// Tests the bounded backtracker when its visited capacity is set to its
+/* /// Tests the bounded backtracker when its visited capacity is set to its
 /// minimum amount.
-/*#[test]
+#[test]
 fn min_visited_capacity() -> Result<()> {
     let mut runner = TestRunner::new()?;
     runner.expand(&["is_match", "find", "captures"], |test| test.compiles());
@@ -97,7 +97,7 @@
     Ok(())
 }*/
 
-fn compiler(
+/* fn compiler(
     mut builder: backtrack::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     move |test, regexes| {
@@ -110,9 +110,9 @@
             run_test(&re, &mut cache, test)
         }))
     }
-}
+}*/
 
-fn run_test(
+/*fn run_test(
     re: &BoundedBacktracker,
     cache: &mut backtrack::Cache,
     test: &RegexTest,
@@ -194,20 +194,20 @@
         .syntax(config_syntax(test))
         .thompson(config_thompson(test));
     true
-}
+}*/
 
-/// Configuration of a Thompson NFA compiler from a regex test.
+/* /// Configuration of a Thompson NFA compiler from a regex test.
 fn config_thompson(test: &RegexTest) -> thompson::Config {
     let mut lookm = regex_automata::util::look::LookMatcher::new();
     lookm.set_line_terminator(test.line_terminator());
     thompson::Config::new().utf8(test.utf8()).look_matcher(lookm)
-}
+}*/
 
-/// Configuration of the regex parser from a regex test.
+/* /// Configuration of the regex parser from a regex test.
 fn config_syntax(test: &RegexTest) -> syntax::Config {
     syntax::Config::new()
         .case_insensitive(test.case_insensitive())
         .unicode(test.unicode())
         .utf8(test.utf8())
         .line_terminator(test.line_terminator())
-}
+}*/
--- a/tests/nfa/thompson/pikevm/suite.rs
+++ b/tests/nfa/thompson/pikevm/suite.rs
@@ -8,16 +8,16 @@
         util::{prefilter::Prefilter, syntax},
         PatternSet,
     },
-    regex_test::{
+    /*regex_test::{
         CompiledRegex, Match, RegexTest, SearchKind, Span, TestResult,
         TestRunner,
-    },
+    },*/
 };
 
-use crate::{create_input, testify_captures, untestify_kind};
+//use crate::{create_input, testify_captures, untestify_kind};
 
-/// Tests the default configuration of the hybrid NFA/DFA.
-/*#[test]
+/* /// Tests the default configuration of the hybrid NFA/DFA.
+#[test]
 fn default() -> Result<()> {
     let builder = PikeVM::builder();
     let mut runner = TestRunner::new()?;
@@ -26,8 +26,8 @@
     Ok(())
 }*/
 
-/// Tests the PikeVM with prefilters enabled.
-/*#[test]
+/* /// Tests the PikeVM with prefilters enabled.
+#[test]
 fn prefilter() -> Result<()> {
     let my_compiler = |test: &RegexTest, regexes: &[String]| {
         // Parse regexes as HIRs so we can get literals to build a prefilter.
@@ -50,7 +50,7 @@
     Ok(())
 }*/
 
-fn compiler(
+/* fn compiler(
     mut builder: pikevm::Builder,
 ) -> impl FnMut(&RegexTest, &[String]) -> Result<CompiledRegex> {
     move |test, regexes| {
@@ -63,9 +63,9 @@
             run_test(&re, &mut cache, test)
         }))
     }
-}
+}*/
 
-fn run_test(
+/*fn run_test(
     re: &PikeVM,
     cache: &mut pikevm::Cache,
     test: &RegexTest,
@@ -122,9 +122,9 @@
         },
         name => TestResult::fail(&format!("unrecognized test name: {name}")),
     }
-}
+}*/
 
-/// Configures the given regex builder with all relevant settings on the given
+/* /// Configures the given regex builder with all relevant settings on the given
 /// regex test.
 ///
 /// If the regex test has a setting that is unsupported, then this returns
@@ -143,20 +143,20 @@
         .syntax(config_syntax(test))
         .thompson(config_thompson(test));
     true
-}
+}*/
 
-/// Configuration of a Thompson NFA compiler from a regex test.
+/* /// Configuration of a Thompson NFA compiler from a regex test.
 fn config_thompson(test: &RegexTest) -> thompson::Config {
     let mut lookm = regex_automata::util::look::LookMatcher::new();
     lookm.set_line_terminator(test.line_terminator());
     thompson::Config::new().utf8(test.utf8()).look_matcher(lookm)
-}
+}*/
 
-/// Configuration of the regex parser from a regex test.
+/* /// Configuration of the regex parser from a regex test.
 fn config_syntax(test: &RegexTest) -> syntax::Config {
     syntax::Config::new()
         .case_insensitive(test.case_insensitive())
         .unicode(test.unicode())
         .utf8(test.utf8())
         .line_terminator(test.line_terminator())
-}
+}*/
