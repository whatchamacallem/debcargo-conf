Index: zerocopy/Cargo.toml
===================================================================
--- zerocopy.orig/Cargo.toml
+++ zerocopy/Cargo.toml
@@ -96,9 +96,6 @@ optional = true
 [dev-dependencies.either]
 version = "1.13.0"
 
-[dev-dependencies.elain]
-version = "0.3.0"
-
 [dev-dependencies.itertools]
 version = "0.13"
 
Index: zerocopy/src/error.rs
===================================================================
--- zerocopy.orig/src/error.rs
+++ zerocopy/src/error.rs
@@ -1000,53 +1000,53 @@ mod tests {
             bytes: [u8; 128],
         }
 
-        impl_known_layout!(elain::Align::<8>);
+        //impl_known_layout!(elain::Align::<8>);
 
         let aligned = Aligned { bytes: [0; 128] };
 
         let bytes = &aligned.bytes[1..];
         let addr = crate::util::AsAddress::addr(bytes);
-        assert_eq!(
+        /*assert_eq!(
             AlignmentError::<_, elain::Align::<8>>::new_checked(bytes).to_string(),
             format!("The conversion failed because the address of the source is not a multiple of the alignment of the destination type.\n\
             \nSource type: &[u8]\
             \nSource address: 0x{:x} (a multiple of 1)\
             \nDestination type: elain::Align<8>\
             \nDestination alignment: 8", addr)
-        );
+        );*/
 
         let bytes = &aligned.bytes[2..];
         let addr = crate::util::AsAddress::addr(bytes);
-        assert_eq!(
+        /*assert_eq!(
             AlignmentError::<_, elain::Align::<8>>::new_checked(bytes).to_string(),
             format!("The conversion failed because the address of the source is not a multiple of the alignment of the destination type.\n\
             \nSource type: &[u8]\
             \nSource address: 0x{:x} (a multiple of 2)\
             \nDestination type: elain::Align<8>\
             \nDestination alignment: 8", addr)
-        );
+        );*/
 
         let bytes = &aligned.bytes[3..];
         let addr = crate::util::AsAddress::addr(bytes);
-        assert_eq!(
+        /*assert_eq!(
             AlignmentError::<_, elain::Align::<8>>::new_checked(bytes).to_string(),
             format!("The conversion failed because the address of the source is not a multiple of the alignment of the destination type.\n\
             \nSource type: &[u8]\
             \nSource address: 0x{:x} (a multiple of 1)\
             \nDestination type: elain::Align<8>\
             \nDestination alignment: 8", addr)
-        );
+        );*/
 
         let bytes = &aligned.bytes[4..];
         let addr = crate::util::AsAddress::addr(bytes);
-        assert_eq!(
+        /*assert_eq!(
             AlignmentError::<_, elain::Align::<8>>::new_checked(bytes).to_string(),
             format!("The conversion failed because the address of the source is not a multiple of the alignment of the destination type.\n\
             \nSource type: &[u8]\
             \nSource address: 0x{:x} (a multiple of 4)\
             \nDestination type: elain::Align<8>\
             \nDestination alignment: 8", addr)
-        );
+        );*/
     }
 
     #[test]
Index: zerocopy/src/layout.rs
===================================================================
--- zerocopy.orig/src/layout.rs
+++ zerocopy/src/layout.rs
@@ -828,7 +828,7 @@ mod tests {
     use super::*;
 
     /// Tests of when a sized `DstLayout` is extended with a sized field.
-    #[allow(clippy::decimal_literal_representation)]
+    /*#[allow(clippy::decimal_literal_representation)]
     #[test]
     fn test_dst_layout_extend_sized_with_sized() {
         // This macro constructs a layout corresponding to a `u8` and extends it
@@ -888,7 +888,7 @@ mod tests {
         test_align_is_size!(33554432);
         test_align_is_size!(134217728);
         test_align_is_size!(268435456);
-    }
+    }*/
 
     /// Tests of when a sized `DstLayout` is extended with a DST field.
     #[test]
Index: zerocopy/src/lib.rs
===================================================================
--- zerocopy.orig/src/lib.rs
+++ zerocopy/src/lib.rs
@@ -5744,7 +5744,7 @@ mod tests {
         test!(str, layout(0, 1, Some(1)));
     }
 
-    #[cfg(feature = "derive")]
+    /*#[cfg(feature = "derive")]
     #[test]
     fn test_known_layout_derive() {
         // In this and other files (`late_compile_pass.rs`,
@@ -6143,7 +6143,7 @@ mod tests {
         struct KLF4(NotKnownLayout<u8>, NotKnownLayout<AU16>, NotKnownLayout<AU32>, [u8]);
 
         assert_eq!(<KLF4 as KnownLayout>::LAYOUT, unsized_layout(4, 1, 8));
-    }
+    }*/
 
     #[test]
     fn test_object_safety() {
