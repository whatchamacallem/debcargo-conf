From: Michael Tokarev <mjt@tls.msk.ru>
Date: Wed, 1 Jan 2025 22:50:15 +0300
Subject: Revert "Add command line options for UID/GID translation"

This reverts commit b83204f1e97ad8a324e147376200a35441c26196.

Temporarily, because of difficulties with the newly used crates.
---
 README.md                 |  55 --------
 src/main.rs               |  43 +-----
 src/passthrough/mod.rs    |  35 +----
 src/soft_idmap/cmdline.rs | 288 --------------------------------------
 src/soft_idmap/mod.rs     | 169 +---------------------
 5 files changed, 7 insertions(+), 583 deletions(-)
 delete mode 100644 src/soft_idmap/cmdline.rs

diff --git a/README.md b/README.md
index 0c692c2..3b44593 100644
--- a/README.md
+++ b/README.md
@@ -334,61 +334,6 @@ This range can be mapped to the GIDs [0, 65535] in virtiofsd’s user namespace
 Alternatively, you can simply map your own GID to a single GID in the namespace:
 For example, --gid-map=:0:1000:1: would map GID 1000 to root’s GID in the namespace (and thus the guest).
 
-```shell
---translate-uid=guest:<guest base UID>:<host base UID>:<count>
---translate-uid=host:<host base UID>:<guest base UID>:<count>
---translate-uid=squash-guest:<guest base UID>:<host UID>:<count>
---translate-uid=squash-host:<host base UID>:<guest UID>:<count>
---translate-uid=forbid-guest:<guest base UID>:<count>
---translate-uid=map:<guest base UID>:<host base UID>:<count>
-```
-Set up a map for virtiofsd to internally translate between host and guest UIDs.  As opposed to `--uid-map`, this option
-does not require a user namespace, and may freely be used regardless of whether virtiofsd runs as root or not.
-
-Mapping from guest UIDs to host UIDs is independent from the reverse, i.e. setting up a *guest* or *squash-guest*
-mapping only instructs virtiofsd to follow this guest-to-host mapping, it does not imply any potentially corresponding
-host-to-guest mapping.  The only exception is the prefix-less form, which sets up a bidirectional mapping.
-
-- `guest:<guest base UID>:<host base UID>:<count>`: Maps the range [guest base UID, guest base UID + count) 1:1 to [host
-  base UID, host base UID + count), i.e. `guest UID ↦ host base UID + (guest UID - guest base UID)`.
-- `host:<host base UID>:<guest base UID>:<count>`: Reverse of the above, i.e. maps the range [host base UID, host base
-  UID + count) to [guest base UID, guest base UID + count); `host UID ↦ guest base UID + (host UID - host base UID)`.
-- `squash-guest:<guest base UID>:<host UID>:<count>`: Maps everything in the range [guest base UID, guest base UID +
-  count) to the single given host UID, i.e. `guest UID ↦ host UID`.
-- `squash-host:<host base UID>:<guest UID>:<count>`: Reverse of the above, i.e. maps the range [host base UID, host base
-  UID + count) to the single given guest UID, i.e. `host UID ↦ guest UID`.
-- `forbid-guest:<guest base UID>:<count>`: Prohibits use of guest UIDs in the given range: Returns an error to the guest
-  whenever it tries to use a UID in that range for a new file or assign such a UID to an existing file.
-- `map:<guest base UID>:<host base UID>:<count>`: Sets up a bidirectional 1:1 mapping between [guest base UID, guest
-  base UID + count) and [host base UID, host base UID + count), i.e. the same as passing both `guest:<guest base
-  UID>:<host base UID>:<count>` and `host:<host base UID>:<guest base UID>:<count>`.
-
-When giving multiple mappings, their source ranges must not overlap.
-
-Neither of `--translate-uid` and `--translate-gid` can be used together with `--posix-acl`; translating UIDs or GIDs in
-virtiofsd would break posix ACLs.
-
-Example use case: virtiofsd runs unprivileged with UID:GID 1001:100.  It cannot change its own UID/GID, so attempting to
-let the guest create files with any other UID/GID combination will fail.  By using `--translate-uid` and
-`--translate-gid`, however, a mapping from guest UIDs/GIDs can be set up such that virtiofsd will create files under the
-only combination that it can, which is 1001:100.  For example, to allow any guest user to create a file, we can squash
-everything to 1001:100, which will create all those files as 1001:100 on the host.  In the guest, we may want to have
-those files appear as 1000:1000, though, and all other UIDs and GIDs should be visible unchanged in the guest.  That
-would look like so:
-
-```shell
-virtiofsd [...] \
-    --translate-uid squash-guest:0:1001:4294967295 \
-    --translate-gid squash-guest:0:100:4294967295 \
-    --translate-uid host:1001:1000:1 \
-    --translate-gid host:100:1000:1
-```
-
-```shell
---translate-gid=<type>:<source base GID>:<target base GID>:<count>
-```
-Same as `--translate-uid`, but for GIDs.
-
 ```shell
 --migration-mode=<find-paths|file-handles>
 ```
diff --git a/src/main.rs b/src/main.rs
index 0ca37a8..49198ab 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -30,7 +30,7 @@ use virtiofsd::sandbox::{Sandbox, SandboxMode};
 use virtiofsd::seccomp::{enable_seccomp, SeccompAction};
 use virtiofsd::util::write_pid_file;
 use virtiofsd::vhost_user::{Error, VhostUserFsBackendBuilder, MAX_TAG_LEN};
-use virtiofsd::{limits, oslib, soft_idmap};
+use virtiofsd::{limits, oslib};
 use vm_memory::{GuestMemoryAtomic, GuestMemoryMmap};
 
 type Result<T> = std::result::Result<T, Error>;
@@ -262,9 +262,6 @@ struct Opt {
     /// Map a range of UIDs from the host into the namespace, given as
     /// :namespace_uid:host_uid:count:
     ///
-    /// As opposed to '--translate-uid', this mapping is not done by virtiofsd, but by the
-    /// user namespace into which virtiofsd is placed via '--sandbox=namespace'.
-    ///
     /// For example, :0:100000:65536: will map the 65536 host UIDs [100000, 165535]
     /// into the namespace as [0, 65535].
     ///
@@ -275,9 +272,6 @@ struct Opt {
     /// Map a range of GIDs from the host into the namespace, given as
     /// :namespace_gid:host_gid:count:
     ///
-    /// As opposed to '--translate-gid', this mapping is not done by virtiofsd, but by the
-    /// user namespace into which virtiofsd is placed via '--sandbox=namespace'.
-    ///
     /// For example, :0:100000:65536: will map the 65536 host GIDs [100000, 165535]
     /// into the namespace as [0, 65535].
     ///
@@ -285,39 +279,6 @@ struct Opt {
     #[arg(long)]
     gid_map: Vec<GidMap>,
 
-    /// Describe how to translate UIDs between guest and host, given as
-    /// '<type>:<source base>:<target base>:<count>'.
-    ///
-    /// As opposed to '--uid-map', this mapping is done internally by virtiofsd, and does not
-    /// require using a user namespace.
-    ///
-    /// 'type' describes how to do the mapping, and in which direction:
-    ///
-    /// - 'guest': 1:1 map a range of guest UIDs to host UIDs
-    ///
-    /// - 'host': 1:1 map a range of host UIDs to guest UIDs
-    ///
-    /// - 'squash-guest': n:1 map a range of guest UIDs all to a single host UID
-    ///
-    /// - 'squash-host': n:1 map a range of host UIDs all to a single guest UID
-    ///
-    /// - 'forbid-guest': Forbid guest UIDs in the given range: Return an error to the guest
-    ///   whenever it tries to create a file with such a UID or make a file have such a UID
-    ///
-    /// - 'map': bidirectionally 1:1 map between a range of guest UIDs and host UIDs; the
-    ///   order is: 'map:<guest base>:<host base>:<count>'
-    ///
-    /// Provide this argument multiple times to map multiple UID ranges.
-    ///
-    /// Cannot be used together with --posix-acl; translating UIDs (or GIDs) in virtiofsd would
-    /// break posix ACLs.
-    #[arg(long, conflicts_with = "posix_acl")]
-    translate_uid: Vec<soft_idmap::cmdline::IdMap>,
-
-    /// Same as '--translate-uid', but for GIDs.
-    #[arg(long, conflicts_with = "posix_acl")]
-    translate_gid: Vec<soft_idmap::cmdline::IdMap>,
-
     /// Preserve O_NOATIME behavior, otherwise automatically clean up O_NOATIME flag to prevent
     /// potential permission errors when running in unprivileged mode (e.g., when accessing files
     /// without having ownership/capability to use O_NOATIME).
@@ -818,8 +779,6 @@ fn main() {
         migration_verify_handles: opt.migration_verify_handles,
         migration_confirm_paths: opt.migration_confirm_paths,
         migration_mode: opt.migration_mode,
-        uid_map: Some(opt.translate_uid),
-        gid_map: Some(opt.translate_gid),
         ..Default::default()
     };
 
diff --git a/src/passthrough/mod.rs b/src/passthrough/mod.rs
index 8bf6a21..fcaf0e1 100644
--- a/src/passthrough/mod.rs
+++ b/src/passthrough/mod.rs
@@ -27,7 +27,7 @@ use crate::passthrough::util::{
     ebadf, is_safe_inode, openat, openat_verbose, reopen_fd_through_proc,
 };
 use crate::read_dir::ReadDir;
-use crate::soft_idmap::{self, GuestGid, GuestUid, HostGid, HostUid, Id, IdMap};
+use crate::soft_idmap::{GuestGid, GuestUid, HostGid, HostUid, Id, IdMap};
 use crate::util::{other_io_error, ResultErrorContext};
 use crate::{fuse, oslib};
 use file_handle::{FileHandle, FileOrHandle, OpenableFileHandle};
@@ -35,7 +35,6 @@ use mount_fd::{MPRError, MountFds};
 use stat::{statx, StatExt};
 use std::borrow::Cow;
 use std::collections::{btree_map, BTreeMap};
-use std::convert::TryInto;
 use std::ffi::{CStr, CString};
 use std::fs::File;
 use std::io;
@@ -372,20 +371,6 @@ pub struct Config {
     ///
     /// The default is `FindPaths`.
     pub migration_mode: MigrationMode,
-
-    /**
-     * UID map parameters given on the command line.
-     *
-     * Is `take()`n when `PassthroughFs` is created, i.e. `None` during runtime.
-     */
-    pub uid_map: Option<Vec<soft_idmap::cmdline::IdMap>>,
-
-    /**
-     * GID map parameters given on the command line.
-     *
-     * Is `take()`n when `PassthroughFs` is created, i.e. `None` during runtime.
-     */
-    pub gid_map: Option<Vec<soft_idmap::cmdline::IdMap>>,
 }
 
 impl Default for Config {
@@ -415,8 +400,6 @@ impl Default for Config {
             migration_verify_handles: false,
             migration_confirm_paths: false,
             migration_mode: MigrationMode::FindPaths,
-            uid_map: None,
-            gid_map: None,
         }
     }
 }
@@ -518,18 +501,6 @@ impl PassthroughFs {
             Some(MountFds::new(mountinfo_fd, cfg.mountinfo_prefix.clone()))
         };
 
-        let uid_map = if let Some(map) = cfg.uid_map.take() {
-            map.try_into().err_context(|| "UID map")?
-        } else {
-            IdMap::empty()
-        };
-
-        let gid_map = if let Some(map) = cfg.gid_map.take() {
-            map.try_into().err_context(|| "GID map")?
-        } else {
-            IdMap::empty()
-        };
-
         let mut fs = PassthroughFs {
             inodes: Default::default(),
             next_inode: AtomicU64::new(fuse::ROOT_ID + 1),
@@ -545,8 +516,8 @@ impl PassthroughFs {
             os_facts: oslib::OsFacts::new(),
             track_migration_info: AtomicBool::new(false),
             cfg,
-            uid_map,
-            gid_map,
+            uid_map: IdMap::empty(),
+            gid_map: IdMap::empty(),
         };
 
         // Check to see if the client remapped "security.capability", if so,
diff --git a/src/soft_idmap/cmdline.rs b/src/soft_idmap/cmdline.rs
deleted file mode 100644
index 8038741..0000000
--- a/src/soft_idmap/cmdline.rs
+++ /dev/null
@@ -1,288 +0,0 @@
-// Copyright 2024 Red Hat, Inc. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-/*!
- * Provides structures to represent ID maps on the command line.
- *
- * The actual conversion of the [`Vec<cmdline::IdMap>`](IdMap) we get from the command line to a
- * proper [`super::IdMap`] for runtime use is implemented in [`super`]
- * ([`super::IdMap as
- * TryFrom<Vec<cmdline::IdMap>>`](`super::IdMap#impl-TryFrom<Vec<IdMap>>-for-IdMap<Guest,+Host>`)).
- */
-
-use std::fmt::{self, Display, Formatter};
-use std::num::ParseIntError;
-use std::str::FromStr;
-
-/// Command-line configuration for UID/GID translation between host and guest.
-#[derive(Clone, Debug)]
-pub enum IdMap {
-    /// 1:1 translate a guest ID range to a host ID range.
-    Guest {
-        /// First ID in the guest range.
-        from_guest: u32,
-        /// First ID in the host range.
-        to_host: u32,
-        /// Range length.
-        count: u32,
-    },
-
-    /// 1:1 translate a host ID range to a guest ID range.
-    Host {
-        /// First ID in the host range.
-        from_host: u32,
-        /// First ID in the guest range.
-        to_guest: u32,
-        /// Range length.
-        count: u32,
-    },
-
-    /// n:1 translate a guest ID range to a single host ID.
-    SquashGuest {
-        /// First ID in the guest range.
-        from_guest: u32,
-        /// Single target host ID.
-        to_host: u32,
-        /// Guest range length.
-        count: u32,
-    },
-
-    /// n:1 translate a host ID range to a single guest ID.
-    SquashHost {
-        /// First ID in the host range.
-        from_host: u32,
-        /// Single target guest ID.
-        to_guest: u32,
-        /// Host range length.
-        count: u32,
-    },
-
-    /// 1:1 translate between a guest ID range and a host ID range, both directions.
-    Bidirectional {
-        /// First ID in the guest range.
-        guest: u32,
-        /// First ID in the host range.
-        host: u32,
-        /// Range length.
-        count: u32,
-    },
-
-    /// Prohibit using the given range of guest IDs, returning an error when attempted.
-    ForbidGuest {
-        /// First ID in the guest range.
-        from_guest: u32,
-        /// Range length.
-        count: u32,
-    },
-}
-
-/// Errors that can occur when parsing an `IdMap` argument.
-#[derive(Debug)]
-pub enum IdMapError {
-    /// Invalid/unknown mapping type prefix.
-    InvalidPrefix(
-        /// The prefix in question.
-        String,
-    ),
-
-    /// Invalid number of arguments.
-    InvalidLength {
-        /// Number of arguments expected.
-        expected: usize,
-        /// Number of arguments actually seen.
-        seen: usize,
-    },
-
-    /// Error parsing an integer.
-    InvalidValue {
-        /// The value in question that could not be parsed.
-        value: String,
-        /// The error we got.
-        error: ParseIntError,
-    },
-}
-
-impl std::error::Error for IdMapError {}
-
-impl Display for IdMapError {
-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
-        match self {
-            IdMapError::InvalidPrefix(prefix) => write!(f, "Invalid ID map prefix {prefix}"),
-            IdMapError::InvalidLength { expected, seen } => write!(
-                f,
-                "Invalid ID map length (expected {expected} elements, got {seen} elements)"
-            ),
-            IdMapError::InvalidValue { value, error } => {
-                write!(f, "Invalid value {value} in ID map: {error}")
-            }
-        }
-    }
-}
-
-impl FromStr for IdMap {
-    type Err = IdMapError;
-
-    fn from_str(s: &str) -> Result<Self, IdMapError> {
-        let (prefix, fields) = Self::pre_parse(s)?;
-
-        match prefix.as_str() {
-            "guest" => {
-                Self::check_arg_count(&fields, 3)?;
-                Ok(IdMap::Guest {
-                    from_guest: fields[0],
-                    to_host: fields[1],
-                    count: fields[2],
-                })
-            }
-
-            "host" => {
-                Self::check_arg_count(&fields, 3)?;
-                Ok(IdMap::Host {
-                    from_host: fields[0],
-                    to_guest: fields[1],
-                    count: fields[2],
-                })
-            }
-
-            "squash-guest" => {
-                Self::check_arg_count(&fields, 3)?;
-                Ok(IdMap::SquashGuest {
-                    from_guest: fields[0],
-                    to_host: fields[1],
-                    count: fields[2],
-                })
-            }
-
-            "squash-host" => {
-                Self::check_arg_count(&fields, 3)?;
-                Ok(IdMap::SquashHost {
-                    from_host: fields[0],
-                    to_guest: fields[1],
-                    count: fields[2],
-                })
-            }
-
-            "forbid-guest" => {
-                Self::check_arg_count(&fields, 2)?;
-                Ok(IdMap::ForbidGuest {
-                    from_guest: fields[0],
-                    count: fields[1],
-                })
-            }
-
-            "map" => {
-                Self::check_arg_count(&fields, 3)?;
-                Ok(IdMap::Bidirectional {
-                    guest: fields[0],
-                    host: fields[1],
-                    count: fields[2],
-                })
-            }
-
-            _ => Err(IdMapError::InvalidPrefix(prefix)),
-        }
-    }
-}
-
-impl Display for IdMap {
-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
-        match self {
-            IdMap::Guest {
-                from_guest,
-                to_host,
-                count,
-            } => {
-                write!(f, "guest:{from_guest}:{to_host}:{count}")
-            }
-            IdMap::Host {
-                from_host,
-                to_guest,
-                count,
-            } => {
-                write!(f, "host:{from_host}:{to_guest}:{count}")
-            }
-            IdMap::SquashGuest {
-                from_guest,
-                to_host,
-                count,
-            } => {
-                write!(f, "squash-guest:{from_guest}:{to_host}:{count}")
-            }
-            IdMap::SquashHost {
-                from_host,
-                to_guest,
-                count,
-            } => {
-                write!(f, "squash-host:{from_host}:{to_guest}:{count}")
-            }
-            IdMap::ForbidGuest { from_guest, count } => {
-                write!(f, "forbid-guest:{from_guest}:{count}")
-            }
-            IdMap::Bidirectional { guest, host, count } => {
-                write!(f, "map:{guest}:{host}:{count}")
-            }
-        }
-    }
-}
-
-impl IdMap {
-    /**
-     * Helper for [`Self::from_str()`].
-     *
-     * Pre-parse an argument of the form `/^[a-zA-Z0-9_-]*(:[0-9]+){expected_len}$/` (separator
-     * given as a colon here, but is allowed to be any non-alphanumeric separator except `-` and
-     * `_`, though it must be the same for all fields).
-     *
-     * The prefix is returned as a string, the remaining numerical values as a parsed vector.
-     */
-    fn pre_parse(s: &str) -> Result<(String, Vec<u32>), IdMapError> {
-        let mut chars = s.chars();
-        let mut prefix = String::new();
-
-        let separator = loop {
-            let Some(c) = chars.next() else {
-                return Err(IdMapError::InvalidLength {
-                    // Not entirely right, but not entirely wrong either.  1 argument is always
-                    // expected.
-                    expected: 1,
-                    seen: 0,
-                });
-            };
-
-            if c.is_alphanumeric() || c == '-' || c == '_' {
-                for c in c.to_lowercase() {
-                    prefix.push(c);
-                }
-            } else {
-                break c;
-            }
-        };
-
-        let values: Vec<&str> = chars.as_str().split(separator).collect();
-
-        let values = values
-            .into_iter()
-            .map(|v| {
-                v.parse().map_err(|error| IdMapError::InvalidValue {
-                    value: String::from(v),
-                    error,
-                })
-            })
-            .collect::<Result<Vec<u32>, IdMapError>>()?;
-
-        Ok((prefix, values))
-    }
-
-    /// Verifies that `args`’s length is `expected_count`, returning an error otherwise.
-    fn check_arg_count(args: &[u32], expected_count: usize) -> Result<(), IdMapError> {
-        if args.len() != expected_count {
-            Err(IdMapError::InvalidLength {
-                expected: expected_count,
-                seen: args.len(),
-            })
-        } else {
-            Ok(())
-        }
-    }
-}
diff --git a/src/soft_idmap/mod.rs b/src/soft_idmap/mod.rs
index 4c2c998..91b9d90 100644
--- a/src/soft_idmap/mod.rs
+++ b/src/soft_idmap/mod.rs
@@ -9,13 +9,10 @@
  * translation functions in either direction.
  */
 
-pub mod cmdline;
 pub mod id_types;
 
-use crate::util::{other_io_error, ResultErrorContext};
 use btree_range_map::RangeMap;
 pub use id_types::{GuestGid, GuestId, GuestUid, HostGid, HostId, HostUid, Id};
-use std::convert::TryFrom;
 use std::fmt::{self, Display, Formatter};
 use std::io;
 use std::ops::{Add, Range, Sub};
@@ -42,6 +39,7 @@ pub struct IdMap<Guest: GuestId<HostType = Host>, Host: HostId<GuestType = Guest
 #[derive(Clone, Debug, PartialEq)]
 enum MapEntry<Source: Id, Target: Id> {
     /// Squash a range of IDs onto a single one.
+    #[allow(dead_code)] // to be removed when we allow parsing from the command line
     Squash {
         /// Range of source IDs.
         from: Range<Source>,
@@ -50,6 +48,7 @@ enum MapEntry<Source: Id, Target: Id> {
     },
 
     /// 1:1 map a range of IDs to another range (of the same length).
+    #[allow(dead_code)] // to be removed when we allow parsing from the command line
     Range {
         /// Range of source IDs.
         from: Range<Source>,
@@ -58,6 +57,7 @@ enum MapEntry<Source: Id, Target: Id> {
     },
 
     /// Disallow using this ID range: Return an error.
+    #[allow(dead_code)] // to be removed when we allow parsing from the command line
     Fail {
         /// Range of source IDs.
         from: Range<Source>,
@@ -102,59 +102,6 @@ where
             .map(|e| e.map(host_id))
             .unwrap_or(Ok(host_id.id_mapped()))
     }
-
-    /**
-     * Add a new mapping.
-     *
-     * Internal helper for [`Self::push_guest_to_host()`] and [`Self::push_host_to_guest()`].
-     *
-     * `map` points to either `self.guest_to_host` or `self.host_to_guest`.  `map_name` should be
-     * `"Guest-to-host"` or `"Host-to-guest"` accordingly, and is only used to generate potential
-     * error messages.
-     */
-    fn do_push<Source, Target>(
-        map: &mut RangeMap<Source::Inner, MapEntry<Source, Target>>,
-        map_name: &str,
-        entry: MapEntry<Source, Target>,
-    ) -> io::Result<()>
-    where
-        Source: Id + Sub<Source>,
-        Target: Id + Add<<Source as Sub>::Output, Output = Target>,
-    {
-        let wrapped_range = entry.source_range();
-        let inner_range = Range {
-            start: wrapped_range.start.into_inner(),
-            end: wrapped_range.end.into_inner(),
-        };
-        if map.intersects(inner_range.clone()) {
-            return Err(other_io_error(format!(
-                "{map_name} mapping '{entry}' intersects previously added entry"
-            )));
-        }
-
-        map.insert(inner_range, entry);
-        Ok(())
-    }
-
-    /**
-     * Add a new mapping of guest IDs to host ID(s).
-     *
-     * Internal helper for [`Self as
-     * TryFrom<Vec<cmdline::IdMap>>`](`Self#impl-TryFrom<Vec<IdMap>>-for-IdMap<Guest,+Host>`).
-     */
-    fn push_guest_to_host(&mut self, entry: MapEntry<Guest, Host>) -> io::Result<()> {
-        Self::do_push(&mut self.guest_to_host, "Guest-to-host", entry)
-    }
-
-    /**
-     * Add a new mapping of host IDs to guest ID(s).
-     *
-     * Internal helper for [`Self as
-     * TryFrom<Vec<cmdline::IdMap>>`](`Self#impl-TryFrom<Vec<IdMap>>-for-IdMap<Guest,+Host>`).
-     */
-    fn push_host_to_guest(&mut self, entry: MapEntry<Host, Guest>) -> io::Result<()> {
-        Self::do_push(&mut self.host_to_guest, "Host-to-guest", entry)
-    }
 }
 
 impl<Source: Id, Target: Id> MapEntry<Source, Target>
@@ -181,15 +128,6 @@ where
             }
         }
     }
-
-    /// Return the source ID range.
-    fn source_range(&self) -> &Range<Source> {
-        match self {
-            MapEntry::Squash { from, to: _ } => from,
-            MapEntry::Range { from, to_base: _ } => from,
-            MapEntry::Fail { from } => from,
-        }
-    }
 }
 
 impl<Source: Id> Display for MapError<Source> {
@@ -236,104 +174,3 @@ where
         }
     }
 }
-
-fn id_range_from_u32<I, P: Display>(base: u32, count: u32, param: P) -> io::Result<Range<I>>
-where
-    u32: Into<I>,
-{
-    let start: I = base.into();
-    let end: I = base
-        .checked_add(count)
-        .ok_or_else(|| {
-            io::Error::new(
-                io::ErrorKind::InvalidInput,
-                format!("Parameter {param}: Range overflow"),
-            )
-        })?
-        .into();
-    Ok(start..end)
-}
-
-impl<Guest, Host> TryFrom<Vec<cmdline::IdMap>> for IdMap<Guest, Host>
-where
-    Guest: GuestId<HostType = Host> + From<u32>,
-    Host: HostId<GuestType = Guest> + From<u32>,
-{
-    type Error = io::Error;
-
-    /// Convert from the command line representation to our runtime object.
-    fn try_from(cmdline: Vec<cmdline::IdMap>) -> io::Result<Self> {
-        let mut map = IdMap::empty();
-
-        for entry in cmdline {
-            match entry {
-                cmdline::IdMap::Guest {
-                    from_guest,
-                    to_host,
-                    count,
-                } => map
-                    .push_guest_to_host(MapEntry::Range {
-                        from: id_range_from_u32(from_guest, count, &entry)?,
-                        to_base: to_host.into(),
-                    })
-                    .err_context(|| entry)?,
-
-                cmdline::IdMap::Host {
-                    from_host,
-                    to_guest,
-                    count,
-                } => map
-                    .push_host_to_guest(MapEntry::Range {
-                        from: id_range_from_u32(from_host, count, &entry)?,
-                        to_base: to_guest.into(),
-                    })
-                    .err_context(|| entry)?,
-
-                cmdline::IdMap::SquashGuest {
-                    from_guest,
-                    to_host,
-                    count,
-                } => map
-                    .push_guest_to_host(MapEntry::Squash {
-                        from: id_range_from_u32(from_guest, count, &entry)?,
-                        to: to_host.into(),
-                    })
-                    .err_context(|| entry)?,
-
-                cmdline::IdMap::SquashHost {
-                    from_host,
-                    to_guest,
-                    count,
-                } => map
-                    .push_host_to_guest(MapEntry::Squash {
-                        from: id_range_from_u32(from_host, count, &entry)?,
-                        to: to_guest.into(),
-                    })
-                    .err_context(|| entry)?,
-
-                cmdline::IdMap::Bidirectional { guest, host, count } => {
-                    map.push_guest_to_host(MapEntry::Range {
-                        from: id_range_from_u32(guest, count, &entry)?,
-                        to_base: host.into(),
-                    })
-                    .err_context(|| &entry)?;
-
-                    map.push_host_to_guest(MapEntry::Range {
-                        from: id_range_from_u32(host, count, &entry)?,
-                        to_base: guest.into(),
-                    })
-                    .err_context(|| &entry)?;
-                }
-
-                cmdline::IdMap::ForbidGuest { from_guest, count } => {
-                    map.push_guest_to_host(MapEntry::Fail {
-                        from: (from_guest.into())..((from_guest + count).into()),
-                    })
-                    .err_context(|| &entry)?;
-                }
-            }
-        }
-
-        Ok(map)
-    }
-}
-- 
2.39.5

