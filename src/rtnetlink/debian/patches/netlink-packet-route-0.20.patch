From: little-dude <little-dude@mailbox.org>
Date: Sat, 24 Feb 2024 21:56:46 +0100
Subject: [PATCH] update to netlink-packet-route 0.20
Upstream: https://github.com/rust-netlink/rtnetlink/commit/6896baec2db251a7ecc9d85c09062de5b1cb9241.patch

the main change is the switch to `bitflags` for manipulating fields
that contain flags.

Some integers have also been replaced by enums:

- `BondMode` replaced the raw `u8`
- `MacVlanMode` replaced the raw u32`
- `MacVtapMode` replaced the raw u32`
---
 Cargo.toml                        |  2 +-
 examples/create_bond.rs           |  3 +-
 examples/create_macvlan.rs        |  4 +--
 examples/create_macvtap.rs        |  4 +--
 src/link/add.rs                   | 56 ++++++++++++++-----------------
 src/link/set.rs                   | 25 ++++++--------
 src/link/set_bond_port.rs         |  2 +-
 src/link/test.rs                  |  6 ++--
 src/neighbour/add.rs              |  4 +--
 src/neighbour/get.rs              |  4 +--
 src/traffic_control/add_filter.rs |  8 ++---
 11 files changed, 56 insertions(+), 62 deletions(-)

Index: rtnetlink/Cargo.toml
===================================================================
--- rtnetlink.orig/Cargo.toml
+++ rtnetlink/Cargo.toml
@@ -40,7 +40,7 @@ version = "0.4.8"
 version = "0.7"
 
 [dependencies.netlink-packet-route]
-version = "0.19"
+version = "0.20"
 
 [dependencies.netlink-packet-utils]
 version = "0.5"
Index: rtnetlink/examples/create_bond.rs
===================================================================
--- rtnetlink.orig/examples/create_bond.rs
+++ rtnetlink/examples/create_bond.rs
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: MIT
 #![cfg(feature = "tokio_socket")]
 
+use netlink_packet_route::link::BondMode;
 use rtnetlink::new_connection;
 use std::net::{Ipv4Addr, Ipv6Addr};
 
@@ -12,7 +13,7 @@ async fn main() -> Result<(), String> {
         .link()
         .add()
         .bond("my-bond".into())
-        .mode(1)
+        .mode(BondMode::ActiveBackup)
         .miimon(100)
         .updelay(100)
         .downdelay(100)
Index: rtnetlink/examples/create_macvlan.rs
===================================================================
--- rtnetlink.orig/examples/create_macvlan.rs
+++ rtnetlink/examples/create_macvlan.rs
@@ -6,7 +6,7 @@ use macaddr::MacAddr;
 use rtnetlink::{new_connection, Error, Handle};
 use std::{env, str::FromStr};
 
-use netlink_packet_route::link::LinkAttribute;
+use netlink_packet_route::link::{LinkAttribute, MacVlanMode};
 
 #[tokio::main]
 async fn main() -> Result<(), String> {
@@ -43,7 +43,7 @@ async fn create_macvlan(
         let mut request = handle.link().add().macvlan(
             "test_macvlan".into(),
             link.header.index,
-            4u32, // bridge mode
+            MacVlanMode::Bridge,
         );
         if let Some(mac) = mac_address {
             request
Index: rtnetlink/examples/create_macvtap.rs
===================================================================
--- rtnetlink.orig/examples/create_macvtap.rs
+++ rtnetlink/examples/create_macvtap.rs
@@ -2,6 +2,7 @@
 #![cfg(feature = "tokio_socket")]
 
 use futures::stream::TryStreamExt;
+use netlink_packet_route::link::MacVtapMode;
 use rtnetlink::{new_connection, Error, Handle};
 use std::env;
 
@@ -28,11 +29,10 @@ async fn create_macvtap(
 ) -> Result<(), Error> {
     let mut links = handle.link().get().match_name(veth_name.clone()).execute();
     if let Some(link) = links.try_next().await? {
-        // hard code mode: 4u32 i.e bridge mode
         let request = handle.link().add().macvtap(
             "test_macvtap".into(),
             link.header.index,
-            4u32,
+            MacVtapMode::Bridge,
         );
         request.execute().await?
     } else {
Index: rtnetlink/src/link/add.rs
===================================================================
--- rtnetlink.orig/src/link/add.rs
+++ rtnetlink/src/link/add.rs
@@ -13,9 +13,10 @@ use netlink_packet_core::{
 
 use netlink_packet_route::{
     link::{
-        InfoBond, InfoData, InfoKind, InfoMacVlan, InfoMacVtap, InfoVeth,
-        InfoVlan, InfoVxlan, InfoXfrm, LinkAttribute, LinkFlag, LinkInfo,
-        LinkMessage, VlanQosMapping,
+        BondMode, InfoBond, InfoData, InfoKind, InfoMacVlan, InfoMacVtap,
+        InfoVeth, InfoVlan, InfoVxlan, InfoXfrm, LinkAttribute,
+        LinkFlags, LinkInfo, LinkMessage, MacVlanMode, MacVtapMode,
+        VlanQosMapping,
     },
     RouteNetlinkMessage,
 };
@@ -45,7 +46,7 @@ impl BondAddRequest {
 
     /// Adds the `mode` attribute to the bond
     /// This is equivalent to `ip link add name NAME type bond mode MODE`.
-    pub fn mode(mut self, mode: u8) -> Self {
+    pub fn mode(mut self, mode: BondMode) -> Self {
         self.info_data.push(InfoBond::Mode(mode));
         self
     }
@@ -442,7 +443,7 @@ impl VxlanAddRequest {
 
     /// Adds the `learning` attribute to the VXLAN
     /// This is equivalent to `ip link add name NAME type vxlan id VNI
-    /// [no]learning`. [no]learning - specifies if unknown source link layer
+    /// \[no\]learning`. \[no\]learning - specifies if unknown source link layer
     /// addresses and IP addresses are entered into the VXLAN
     /// device forwarding database.
     pub fn learning(mut self, learning: bool) -> Self {
@@ -480,15 +481,15 @@ impl VxlanAddRequest {
 
     /// Adds the `proxy` attribute to the VXLAN
     /// This is equivalent to `ip link add name NAME type vxlan id VNI
-    /// [no]proxy`. [no]proxy - specifies ARP proxy is turned on.
+    /// [no]proxy`. \[no\]proxy - specifies ARP proxy is turned on.
     pub fn proxy(mut self, proxy: bool) -> Self {
         self.info_data.push(InfoVxlan::Proxy(proxy));
         self
     }
 
-    /// Adds the `rsc` attribute to the VXLAN
-    /// This is equivalent to `ip link add name NAME type vxlan id VNI [no]rsc`.
-    /// [no]rsc - specifies if route short circuit is turned on.
+    /// Adds the `rsc` attribute to the VXLAN This is equivalent to
+    /// `ip link add name NAME type vxlan id VNI [no]rsc`.
+    /// \[no\]rsc - specifies if route short circuit is turned on.
     pub fn rsc(mut self, rsc: bool) -> Self {
         self.info_data.push(InfoVxlan::Rsc(rsc));
         self
@@ -496,7 +497,7 @@ impl VxlanAddRequest {
 
     // Adds the `l2miss` attribute to the VXLAN
     /// This is equivalent to `ip link add name NAME type vxlan id VNI
-    /// [no]l2miss`. [no]l2miss - specifies if netlink LLADDR miss
+    /// [no]l2miss`. \[no\]l2miss - specifies if netlink LLADDR miss
     /// notifications are generated.
     pub fn l2miss(mut self, l2miss: bool) -> Self {
         self.info_data.push(InfoVxlan::L2Miss(l2miss));
@@ -505,8 +506,8 @@ impl VxlanAddRequest {
 
     // Adds the `l3miss` attribute to the VXLAN
     /// This is equivalent to `ip link add name NAME type vxlan id VNI
-    /// [no]l3miss`. [no]l3miss - specifies if netlink IP ADDR miss
-    /// notifications are generated.
+    /// [no]l3miss`. \[no\]l3miss - specifies if netlink IP ADDR
+    /// miss notifications are generated.
     pub fn l3miss(mut self, l3miss: bool) -> Self {
         self.info_data.push(InfoVxlan::L3Miss(l3miss));
         self
@@ -520,8 +521,8 @@ impl VxlanAddRequest {
 
     // Adds the `udp_csum` attribute to the VXLAN
     /// This is equivalent to `ip link add name NAME type vxlan id VNI
-    /// [no]udp_csum`. [no]udpcsum - specifies if UDP checksum is calculated
-    /// for transmitted packets over IPv4.
+    /// [no]udp_csum`. \[no\]udpcsum - specifies if UDP checksum is
+    /// calculated for transmitted packets over IPv4.
     pub fn udp_csum(mut self, udp_csum: bool) -> Self {
         self.info_data.push(InfoVxlan::UDPCsum(udp_csum));
         self
@@ -588,13 +589,13 @@ impl LinkAddRequest {
     ///
     /// Let's say we want to create a vlan interface on a link with id 6. By
     /// default, the [`vlan()`](#method.vlan) method would create a request
-    /// with the `LinkFlag::Up` link set, so that the interface is up after
+    /// with the `LinkFlags::Up` link set, so that the interface is up after
     /// creation. If we want to create a interface that is down by default we
     /// could do:
     ///
     /// ```rust,no_run
     /// use futures::Future;
-    /// use netlink_packet_route::link::LinkFlag;
+    /// use netlink_packet_route::link::LinkFlags;
     /// use rtnetlink::{Handle, new_connection};
     ///
     /// async fn run(handle: Handle) -> Result<(), String> {
@@ -602,9 +603,8 @@ impl LinkAddRequest {
     ///     let link_id = 6;
     ///     let mut request = handle.link().add().vlan("my-vlan-itf".into(),
     ///         link_id, vlan_id);
-    ///     request.message_mut().header.flags.push(LinkFlag::Up);
-    ///     request.message_mut().header.change_mask.retain(
-    ///         |f| *f != LinkFlag::Up);
+    ///     request.message_mut().header.flags.remove(LinkFlags::Up);
+    ///     request.message_mut().header.change_mask.remove(LinkFlags::Up);
     ///     // send the request
     ///     request.execute().await.map_err(|e| format!("{}", e))
     /// }
@@ -628,8 +628,8 @@ impl LinkAddRequest {
 
         let mut peer = LinkMessage::default();
         // FIXME: we get a -107 (ENOTCONN) (???) when trying to set `name` up.
-        // peer.header.flags.push(LinkFlag::Up);
-        // peer.header.change_mask.push(LinkFlag::Up);
+        // peer.header.flags |= LinkFlags::Up;
+        // peer.header.change_mask |= LinkFlag::Up;
         peer.attributes.push(LinkAttribute::IfName(name));
         let link_info_data = InfoData::Veth(InfoVeth::Peer(peer));
         self.name(peer_name)
@@ -687,7 +687,7 @@ impl LinkAddRequest {
     /// flags from MACVLAN_MODE (netlink-packet-route/src/rtnl/constants.rs)
     ///   being: _PRIVATE, _VEPA, _BRIDGE, _PASSTHRU, _SOURCE, which can be
     /// *combined*.
-    pub fn macvlan(self, name: String, index: u32, mode: u32) -> Self {
+    pub fn macvlan(self, name: String, index: u32, mode: MacVlanMode) -> Self {
         self.name(name)
             .link_info(
                 InfoKind::MacVlan,
@@ -704,7 +704,7 @@ impl LinkAddRequest {
     /// flags from MACVTAP_MODE (netlink-packet-route/src/rtnl/constants.rs)
     ///   being: _PRIVATE, _VEPA, _BRIDGE, _PASSTHRU, _SOURCE, which can be
     /// *combined*.
-    pub fn macvtap(self, name: String, index: u32, mode: u32) -> Self {
+    pub fn macvtap(self, name: String, index: u32, mode: MacVtapMode) -> Self {
         self.name(name)
             .link_info(
                 InfoKind::MacVtap,
@@ -760,11 +760,7 @@ impl LinkAddRequest {
     /// This is equivalent to `ip link add NAME type wireguard`.
     pub fn wireguard(self, name: String) -> Self {
         let mut request = self.name(name).link_info(InfoKind::Wireguard, None);
-        request
-            .message_mut()
-            .header
-            .flags
-            .retain(|f| *f != LinkFlag::Up);
+        request.message_mut().header.flags.remove(LinkFlags::Up);
         request
     }
 
@@ -777,8 +773,8 @@ impl LinkAddRequest {
     }
 
     fn up(mut self) -> Self {
-        self.message.header.flags.push(LinkFlag::Up);
-        self.message.header.change_mask.push(LinkFlag::Up);
+        self.message.header.flags |= LinkFlags::Up;
+        self.message.header.change_mask |= LinkFlags::Up;
         self
     }
 
Index: rtnetlink/src/link/set.rs
===================================================================
--- rtnetlink.orig/src/link/set.rs
+++ rtnetlink/src/link/set.rs
@@ -7,7 +7,7 @@ use netlink_packet_core::{
     NetlinkMessage, NLM_F_ACK, NLM_F_CREATE, NLM_F_EXCL, NLM_F_REQUEST,
 };
 use netlink_packet_route::{
-    link::{LinkAttribute, LinkFlag, LinkMessage},
+    link::{LinkAttribute, LinkFlags, LinkMessage},
     RouteNetlinkMessage,
 };
 
@@ -105,16 +105,16 @@ impl LinkSetRequest {
     /// Set the link with the given index up (equivalent to `ip link set dev DEV
     /// up`)
     pub fn up(mut self) -> Self {
-        self.message.header.flags.push(LinkFlag::Up);
-        self.message.header.change_mask.push(LinkFlag::Up);
+        self.message.header.flags |= LinkFlags::Up;
+        self.message.header.change_mask |= LinkFlags::Up;
         self
     }
 
     /// Set the link with the given index down (equivalent to `ip link set dev
     /// DEV down`)
     pub fn down(mut self) -> Self {
-        self.message.header.flags.retain(|f| *f != LinkFlag::Up);
-        self.message.header.change_mask.push(LinkFlag::Up);
+        self.message.header.flags.remove(LinkFlags::Up);
+        self.message.header.change_mask |= LinkFlags::Up;
         self
     }
 
@@ -122,14 +122,11 @@ impl LinkSetRequest {
     /// (equivalent to `ip link set dev DEV promisc on/off`)
     pub fn promiscuous(mut self, enable: bool) -> Self {
         if enable {
-            self.message.header.flags.push(LinkFlag::Promisc);
+            self.message.header.flags |= LinkFlags::Promisc;
         } else {
-            self.message
-                .header
-                .flags
-                .retain(|f| *f != LinkFlag::Promisc);
+            self.message.header.flags.remove(LinkFlags::Promisc);
         }
-        self.message.header.change_mask.push(LinkFlag::Promisc);
+        self.message.header.change_mask |= LinkFlags::Promisc;
         self
     }
 
@@ -137,11 +134,11 @@ impl LinkSetRequest {
     /// (equivalent to `ip link set dev DEV arp on/off`)
     pub fn arp(mut self, enable: bool) -> Self {
         if enable {
-            self.message.header.flags.retain(|f| *f != LinkFlag::Noarp);
+            self.message.header.flags.remove(LinkFlags::Noarp);
         } else {
-            self.message.header.flags.push(LinkFlag::Noarp);
+            self.message.header.flags |= LinkFlags::Noarp;
         }
-        self.message.header.change_mask.push(LinkFlag::Noarp);
+        self.message.header.change_mask |= LinkFlags::Noarp;
         self
     }
 
Index: rtnetlink/src/link/set_bond_port.rs
===================================================================
--- rtnetlink.orig/src/link/set_bond_port.rs
+++ rtnetlink/src/link/set_bond_port.rs
@@ -53,7 +53,7 @@ impl BondPortSetRequest {
         Ok(())
     }
 
-    /// Return a mutable reference to the Vec<InfoBondPort>
+    /// Return a mutable reference to the `Vec<InfoBondPort>`
     pub fn info_port_nlas_mut(&mut self) -> &mut Vec<InfoBondPort> {
         &mut self.port_nlas
     }
Index: rtnetlink/src/link/test.rs
===================================================================
--- rtnetlink.orig/src/link/test.rs
+++ rtnetlink/src/link/test.rs
@@ -4,6 +4,7 @@
 use futures::stream::TryStreamExt;
 use netlink_packet_route::link::{
     InfoData, InfoKind, InfoMacVlan, LinkAttribute, LinkInfo, LinkMessage,
+    MacVlanMode
 };
 use tokio::runtime::Runtime;
 
@@ -32,7 +33,7 @@ fn create_get_delete_wg() {
 fn create_get_delete_macvlan() {
     const MACVLAN_IFACE_NAME: &str = "mvlan1";
     const LOWER_DEVICE_IDX: u32 = 2;
-    const MACVLAN_MODE: u32 = 4; // bridge
+    const MACVLAN_MODE: MacVlanMode = MacVlanMode::Bridge;
     let mac_address = &vec![2u8, 0, 0, 0, 0, 1];
 
     let rt = Runtime::new().unwrap();
@@ -115,7 +116,7 @@ async fn _del_iface(handle: &mut LinkHan
 async fn _create_macvlan(
     name: &String,
     lower_device_index: u32,
-    mode: u32,
+    mode: MacVlanMode,
     mac: Vec<u8>,
 ) -> Result<LinkHandle, Error> {
     let (conn, handle, _) = new_connection().unwrap();
Index: rtnetlink/src/neighbour/add.rs
===================================================================
--- rtnetlink.orig/src/neighbour/add.rs
+++ rtnetlink/src/neighbour/add.rs
@@ -8,7 +8,7 @@ use netlink_packet_core::{
 };
 use netlink_packet_route::{
     neighbour::{
-        NeighbourAddress, NeighbourAttribute, NeighbourFlag, NeighbourMessage,
+        NeighbourAddress, NeighbourAttribute, NeighbourFlags, NeighbourMessage,
         NeighbourState,
     },
     route::RouteType,
@@ -80,7 +80,7 @@ impl NeighbourAddRequest {
 
     /// Set flags for the neighbor cache entry.
     /// It should be a combination of `NTF_*` constants.
-    pub fn flags(mut self, flags: Vec<NeighbourFlag>) -> Self {
+    pub fn flags(mut self, flags: NeighbourFlags) -> Self {
         self.message.header.flags = flags;
         self
     }
Index: rtnetlink/src/neighbour/get.rs
===================================================================
--- rtnetlink.orig/src/neighbour/get.rs
+++ rtnetlink/src/neighbour/get.rs
@@ -9,7 +9,7 @@ use netlink_packet_core::{
     NetlinkMessage, NetlinkPayload, NLM_F_DUMP, NLM_F_REQUEST,
 };
 use netlink_packet_route::{
-    neighbour::{NeighbourFlag, NeighbourMessage},
+    neighbour::{NeighbourFlags, NeighbourMessage},
     RouteNetlinkMessage,
 };
 
@@ -29,7 +29,7 @@ impl NeighbourGetRequest {
     /// List neighbor proxies in the system (equivalent to: `ip neighbor show
     /// proxy`).
     pub fn proxies(mut self) -> Self {
-        self.message.header.flags.push(NeighbourFlag::Proxy);
+        self.message.header.flags |= NeighbourFlags::Proxy;
         self
     }
 
Index: rtnetlink/src/traffic_control/add_filter.rs
===================================================================
--- rtnetlink.orig/src/traffic_control/add_filter.rs
+++ rtnetlink/src/traffic_control/add_filter.rs
@@ -8,7 +8,7 @@ use netlink_packet_route::{
         TcActionMirrorOption, TcActionOption, TcActionType, TcAttribute,
         TcFilterU32, TcFilterU32Option, TcHandle, TcHeader, TcMessage,
         TcMirror, TcMirrorActionType, TcOption, TcU32Key, TcU32Selector,
-        TcU32SelectorFlag,
+        TcU32SelectorFlags,
     },
     RouteNetlinkMessage,
 };
@@ -149,7 +149,7 @@ impl TrafficFilterNewRequest {
     /// You need to set the `parent` and `protocol` before call redirect.
     pub fn redirect(self, dst_index: u32) -> Result<Self, Error> {
         let mut sel_na = TcU32Selector::default();
-        sel_na.flags = vec![TcU32SelectorFlag::Terminal];
+        sel_na.flags = TcU32SelectorFlags::Terminal;
         sel_na.nkeys = 1;
         sel_na.keys = vec![TcU32Key::default()];
         let mut tc_mirror_nla = TcMirror::default();
@@ -182,7 +182,7 @@ mod test {
         link::LinkMessage,
         tc::{
             TcAttribute, TcFilterU32, TcFilterU32Option, TcOption, TcU32Key,
-            TcU32SelectorFlag,
+            TcU32SelectorFlags,
         },
     };
     use nix::sched::{setns, CloneFlags};
@@ -344,7 +344,7 @@ mod test {
                 } else {
                     panic!("expect sel nla");
                 };
-                assert_eq!(sel.flags, vec![TcU32SelectorFlag::Terminal]);
+                assert_eq!(sel.flags, TcU32SelectorFlags::Terminal);
                 assert_eq!(sel.nkeys, 1);
                 assert_eq!(sel.keys.len(), 1);
                 assert_eq!(sel.keys[0], TcU32Key::default());
