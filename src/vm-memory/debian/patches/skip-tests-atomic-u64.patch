Index: rust-vm-memory-0.10.0/src/bitmap/mod.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/bitmap/mod.rs
+++ rust-vm-memory-0.10.0/src/bitmap/mod.rs
@@ -14,7 +14,9 @@ use std::fmt::Debug;
 use crate::{GuestMemory, GuestMemoryRegion};
 
 #[cfg(any(test, feature = "backend-bitmap"))]
-pub use backend::{ArcSlice, AtomicBitmap, RefSlice};
+pub use backend::{ArcSlice, RefSlice};
+#[cfg(any(all(test, target_has_atomic = "64"), feature = "backend-bitmap"))]
+pub use backend::AtomicBitmap;
 
 /// Trait implemented by types that support creating `BitmapSlice` objects.
 pub trait WithBitmapSlice<'a> {
Index: rust-vm-memory-0.10.0/src/volatile_memory.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/volatile_memory.rs
+++ rust-vm-memory-0.10.0/src/volatile_memory.rs
@@ -1389,7 +1389,9 @@ mod tests {
     use crate::bitmap::tests::{
         check_range, range_is_clean, range_is_dirty, test_bytes, test_volatile_memory,
     };
-    use crate::bitmap::{AtomicBitmap, RefSlice};
+    #[cfg(target_has_atomic = "64")]
+    use crate::bitmap::AtomicBitmap;
+    use crate::bitmap::RefSlice;
 
     #[derive(Clone)]
     struct VecMem {
@@ -2008,6 +2010,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn test_volatile_slice_dirty_tracking() {
         let val = 123u64;
         let dirty_offset = 0x1000;
@@ -2101,6 +2104,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn test_volatile_ref_dirty_tracking() {
         let val = 123u64;
         let mut buf = vec![val];
@@ -2115,6 +2119,7 @@ mod tests {
         assert!(range_is_dirty(vref.bitmap(), 0, vref.len()));
     }
 
+    #[cfg(target_has_atomic = "64")]
     fn test_volatile_array_ref_copy_from_tracking<T>(buf: &mut [T], index: usize, page_size: usize)
     where
         T: ByteValued + From<u8>,
@@ -2137,6 +2142,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(target_has_atomic = "64")]
     fn test_volatile_array_ref_dirty_tracking() {
         let val = 123u64;
         let dirty_len = size_of_val(&val);
Index: rust-vm-memory-0.10.0/src/bitmap/backend/mod.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/bitmap/backend/mod.rs
+++ rust-vm-memory-0.10.0/src/bitmap/backend/mod.rs
@@ -1,10 +1,14 @@
 // Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 // SPDX-License-Identifier: Apache-2.0 OR BSD-3-Clause
 
+#[cfg(any(all(test, target_has_atomic = "64"), feature = "backend-bitmap"))]
 mod atomic_bitmap;
+#[cfg(any(all(test, target_has_atomic = "64"), feature = "backend-bitmap"))]
 mod atomic_bitmap_arc;
 mod slice;
 
+#[cfg(any(all(test, target_has_atomic = "64"), feature = "backend-bitmap"))]
 pub use atomic_bitmap::AtomicBitmap;
+#[cfg(any(all(test, target_has_atomic = "64"), feature = "backend-bitmap"))]
 pub use atomic_bitmap_arc::AtomicBitmapArc;
 pub use slice::{ArcSlice, RefSlice};
Index: rust-vm-memory-0.10.0/src/bitmap/backend/slice.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/bitmap/backend/slice.rs
+++ rust-vm-memory-0.10.0/src/bitmap/backend/slice.rs
@@ -94,6 +94,7 @@ pub type RefSlice<'a, B> = BaseSlice<&'a
 pub type ArcSlice<B> = BaseSlice<Arc<B>>;
 
 #[cfg(test)]
+#[cfg(target_has_atomic = "64")]
 mod tests {
     use super::*;
 
Index: rust-vm-memory-0.10.0/src/mmap.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/mmap.rs
+++ rust-vm-memory-0.10.0/src/mmap.rs
@@ -676,6 +676,7 @@ mod tests {
     use super::*;
 
     use crate::bitmap::tests::test_guest_memory_and_region;
+    #[cfg(target_has_atomic = "64")]
     use crate::bitmap::AtomicBitmap;
     use crate::GuestAddressSpace;
 
@@ -1560,7 +1561,7 @@ mod tests {
         );
     }
 
-    #[cfg(not(target_arch = "powerpc64"))]
+    #[cfg(all(not(target_arch = "powerpc64"), target_has_atomic = "64"))]
     #[test]
     fn test_dirty_tracking() {
         test_guest_memory_and_region(|| {
Index: rust-vm-memory-0.10.0/src/mmap_unix.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/mmap_unix.rs
+++ rust-vm-memory-0.10.0/src/mmap_unix.rs
@@ -469,6 +469,7 @@ mod tests {
     use std::sync::Arc;
     use vmm_sys_util::tempfile::TempFile;
 
+    #[cfg(target_has_atomic = "64")]
     use crate::bitmap::AtomicBitmap;
 
     type MmapRegion = super::MmapRegion<()>;
@@ -617,6 +618,7 @@ mod tests {
         assert!(r.owned());
 
         let region_size = 0x10_0000;
+        #[cfg(target_has_atomic = "64")] {
         let bitmap = AtomicBitmap::new(region_size, 0x1000);
         let builder = MmapRegionBuilder::new_with_bitmap(region_size, bitmap)
             .with_hugetlbfs(true)
@@ -626,6 +628,7 @@ mod tests {
         assert_eq!(builder.prot, libc::PROT_READ | libc::PROT_WRITE);
 
         crate::bitmap::tests::test_volatile_memory(&(builder.build().unwrap()));
+        }
     }
 
     #[test]
@@ -677,7 +680,7 @@ mod tests {
         assert!(!r1.fds_overlap(&r2));
     }
 
-    #[cfg(not(target_arch = "powerpc64"))]
+    #[cfg(all(not(target_arch = "powerpc64"), target_has_atomic = "64"))]
     #[test]
     fn test_dirty_tracking() {
         // Using the `crate` prefix because we aliased `MmapRegion` to `MmapRegion<()>` for
