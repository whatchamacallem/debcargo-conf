Index: rust-ntp-os-clock-1.1.3/src/unix.rs
===================================================================
--- rust-ntp-os-clock-1.1.3.orig/src/unix.rs
+++ rust-ntp-os-clock-1.1.3/src/unix.rs
@@ -16,42 +16,7 @@ use ntp_proto::{NtpClock, NtpDuration, N
 // Libc has no good other way of obtaining this, so let's at least make our functions
 // more readable.
 #[cfg(all(target_os = "linux", target_env = "gnu"))]
-pub(crate) const EMPTY_TIMEX: libc::timex = libc::timex {
-    modes: 0,
-    offset: 0,
-    freq: 0,
-    maxerror: 0,
-    esterror: 0,
-    status: 0,
-    constant: 0,
-    precision: 0,
-    tolerance: 0,
-    time: libc::timeval {
-        tv_sec: 0,
-        tv_usec: 0,
-    },
-    tick: 0,
-    ppsfreq: 0,
-    jitter: 0,
-    shift: 0,
-    stabil: 0,
-    jitcnt: 0,
-    calcnt: 0,
-    errcnt: 0,
-    stbcnt: 0,
-    tai: 0,
-    __unused1: 0,
-    __unused2: 0,
-    __unused3: 0,
-    __unused4: 0,
-    __unused5: 0,
-    __unused6: 0,
-    __unused7: 0,
-    __unused8: 0,
-    __unused9: 0,
-    __unused10: 0,
-    __unused11: 0,
-};
+pub(crate) const EMPTY_TIMEX: libc::timex = unsafe { std::mem::zeroed() };
 
 #[cfg(all(target_os = "linux", target_env = "musl"))]
 pub(crate) const EMPTY_TIMEX: libc::timex = libc::timex {
@@ -144,10 +109,7 @@ impl UnixNtpClock {
 
     #[cfg_attr(target_os = "linux", allow(unused))]
     fn clock_gettime(&self) -> Result<libc::timespec, Error> {
-        let mut timespec = libc::timespec {
-            tv_sec: 0,
-            tv_nsec: 0,
-        };
+        let mut timespec = unsafe { std::mem::zeroed() };
 
         // # Safety
         //
@@ -265,7 +227,7 @@ impl UnixNtpClock {
             modes: libc::ADJ_SETOFFSET | libc::MOD_NANO,
             time: libc::timeval {
                 tv_sec: secs as _,
-                tv_usec: nanos as libc::suseconds_t,
+                tv_usec: nanos as _,
             },
             ..crate::unix::EMPTY_TIMEX
         };
@@ -409,7 +371,7 @@ impl NtpClock for UnixNtpClock {
         ntp_kapi_timex.modes = libc::MOD_FREQUENCY;
         // NTP Kapi expects frequency adjustment in units of 2^-16 ppm
         // but our input is in units of seconds drift per second, so convert.
-        ntp_kapi_timex.freq = (freq * 65536e6) as libc::c_long;
+        ntp_kapi_timex.freq = (freq * 65536e6) as _;
         ntp_kapi_timex.status =
             !libc::STA_PLL & !libc::STA_PPSFREQ & !libc::STA_FLL & !libc::STA_PPSTIME;
 
@@ -460,8 +422,8 @@ impl NtpClock for UnixNtpClock {
     ) -> Result<(), Self::Error> {
         let mut timex = EMPTY_TIMEX;
         timex.modes = libc::MOD_OFFSET | libc::MOD_TIMECONST;
-        timex.offset = duration_in_nanos(offset);
-        timex.constant = poll_interval.as_log() as libc::c_long;
+        timex.offset = duration_in_nanos(offset) as _;
+        timex.constant = poll_interval.as_log() as _;
         ignore_not_supported(self.adjtime(&mut timex))
     }
 
@@ -472,8 +434,8 @@ impl NtpClock for UnixNtpClock {
     ) -> Result<(), Self::Error> {
         let mut timex = EMPTY_TIMEX;
         timex.modes = libc::MOD_ESTERROR | libc::MOD_MAXERROR;
-        timex.esterror = duration_in_nanos(est_error) / 1000;
-        timex.maxerror = duration_in_nanos(max_error) / 1000;
+        timex.esterror = (duration_in_nanos(est_error) / 1000) as _;
+        timex.maxerror = (duration_in_nanos(max_error) / 1000) as _;
         ignore_not_supported(self.adjtime(&mut timex))
     }
 
