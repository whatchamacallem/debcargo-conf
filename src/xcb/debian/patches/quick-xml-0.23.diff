Index: xcb/Cargo.toml
===================================================================
--- xcb.orig/Cargo.toml
+++ xcb/Cargo.toml
@@ -131,7 +131,7 @@ features = [
 ]
 
 [build-dependencies.quick-xml]
-version = "0.22.0"
+version = "0.23.0"
 
 [features]
 composite = ["xfixes"]
Index: xcb/build/parse.rs
===================================================================
--- xcb.orig/build/parse.rs
+++ xcb/build/parse.rs
@@ -1,6 +1,7 @@
 use quick_xml::events::attributes::{Attribute, Attributes};
 use quick_xml::events::{BytesStart, Event as XmlEv};
 use quick_xml::Reader as XmlReader;
+use quick_xml::events::attributes::AttrError;
 use std::fs::File;
 use std::io::{self, BufRead, BufReader};
 use std::path::Path;
@@ -16,6 +17,7 @@ use crate::ir::{
 pub enum Error {
     IO(io::Error),
     Xml(quick_xml::Error),
+    Attr(AttrError),
     Utf8(Utf8Error),
     Parse(String),
 }
@@ -32,6 +34,13 @@ impl From<Utf8Error> for Error {
     }
 }
 
+impl From<AttrError> for Error {
+    fn from(err: AttrError) -> Self {
+        let e: quick_xml::Error = err.into();
+        e.into()
+    }
+}
+
 impl From<quick_xml::Error> for Error {
     fn from(err: quick_xml::Error) -> Self {
         match err {
@@ -310,21 +319,49 @@ impl Parser<BufReader<File>> {
 impl<B: BufRead> Parser<B> {
     fn expect_text(&mut self) -> Result<String> {
         match self.xml.read_event(&mut self.buf)? {
-            XmlEv::Text(e) | XmlEv::CData(e) => {
+            XmlEv::Text(e) => {
                 let txt = e.unescaped()?;
                 Ok(str::from_utf8(&txt)?.into())
             }
+            XmlEv::CData(e) => {
+                let txt = e.into_inner();
+                Ok(str::from_utf8(&txt)?.into())
+            }
             ev => Err(Error::Parse(format!("expected text, found {:?}", ev))),
         }
     }
 
     fn expect_text_trim(&mut self, close_tag: &[u8]) -> Result<String> {
         match self.xml.read_event(&mut self.buf)? {
-            XmlEv::Text(e) | XmlEv::CData(e) => {
+            XmlEv::Text(e) => {
                 let txt = e.unescaped()?;
                 let txt = str::from_utf8(&txt)?.trim().into();
                 if !close_tag.is_empty() {
                     match self.xml.read_event(&mut self.buf)? {
+                        XmlEv::End(e) => {
+                            if e.name() == close_tag {
+                                return Ok(txt);
+                            }
+                            Err(Error::Parse(format!(
+                                "expected </{}> after text",
+                                str::from_utf8(close_tag).unwrap()
+                            )))
+                        }
+                        ev => Err(Error::Parse(format!(
+                            "expected </{}>, found {:?}",
+                            str::from_utf8(close_tag).unwrap(),
+                            ev
+                        ))),
+                    }
+                } else {
+                    Ok(txt)
+                }
+            }
+            XmlEv::CData(e) => {
+                let txt = e.into_inner();
+                let txt = str::from_utf8(&txt)?.trim().into();
+                if !close_tag.is_empty() {
+                    match self.xml.read_event(&mut self.buf)? {
                         XmlEv::End(e) => {
                             if e.name() == close_tag {
                                 return Ok(txt);
