--- rust-xcb-1.2.0.orig/Cargo.toml
+++ rust-xcb-1.2.0/Cargo.toml
@@ -131,7 +131,7 @@ features = [
 ]
 
 [build-dependencies.quick-xml]
-version = "0.23.0"
+version = "0.24.0"
 
 [features]
 composite = ["xfixes"]
--- rust-xcb-1.2.0.orig/build/parse.rs
+++ rust-xcb-1.2.0/build/parse.rs
@@ -2,6 +2,7 @@ use quick_xml::events::attributes::{Attr
 use quick_xml::events::{BytesStart, Event as XmlEv};
 use quick_xml::Reader as XmlReader;
 use quick_xml::events::attributes::AttrError;
+use quick_xml::name::QName;
 use std::fs::File;
 use std::io::{self, BufRead, BufReader};
 use std::path::Path;
@@ -45,7 +46,7 @@ impl From<quick_xml::Error> for Error {
     fn from(err: quick_xml::Error) -> Self {
         match err {
             quick_xml::Error::Io(e) => Error::IO(e),
-            quick_xml::Error::Utf8(e) => Error::Utf8(e),
+            quick_xml::Error::NonDecodable(Some(e)) => Error::Utf8(e),
             e => Error::Xml(e),
         }
     }
@@ -74,8 +75,8 @@ impl<B: BufRead> Iterator for &mut Parse
 
     fn next(&mut self) -> Option<Self::Item> {
         self.buf.clear();
-        match self.xml.read_event(&mut self.buf) {
-            Ok(XmlEv::Empty(ref e)) => match e.name() {
+        match self.xml.read_event_into(&mut self.buf) {
+            Ok(XmlEv::Empty(ref e)) => match e.name().into_inner() {
                 b"typedef" => {
                     let names: [&[u8]; 2] = [b"oldname", b"newname"];
                     let mut vals: [Option<String>; 2] = [None, None];
@@ -162,7 +163,7 @@ impl<B: BufRead> Iterator for &mut Parse
                     str::from_utf8(name).unwrap()
                 )))),
             },
-            Ok(XmlEv::Start(ref e)) => match e.name() {
+            Ok(XmlEv::Start(ref e)) => match e.name().into_inner() {
                 b"xcb" => {
                     let names: [&[u8]; 5] = [
                         b"header",
@@ -318,10 +319,10 @@ impl Parser<BufReader<File>> {
 
 impl<B: BufRead> Parser<B> {
     fn expect_text(&mut self) -> Result<String> {
-        match self.xml.read_event(&mut self.buf)? {
+        match self.xml.read_event_into(&mut self.buf)? {
             XmlEv::Text(e) => {
-                let txt = e.unescaped()?;
-                Ok(str::from_utf8(&txt)?.into())
+                let txt = e.unescape()?;
+                Ok(txt.into())
             }
             XmlEv::CData(e) => {
                 let txt = e.into_inner();
@@ -332,14 +333,14 @@ impl<B: BufRead> Parser<B> {
     }
 
     fn expect_text_trim(&mut self, close_tag: &[u8]) -> Result<String> {
-        match self.xml.read_event(&mut self.buf)? {
+        match self.xml.read_event_into(&mut self.buf)? {
             XmlEv::Text(e) => {
-                let txt = e.unescaped()?;
-                let txt = str::from_utf8(&txt)?.trim().into();
+                let txt = e.unescape()?;
+                let txt = txt.into();
                 if !close_tag.is_empty() {
-                    match self.xml.read_event(&mut self.buf)? {
+                    match self.xml.read_event_into(&mut self.buf)? {
                         XmlEv::End(e) => {
-                            if e.name() == close_tag {
+                            if e.name().into_inner() == close_tag {
                                 return Ok(txt);
                             }
                             Err(Error::Parse(format!(
@@ -361,9 +362,9 @@ impl<B: BufRead> Parser<B> {
                 let txt = e.into_inner();
                 let txt = str::from_utf8(&txt)?.trim().into();
                 if !close_tag.is_empty() {
-                    match self.xml.read_event(&mut self.buf)? {
+                    match self.xml.read_event_into(&mut self.buf)? {
                         XmlEv::End(e) => {
-                            if e.name() == close_tag {
+                            if e.name().into_inner() == close_tag {
                                 return Ok(txt);
                             }
                             Err(Error::Parse(format!(
@@ -382,12 +383,12 @@ impl<B: BufRead> Parser<B> {
                 }
             }
             XmlEv::End(e) => {
-                if e.name() == close_tag {
+                if e.name().into_inner() == close_tag {
                     Ok(String::new())
                 } else {
                     Err(Error::Parse(format!(
                         "expected text, found </{}>",
-                        str::from_utf8(e.name()).unwrap()
+                        str::from_utf8(e.name().into_inner()).unwrap()
                     )))
                 }
             }
@@ -396,23 +397,23 @@ impl<B: BufRead> Parser<B> {
     }
 
     fn expect_start(&mut self) -> Result<Vec<u8>> {
-        match self.xml.read_event(&mut self.buf)? {
-            XmlEv::Start(e) | XmlEv::Empty(e) => Ok(Vec::from(e.name())),
+        match self.xml.read_event_into(&mut self.buf)? {
+            XmlEv::Start(e) | XmlEv::Empty(e) => Ok(Vec::from(e.name().into_inner())),
             ev => Err(Error::Parse(format!("expected start tag, found {:?}", ev))),
         }
     }
 
     fn expect_close_tag(&mut self, tag: &[u8]) -> Result<()> {
         loop {
-            match self.xml.read_event(&mut self.buf)? {
+            match self.xml.read_event_into(&mut self.buf)? {
                 XmlEv::End(e) => {
-                    if e.name() == tag {
+                    if e.name().into_inner() == tag {
                         return Ok(());
                     } else {
                         return Err(Error::Parse(format!(
                             "expected </{}>, got </{}>",
                             str::from_utf8(tag).unwrap(),
-                            str::from_utf8(e.name())?
+                            str::from_utf8(e.name().into_inner())?
                         )));
                     }
                 }
@@ -444,8 +445,8 @@ impl<B: BufRead> Parser<B> {
         let mut sees = Vec::new();
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
-                XmlEv::Start(ref e) => match e.name() {
+            match self.xml.read_event_into(&mut self.buf)? {
+                XmlEv::Start(ref e) => match e.name().into_inner() {
                     b"brief" => {
                         brief = Some(self.expect_text_trim(b"brief")?);
                     }
@@ -473,7 +474,7 @@ impl<B: BufRead> Parser<B> {
                     _ => {}
                 },
                 XmlEv::Empty(ref e) => {
-                    if e.name() == b"field" {
+                    if e.name().into_inner() == b"field" {
                         let name = expect_attribute(e.attributes(), b"name")?;
                         fields.push(DocField {
                             name,
@@ -485,7 +486,7 @@ impl<B: BufRead> Parser<B> {
                     return Err(Error::Parse("Unexpected doc text out of element".into()));
                 }
                 XmlEv::End(ref e) => {
-                    if e.name() == b"doc" {
+                    if e.name().into_inner() == b"doc" {
                         break;
                     }
                 }
@@ -566,12 +567,12 @@ impl<B: BufRead> Parser<B> {
     }
 
     fn parse_expr(&mut self, empty_end_tag: &[u8]) -> Result<Option<Expr>> {
-        match self.xml.read_event(&mut self.buf)? {
+        match self.xml.read_event_into(&mut self.buf)? {
             XmlEv::Start(ref e) => {
                 let e = e.to_owned();
                 Ok(Some(self.parse_expr_content(
                     e.attributes(),
-                    e.name(),
+                    e.name().into_inner(),
                     false,
                 )?))
             }
@@ -579,18 +580,18 @@ impl<B: BufRead> Parser<B> {
                 let e = e.to_owned();
                 Ok(Some(self.parse_expr_content(
                     e.attributes(),
-                    e.name(),
+                    e.name().into_inner(),
                     true,
                 )?))
             }
             XmlEv::Comment(_) => self.parse_expr(empty_end_tag), // in case of comment, we just parse the next one
             XmlEv::End(e) => {
-                if e.name() == empty_end_tag {
+                if e.name().into_inner() == empty_end_tag {
                     Ok(None)
                 } else {
                     Err(Error::Parse(format!(
                         "Unexpected </{}> while parsing expression",
-                        str::from_utf8(e.name()).unwrap()
+                        str::from_utf8(e.name().into_inner()).unwrap()
                     )))
                 }
             }
@@ -611,8 +612,8 @@ impl<B: BufRead> Parser<B> {
         let mut xidtypes = Vec::new();
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
-                XmlEv::Start(ref e) => match e.name() {
+            match self.xml.read_event_into(&mut self.buf)? {
+                XmlEv::Start(ref e) => match e.name().into_inner() {
                     b"type" => {
                         let typ = self.expect_text_trim(b"type")?;
                         xidtypes.push(typ);
@@ -624,7 +625,7 @@ impl<B: BufRead> Parser<B> {
                         )));
                     }
                 },
-                XmlEv::End(ref e) => match e.name() {
+                XmlEv::End(ref e) => match e.name().into_inner() {
                     b"xidunion" => break,
                     _ => unreachable!(),
                 },
@@ -645,8 +646,8 @@ impl<B: BufRead> Parser<B> {
         let mut doc = None;
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
-                XmlEv::Empty(ref e) | XmlEv::Start(ref e) => match e.name() {
+            match self.xml.read_event_into(&mut self.buf)? {
+                XmlEv::Empty(ref e) | XmlEv::Start(ref e) => match e.name().into_inner() {
                     b"item" => {
                         let name = expect_attribute(e.attributes(), b"name")?;
                         let (tag, value) = self.expect_text_element()?;
@@ -682,7 +683,7 @@ impl<B: BufRead> Parser<B> {
                         )));
                     }
                 },
-                XmlEv::End(ref e) => match e.name() {
+                XmlEv::End(ref e) => match e.name().into_inner() {
                     b"enum" => break,
                     b"item" => continue,
                     tag => {
@@ -704,7 +705,7 @@ impl<B: BufRead> Parser<B> {
 
     fn parse_field_content(&mut self, e: &BytesStart, empty_tag: bool) -> Result<Option<Field>> {
         if empty_tag {
-            match e.name() {
+            match e.name().into_inner() {
                 b"required_start_align" => {
                     // this is meant for checking if padding is correct in the  XML
                     // we simply ignore this in the rust bindings
@@ -719,27 +720,27 @@ impl<B: BufRead> Parser<B> {
                     let mut altmask = None;
                     for attr in e.attributes() {
                         match attr {
-                            Ok(attr) if attr.key == b"type" => {
+                            Ok(attr) if attr.key.into_inner() == b"type" => {
                                 r#type = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"name" => {
+                            Ok(attr) if attr.key.into_inner() == b"name" => {
                                 name = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"enum" => {
+                            Ok(attr) if attr.key.into_inner() == b"enum" => {
                                 r#enum = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"mask" => {
+                            Ok(attr) if attr.key.into_inner() == b"mask" => {
                                 mask = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"altenum" => {
+                            Ok(attr) if attr.key.into_inner() == b"altenum" => {
                                 altenum = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"altmask" => {
+                            Ok(attr) if attr.key.into_inner() == b"altmask" => {
                                 altmask = Some(attr_value(&attr).unwrap());
                             }
                             Ok(attr) => unreachable!(
                                 "field attribute {}",
-                                str::from_utf8(attr.key).unwrap()
+                                str::from_utf8(attr.key.into_inner()).unwrap()
                             ),
                             Err(err) => return Err(err.into()),
                         }
@@ -788,21 +789,21 @@ impl<B: BufRead> Parser<B> {
                     let mut mask = None;
                     for attr in e.attributes() {
                         match attr {
-                            Ok(attr) if attr.key == b"type" => {
+                            Ok(attr) if attr.key.into_inner() == b"type" => {
                                 r#type = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"name" => {
+                            Ok(attr) if attr.key.into_inner() == b"name" => {
                                 name = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"enum" => {
+                            Ok(attr) if attr.key.into_inner() == b"enum" => {
                                 r#enum = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"mask" => {
+                            Ok(attr) if attr.key.into_inner() == b"mask" => {
                                 mask = Some(attr_value(&attr).unwrap());
                             }
                             Ok(attr) => unreachable!(
                                 "field attribute {}",
-                                str::from_utf8(attr.key).unwrap()
+                                str::from_utf8(attr.key.into_inner()).unwrap()
                             ),
                             Err(err) => return Err(err.into()),
                         }
@@ -850,7 +851,7 @@ impl<B: BufRead> Parser<B> {
                 ))),
             }
         } else {
-            match e.name() {
+            match e.name().into_inner() {
                 b"list" => {
                     let mut r#type = None;
                     let mut name = None;
@@ -858,21 +859,21 @@ impl<B: BufRead> Parser<B> {
                     let mut mask = None;
                     for attr in e.attributes() {
                         match attr {
-                            Ok(attr) if attr.key == b"type" => {
+                            Ok(attr) if attr.key.into_inner() == b"type" => {
                                 r#type = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"name" => {
+                            Ok(attr) if attr.key.into_inner() == b"name" => {
                                 name = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"enum" => {
+                            Ok(attr) if attr.key.into_inner() == b"enum" => {
                                 r#enum = Some(attr_value(&attr).unwrap());
                             }
-                            Ok(attr) if attr.key == b"mask" => {
+                            Ok(attr) if attr.key.into_inner() == b"mask" => {
                                 mask = Some(attr_value(&attr).unwrap());
                             }
                             Ok(attr) => unreachable!(
                                 "field attribute {}",
-                                str::from_utf8(attr.key).unwrap()
+                                str::from_utf8(attr.key.into_inner()).unwrap()
                             ),
                             Err(err) => return Err(err.into()),
                         }
@@ -907,7 +908,7 @@ impl<B: BufRead> Parser<B> {
                     let [typ, nam] = vals;
                     if let (Some(typ), Some(name)) = (typ, nam) {
                         let expr = self.parse_expr(b"")?.unwrap();
-                        self.xml.read_to_end(b"exprfield", &mut self.buf)?;
+                        self.xml.read_to_end_into(QName(b"exprfield"), &mut self.buf)?;
                         Ok(Some(Field::Expr { name, typ, expr }))
                     } else {
                         Err(Error::Parse(
@@ -934,7 +935,7 @@ impl<B: BufRead> Parser<B> {
         let mut doc = None;
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
+            match self.xml.read_event_into(&mut self.buf)? {
                 XmlEv::Empty(ref e) => {
                     let e = e.to_owned();
                     let f = self.parse_field_content(&e, true)?;
@@ -942,7 +943,7 @@ impl<B: BufRead> Parser<B> {
                         fields.push(f);
                     }
                 }
-                XmlEv::Start(ref e) => match e.name() {
+                XmlEv::Start(ref e) => match e.name().into_inner() {
                     b"list" | b"exprfield" | b"switch" => {
                         let e = e.to_owned();
                         let f = self.parse_field_content(&e, false)?;
@@ -967,7 +968,7 @@ impl<B: BufRead> Parser<B> {
                     }
                 },
                 XmlEv::End(ref e) => {
-                    if e.name() == end_tag {
+                    if e.name().into_inner() == end_tag {
                         break;
                     }
                 }
@@ -1013,7 +1014,7 @@ impl<B: BufRead> Parser<B> {
             }
             _ => Err(Error::Parse(format!(
                 "<{}> without name or number",
-                str::from_utf8(start.name())?
+                str::from_utf8(start.name().into_inner())?
             ))),
         }
     }
@@ -1023,8 +1024,8 @@ impl<B: BufRead> Parser<B> {
         let mut selectors = Vec::new();
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
-                XmlEv::Empty(ref e) if e.name() == b"allowed" => {
+            match self.xml.read_event_into(&mut self.buf)? {
+                XmlEv::Empty(ref e) if e.name().into_inner() == b"allowed" => {
                     let names: [&[u8]; 4] = [b"extension", b"xge", b"opcode-min", b"opcode-max"];
                     let mut vals: [Option<String>; 4] = [None, None, None, None];
                     get_attributes(e.attributes(), &names, &mut vals)?;
@@ -1051,7 +1052,7 @@ impl<B: BufRead> Parser<B> {
                         }
                     }
                 }
-                XmlEv::End(ref e) if e.name() == b"eventstruct" => {
+                XmlEv::End(ref e) if e.name().into_inner() == b"eventstruct" => {
                     break;
                 }
                 XmlEv::Comment(..) => {}
@@ -1105,11 +1106,11 @@ impl<B: BufRead> Parser<B> {
         let mut fields = Vec::new();
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
+            match self.xml.read_event_into(&mut self.buf)? {
                 XmlEv::Start(ref e) => {
                     let e = e.to_owned();
-                    if is_expr_tag(e.name()) {
-                        let expr = self.parse_expr_content(e.attributes(), e.name(), false)?;
+                    if is_expr_tag(e.name().into_inner()) {
+                        let expr = self.parse_expr_content(e.attributes(), e.name().into_inner(), false)?;
                         exprs.push(expr);
                     } else {
                         let field = self.parse_field_content(&e, false)?;
@@ -1120,8 +1121,8 @@ impl<B: BufRead> Parser<B> {
                 }
                 XmlEv::Empty(ref e) => {
                     let e = e.to_owned();
-                    if is_expr_tag(e.name()) {
-                        let expr = self.parse_expr_content(e.attributes(), e.name(), true)?;
+                    if is_expr_tag(e.name().into_inner()) {
+                        let expr = self.parse_expr_content(e.attributes(), e.name().into_inner(), true)?;
                         exprs.push(expr);
                     } else {
                         let field = self.parse_field_content(&e, true)?;
@@ -1132,7 +1133,7 @@ impl<B: BufRead> Parser<B> {
                 }
                 XmlEv::Comment(_) => {}
                 XmlEv::End(ref e) => {
-                    if e.name() == end_tag {
+                    if e.name().into_inner() == end_tag {
                         break;
                     }
                 }
@@ -1159,13 +1160,13 @@ impl<B: BufRead> Parser<B> {
         let mut cases = Vec::new();
 
         loop {
-            match self.xml.read_event(&mut self.buf)? {
+            match self.xml.read_event_into(&mut self.buf)? {
                 XmlEv::Start(ref e) => {
                     let names: [&[u8]; 1] = [b"name"];
                     let mut vals: [Option<String>; 1] = [None];
                     get_attributes(e.attributes(), &names, &mut vals)?;
                     let [name] = vals;
-                    match e.name() {
+                    match e.name().into_inner() {
                         b"bitcase" => {
                             cases.push(self.parse_switch_case(name, b"bitcase")?);
                         }
@@ -1181,7 +1182,7 @@ impl<B: BufRead> Parser<B> {
                     }
                 }
                 XmlEv::End(ref e) => {
-                    if e.name() == b"switch" {
+                    if e.name().into_inner() == b"switch" {
                         break;
                     }
                 }
@@ -1231,15 +1232,15 @@ fn is_expr_tag(tag: &[u8]) -> bool {
 }
 
 fn attr_value(attr: &Attribute) -> Result<String> {
-    let val = attr.unescaped_value()?;
-    Ok(str::from_utf8(&val)?.into())
+    let val = attr.unescape_value()?;
+    Ok(val.into())
 }
 
 fn expect_attribute(attrs: Attributes, name: &[u8]) -> Result<String> {
     for attr in attrs {
         match attr {
             Ok(attr) => {
-                if attr.key == name {
+                if attr.key.into_inner() == name {
                     return attr_value(&attr);
                 }
             }
@@ -1258,7 +1259,7 @@ fn get_attributes(attrs: Attributes, nam
         match attr {
             Ok(attr) => {
                 for (i, nam) in names.iter().enumerate() {
-                    if attr.key == *nam {
+                    if attr.key.into_inner() == *nam {
                         output[i] = Some(attr_value(&attr)?);
                     }
                 }
