Use atomicu32 instead of atomicu8 on armel to workaround rustc/llvm issue
with 8-bit atomics on that platform.

See also: https://github.com/rust-lang/rust/issues/100650

We assume armel, if the target_arch is "arm" and the target does not have
64-bit atomics.

Index: rust-concurrent-arena-0.1.10/src/bucket.rs
===================================================================
--- rust-concurrent-arena-0.1.10.orig/src/bucket.rs
+++ rust-concurrent-arena-0.1.10/src/bucket.rs
@@ -1,7 +1,7 @@
 use super::{bitmap::BitMap, Arc, OptionExt, SliceExt};
 
 use core::{array, cell::UnsafeCell, hint::spin_loop, ops::Deref};
-use std::sync::atomic::{fence, AtomicU8, Ordering};
+use std::sync::atomic::{fence, AtomicU8, AtomicU32, Ordering};
 
 const REMOVED_MASK: u8 = 1 << (u8::BITS - 1);
 const REFCNT_MASK: u8 = !REMOVED_MASK;
@@ -9,6 +9,9 @@ pub const MAX_REFCNT: u8 = REFCNT_MASK;
 
 #[derive(Debug)]
 struct Entry<T> {
+    #[cfg(all(target_arch="arm", not(target_has_atomic="64")))]
+    counter: AtomicU32,
+    #[cfg(not(all(target_arch="arm", not(target_has_atomic="64"))))]
     counter: AtomicU8,
     val: UnsafeCell<Option<T>>,
 }
@@ -16,6 +19,9 @@ struct Entry<T> {
 impl<T> Entry<T> {
     const fn new() -> Self {
         Self {
+            #[cfg(all(target_arch="arm", not(target_has_atomic="64")))]
+            counter: AtomicU32::new(0),
+            #[cfg(not(all(target_arch="arm", not(target_has_atomic="64"))))]
             counter: AtomicU8::new(0),
             val: UnsafeCell::new(None),
         }
@@ -134,7 +140,7 @@ impl<T: Send + Sync, const BITARRAY_LEN:
             let mut refcnt = counter.load(Ordering::Relaxed);
 
             loop {
-                if (refcnt & REMOVED_MASK) != 0 {
+                if (refcnt as u8 & REMOVED_MASK) != 0 {
                     return None;
                 }
 
@@ -148,7 +154,7 @@ impl<T: Send + Sync, const BITARRAY_LEN:
 
                 match counter.compare_exchange_weak(
                     refcnt,
-                    update_refcnt(refcnt),
+                    update_refcnt(refcnt as u8) as _,
                     Ordering::Relaxed,
                     Ordering::Relaxed,
                 ) {
@@ -219,20 +225,20 @@ impl<T: Send + Sync, const BITARRAY_LEN:
                 .entries
                 .get_unchecked_on_release(Self::get_index(this))
         };
-        debug_assert!((entry.counter.load(Ordering::Relaxed) & REFCNT_MASK) > 0);
+        debug_assert!((entry.counter.load(Ordering::Relaxed) as u8 & REFCNT_MASK) > 0);
         entry
     }
 
     pub fn strong_count(this: &Self) -> u8 {
         let entry = Self::get_entry(this);
-        let cnt = entry.counter.load(Ordering::Relaxed) & REFCNT_MASK;
+        let cnt = entry.counter.load(Ordering::Relaxed) as u8 & REFCNT_MASK;
         debug_assert!(cnt > 0);
         cnt
     }
 
     pub fn is_removed(this: &Self) -> bool {
         let counter = &Self::get_entry(this).counter;
-        let refcnt = counter.load(Ordering::Relaxed);
+        let refcnt = counter.load(Ordering::Relaxed) as u8;
 
         (refcnt & REMOVED_MASK) != 0
     }
@@ -245,9 +251,9 @@ impl<T: Send + Sync, const BITARRAY_LEN:
         let mut refcnt = counter.load(Ordering::Relaxed);
 
         loop {
-            debug_assert_ne!(refcnt & REFCNT_MASK, 0);
+            debug_assert_ne!((refcnt as u8) & REFCNT_MASK, 0);
 
-            if (refcnt & REMOVED_MASK) != 0 {
+            if (refcnt as u8 & REMOVED_MASK) != 0 {
                 // already removed
                 return false;
             }
@@ -260,7 +266,7 @@ impl<T: Send + Sync, const BITARRAY_LEN:
             match counter.compare_exchange_weak(
                 refcnt,
                 // Reduce refcnt by one since it is removed from bucket.
-                (refcnt - 1) | REMOVED_MASK,
+                ((refcnt - 1) as u8 | REMOVED_MASK) as _,
                 Ordering::Relaxed,
                 Ordering::Relaxed,
             ) {
@@ -295,7 +301,7 @@ impl<T: Send + Sync, const BITARRAY_LEN:
         // reference alive.
         //
         // [1]: https://www.boost.org/doc/libs/1_77_0/doc/html/atomic/usage_examples.html
-        if (entry.counter.fetch_add(1, Ordering::Relaxed) & REFCNT_MASK) == MAX_REFCNT {
+        if (entry.counter.fetch_add(1, Ordering::Relaxed) as u8 & REFCNT_MASK) == MAX_REFCNT {
             panic!("ArenaArc can have at most u8::MAX refcount");
         }
 
@@ -318,7 +324,7 @@ impl<T: Send + Sync, const BITARRAY_LEN:
         // reference is dropped.
         //
         // [1]: https://www.boost.org/doc/libs/1_77_0/doc/html/atomic/usage_examples.html
-        let prev_counter = entry.counter.fetch_sub(1, Ordering::Release);
+        let prev_counter = entry.counter.fetch_sub(1, Ordering::Release) as u8;
         let prev_refcnt = prev_counter & MAX_REFCNT;
 
         debug_assert_ne!(prev_refcnt, 0);
