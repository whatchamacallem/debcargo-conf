This patch is based on the upstream commit described below, adaptd for use
in the Debian package by Peter Michael Green.

Index: wayland-backend/Cargo.toml
===================================================================
--- wayland-backend.orig/Cargo.toml
+++ wayland-backend/Cargo.toml
@@ -44,16 +44,14 @@ version = "2.0.0"
 version = "0.4"
 optional = true
 
-[dependencies.nix]
-version = "0.26.0"
+[dependencies.rustix]
+version = "0.38.17"
 features = [
     "event",
     "fs",
-    "poll",
-    "socket",
-    "uio",
+    "net",
+    "process",
 ]
-default-features = false
 
 [dependencies.raw-window-handle]
 version = "0.5.0"
Index: wayland-backend/src/rs/server_impl/client.rs
===================================================================
--- wayland-backend.orig/src/rs/server_impl/client.rs
+++ wayland-backend/src/rs/server_impl/client.rs
@@ -1,5 +1,6 @@
 use std::{
     ffi::CString,
+    os::unix::io::{AsFd, BorrowedFd, OwnedFd},
     os::unix::{io::RawFd, net::UnixStream},
     sync::Arc,
 };
@@ -15,7 +16,6 @@ use crate::{
     types::server::{DisconnectReason, InvalidId},
 };
 
-use io_lifetimes::OwnedFd;
 use smallvec::SmallVec;
 
 use crate::rs::{
@@ -295,13 +295,10 @@ impl<D> Client<D> {
 
     #[cfg(any(target_os = "linux", target_os = "android"))]
     pub(crate) fn get_credentials(&self) -> Credentials {
-        use std::os::unix::io::AsRawFd;
-        let creds = nix::sys::socket::getsockopt(
-            self.socket.as_raw_fd(),
-            nix::sys::socket::sockopt::PeerCredentials,
-        )
-        .expect("getsockopt failed!?");
-        Credentials { pid: creds.pid(), uid: creds.uid(), gid: creds.gid() }
+        let creds =
+            rustix::net::sockopt::get_socket_peercred(&self.socket).expect("getsockopt failed!?");
+        let pid = rustix::process::Pid::as_raw(Some(creds.pid));
+        Credentials { pid, uid: creds.uid.as_raw(), gid: creds.gid.as_raw() }
     }
 
     #[cfg(not(any(target_os = "linux", target_os = "android")))]
@@ -336,7 +333,7 @@ impl<D> Client<D> {
         &mut self,
     ) -> std::io::Result<(Message<u32, OwnedFd>, Object<Data<D>>)> {
         if self.killed {
-            return Err(nix::errno::Errno::EPIPE.into());
+            return Err(rustix::io::Errno::PIPE.into());
         }
         loop {
             let map = &self.map;
@@ -358,7 +355,7 @@ impl<D> Client<D> {
                 }
                 Err(MessageParseError::Malformed) => {
                     self.kill(DisconnectReason::ConnectionClosed);
-                    return Err(nix::errno::Errno::EPROTO.into());
+                    return Err(rustix::io::Errno::PROTO.into());
                 }
             };
 
@@ -649,6 +646,12 @@ impl<D> Client<D> {
     }
 }
 
+impl<D> AsFd for Client<D> {
+    fn as_fd(&self) -> BorrowedFd<'_> {
+        self.socket.as_fd()
+    }
+}
+
 #[derive(Debug)]
 pub(crate) struct ClientStore<D: 'static> {
     clients: Vec<Option<Client<D>>>,
Index: wayland-backend/src/rs/server_impl/common_poll.rs
===================================================================
--- wayland-backend.orig/src/rs/server_impl/common_poll.rs
+++ wayland-backend/src/rs/server_impl/common_poll.rs
@@ -16,7 +16,7 @@ use crate::{
 
 use io_lifetimes::{BorrowedFd, OwnedFd};
 #[cfg(any(target_os = "linux", target_os = "android"))]
-use nix::sys::epoll::*;
+use rustix::event::epoll;
 
 #[cfg(any(
     target_os = "dragonfly",
@@ -24,7 +24,7 @@ use nix::sys::epoll::*;
     target_os = "netbsd",
     target_os = "openbsd"
 ))]
-use nix::sys::event::*;
+use rustix::event::kqueue::*;
 use smallvec::SmallVec;
 
 #[derive(Debug)]
@@ -35,7 +35,7 @@ pub struct InnerBackend<D: 'static> {
 impl<D> InnerBackend<D> {
     pub fn new() -> Result<Self, InitError> {
         #[cfg(any(target_os = "linux", target_os = "android"))]
-        let poll_fd = epoll_create1(EpollCreateFlags::EPOLL_CLOEXEC)
+        let poll_fd = epoll::create(epoll::CreateFlags::CLOEXEC)
             .map_err(Into::into)
             .map_err(InitError::Io)?;
 
@@ -47,9 +47,7 @@ impl<D> InnerBackend<D> {
         ))]
         let poll_fd = kqueue().map_err(Into::into).map_err(InitError::Io)?;
 
-        Ok(Self {
-            state: Arc::new(Mutex::new(State::new(unsafe { OwnedFd::from_raw_fd(poll_fd) }))),
-        })
+        Ok(Self { state: Arc::new(Mutex::new(State::new(poll_fd))) })
     }
 
     pub fn flush(&self, client: Option<ClientId>) -> std::io::Result<()> {
@@ -80,18 +78,20 @@ impl<D> InnerBackend<D> {
 
     #[cfg(any(target_os = "linux", target_os = "android"))]
     pub fn dispatch_all_clients(&self, data: &mut D) -> std::io::Result<usize> {
+        use std::os::unix::io::AsFd;
+
         let poll_fd = self.poll_fd();
         let mut dispatched = 0;
         loop {
-            let mut events = [EpollEvent::empty(); 32];
-            let nevents = epoll_wait(poll_fd.as_raw_fd(), &mut events, 0)?;
+            let mut events = epoll::EventVec::with_capacity(32);
+            epoll::wait(poll_fd.as_fd(), &mut events, 0)?;
 
-            if nevents == 0 {
+            if events.is_empty() {
                 break;
             }
 
-            for event in events.iter().take(nevents) {
-                let id = InnerClientId::from_u64(event.data());
+            for event in events.iter() {
+                let id = InnerClientId::from_u64(event.data.u64());
                 // remove the cb while we call it, to gracefully handle reentrancy
                 if let Ok(count) = self.dispatch_events_for(data, id) {
                     dispatched += count;
@@ -111,19 +111,13 @@ impl<D> InnerBackend<D> {
         target_os = "openbsd"
     ))]
     pub fn dispatch_all_clients(&self, data: &mut D) -> std::io::Result<usize> {
+        use std::time::Duration;
+
         let poll_fd = self.poll_fd();
         let mut dispatched = 0;
         loop {
-            let mut events = [KEvent::new(
-                0,
-                EventFilter::EVFILT_READ,
-                EventFlag::empty(),
-                FilterFlag::empty(),
-                0,
-                0,
-            ); 32];
-
-            let nevents = kevent(poll_fd.as_raw_fd(), &[], &mut events, 0)?;
+            let mut events = Vec::with_capacity(32);
+            let nevents = unsafe { kevent(&poll_fd, &[], &mut events, Some(Duration::ZERO))? };
 
             if nevents == 0 {
                 break;
Index: wayland-backend/src/rs/server_impl/handle.rs
===================================================================
--- wayland-backend.orig/src/rs/server_impl/handle.rs
+++ wayland-backend/src/rs/server_impl/handle.rs
@@ -305,15 +305,19 @@ impl<D> ErasedState for State<D> {
         stream: UnixStream,
         data: Arc<dyn ClientData>,
     ) -> std::io::Result<InnerClientId> {
-        let client_fd = stream.as_raw_fd();
         let id = self.clients.create_client(stream, data);
+        let client = self.clients.get_client(id.clone()).unwrap();
 
         // register the client to the internal epoll
         #[cfg(any(target_os = "linux", target_os = "android"))]
         let ret = {
-            use nix::sys::epoll::*;
-            let mut evt = EpollEvent::new(EpollFlags::EPOLLIN, id.as_u64());
-            epoll_ctl(self.poll_fd.as_raw_fd(), EpollOp::EpollCtlAdd, client_fd, &mut evt)
+            use rustix::event::epoll;
+            epoll::add(
+                &self.poll_fd,
+                client,
+                epoll::EventData::new_u64(id.as_u64()),
+                epoll::EventFlags::IN,
+            )
         };
 
         #[cfg(any(
@@ -323,17 +327,17 @@ impl<D> ErasedState for State<D> {
             target_os = "openbsd"
         ))]
         let ret = {
-            use nix::sys::event::*;
-            let evt = KEvent::new(
-                client_fd as usize,
-                EventFilter::EVFILT_READ,
-                EventFlag::EV_ADD | EventFlag::EV_RECEIPT,
-                FilterFlag::empty(),
-                0,
+            use rustix::event::kqueue::*;
+            use std::os::unix::io::{AsFd, AsRawFd};
+
+            let evt = Event::new(
+                EventFilter::Read(client.as_fd().as_raw_fd()),
+                EventFlags::ADD | EventFlags::RECEIPT,
                 id.as_u64() as isize,
             );
 
-            kevent_ts(self.poll_fd.as_raw_fd(), &[evt], &mut [], None).map(|_| ())
+            let mut events = Vec::new();
+            unsafe { kevent(&self.poll_fd, &[evt], &mut events, None).map(|_| ()) }
         };
 
         match ret {
Index: wayland-backend/src/rs/socket.rs
===================================================================
--- wayland-backend.orig/src/rs/socket.rs
+++ wayland-backend/src/rs/socket.rs
@@ -1,11 +1,14 @@
 //! Wayland socket manipulation
 
 use std::io::{ErrorKind, IoSlice, IoSliceMut, Result as IoResult};
-use std::os::unix::io::{AsRawFd, RawFd};
+use std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, IntoRawFd, OwnedFd, RawFd};
 use std::os::unix::net::UnixStream;
+use std::slice;
 
-use io_lifetimes::{AsFd, BorrowedFd, OwnedFd};
-use nix::sys::socket;
+use rustix::net::{
+    recvmsg, sendmsg, RecvAncillaryBuffer, RecvAncillaryMessage, RecvFlags, SendAncillaryBuffer,
+    SendAncillaryMessage, SendFlags,
+};
 
 use crate::protocol::{ArgumentType, Message};
 
@@ -35,14 +38,19 @@ impl Socket {
     /// slice should not be longer than `MAX_BYTES_OUT` otherwise the receiving
     /// end may lose some data.
     pub fn send_msg(&self, bytes: &[u8], fds: &[RawFd]) -> IoResult<usize> {
-        let flags = socket::MsgFlags::MSG_DONTWAIT | socket::MsgFlags::MSG_NOSIGNAL;
+        let flags = SendFlags::DONTWAIT | SendFlags::NOSIGNAL;
         let iov = [IoSlice::new(bytes)];
 
         if !fds.is_empty() {
-            let cmsgs = [socket::ControlMessage::ScmRights(fds)];
-            Ok(socket::sendmsg::<()>(self.stream.as_raw_fd(), &iov, &cmsgs, flags, None)?)
+            let mut cmsg_space = vec![0; rustix::cmsg_space!(ScmRights(fds.len()))];
+            let mut cmsg_buffer = SendAncillaryBuffer::new(&mut cmsg_space);
+            let fds =
+                unsafe { slice::from_raw_parts(fds.as_ptr() as *const BorrowedFd, fds.len()) };
+            cmsg_buffer.push(SendAncillaryMessage::ScmRights(fds));
+            Ok(sendmsg(self, &iov, &mut cmsg_buffer, flags)?)
         } else {
-            Ok(socket::sendmsg::<()>(self.stream.as_raw_fd(), &iov, &[], flags, None)?)
+            let mut cmsg_buffer = SendAncillaryBuffer::new(&mut []);
+            Ok(sendmsg(self, &iov, &mut cmsg_buffer, flags)?)
         }
     }
 
@@ -58,25 +66,27 @@ impl Socket {
     /// slice `MAX_FDS_OUT` long, otherwise some data of the received message may
     /// be lost.
     pub fn rcv_msg(&self, buffer: &mut [u8], fds: &mut [RawFd]) -> IoResult<(usize, usize)> {
-        let mut cmsg = nix::cmsg_space!([RawFd; MAX_FDS_OUT]);
+        let mut cmsg_space = vec![0; rustix::cmsg_space!(ScmRights(MAX_FDS_OUT))];
+        let mut cmsg_buffer = RecvAncillaryBuffer::new(&mut cmsg_space);
         let mut iov = [IoSliceMut::new(buffer)];
-        let msg = socket::recvmsg::<()>(
-            self.stream.as_raw_fd(),
+        let msg = recvmsg(
+            &self.stream,
             &mut iov[..],
-            Some(&mut cmsg),
-            socket::MsgFlags::MSG_DONTWAIT
-                | socket::MsgFlags::MSG_CMSG_CLOEXEC
-                | socket::MsgFlags::MSG_NOSIGNAL,
+            &mut cmsg_buffer,
+            RecvFlags::DONTWAIT | RecvFlags::CMSG_CLOEXEC,
         )?;
 
         let mut fd_count = 0;
-        let received_fds = msg.cmsgs().flat_map(|cmsg| match cmsg {
-            socket::ControlMessageOwned::ScmRights(s) => s,
-            _ => Vec::new(),
-        });
+        let received_fds = cmsg_buffer
+            .drain()
+            .filter_map(|cmsg| match cmsg {
+                RecvAncillaryMessage::ScmRights(fds) => Some(fds),
+                _ => None,
+            })
+            .flatten();
         for (fd, place) in received_fds.zip(fds.iter_mut()) {
             fd_count += 1;
-            *place = fd;
+            *place = fd.into_raw_fd();
         }
         Ok((msg.bytes, fd_count))
     }
@@ -141,7 +151,7 @@ impl BufferedSocket {
             let written = self.socket.send_msg(bytes, fds)?;
             for &fd in fds {
                 // once the fds are sent, we can close them
-                let _ = ::nix::unistd::close(fd);
+                unsafe { rustix::io::close(fd) };
             }
             written
         };
@@ -192,7 +202,7 @@ impl BufferedSocket {
             if !self.attempt_write_message(msg)? {
                 // If this fails again, this means the message is too big
                 // to be transmitted at all
-                return Err(::nix::errno::Errno::E2BIG.into());
+                return Err(rustix::io::Errno::TOOBIG.into());
             }
         }
         Ok(())
@@ -215,7 +225,7 @@ impl BufferedSocket {
         };
         if in_bytes == 0 {
             // the other end of the socket was closed
-            return Err(::nix::errno::Errno::EPIPE.into());
+            return Err(rustix::io::Errno::PIPE.into());
         }
         // advance the storage
         self.in_data.advance(in_bytes / 4 + usize::from(in_bytes % 4 > 0));
@@ -342,14 +352,14 @@ mod tests {
     use crate::protocol::{AllowNull, Argument, ArgumentType, Message};
 
     use std::ffi::CString;
-    use std::os::unix::io::RawFd;
+    use std::os::unix::io::BorrowedFd;
     use std::os::unix::prelude::IntoRawFd;
 
     use smallvec::smallvec;
 
-    fn same_file(a: RawFd, b: RawFd) -> bool {
-        let stat1 = ::nix::sys::stat::fstat(a).unwrap();
-        let stat2 = ::nix::sys::stat::fstat(b).unwrap();
+    fn same_file(a: BorrowedFd, b: BorrowedFd) -> bool {
+        let stat1 = rustix::fs::fstat(a).unwrap();
+        let stat2 = rustix::fs::fstat(b).unwrap();
         stat1.st_dev == stat2.st_dev && stat1.st_ino == stat2.st_ino
     }
 
@@ -366,7 +376,9 @@ mod tests {
         assert_eq!(msg1.args.len(), msg2.args.len());
         for (arg1, arg2) in msg1.args.iter().zip(msg2.args.iter()) {
             if let (Argument::Fd(fd1), Argument::Fd(fd2)) = (arg1, arg2) {
-                assert!(same_file(fd1.as_raw_fd(), fd2.as_raw_fd()));
+                let fd1 = unsafe { BorrowedFd::borrow_raw(fd1.as_raw_fd()) };
+                let fd2 = unsafe { BorrowedFd::borrow_raw(fd2.as_raw_fd()) };
+                assert!(same_file(fd1, fd2));
             } else {
                 assert_eq!(arg1, arg2);
             }
Index: wayland-backend/src/sys/client_impl/mod.rs
===================================================================
--- wayland-backend.orig/src/sys/client_impl/mod.rs
+++ wayland-backend/src/sys/client_impl/mod.rs
@@ -309,7 +309,7 @@ impl ConnectionState {
     #[inline]
     fn store_and_return_error(&mut self, err: std::io::Error) -> WaylandError {
         // check if it was actually a protocol error
-        let err = if err.raw_os_error() == Some(nix::errno::Errno::EPROTO as i32) {
+        let err = if err.raw_os_error() == Some(rustix::io::Errno::PROTO.raw_os_error()) {
             let mut object_id = 0;
             let mut interface = std::ptr::null();
             let code = unsafe {
Index: wayland-backend/src/test/many_args.rs
===================================================================
--- wayland-backend.orig/src/test/many_args.rs
+++ wayland-backend/src/test/many_args.rs
@@ -1,6 +1,5 @@
 use std::{
     ffi::{CStr, CString},
-    os::unix::io::AsRawFd,
     sync::atomic::{AtomicBool, Ordering},
 };
 
@@ -32,8 +31,8 @@ macro_rules! serverdata_impls {
                     assert_eq!(&**a, &[1, 2, 3, 4, 5, 6, 7, 8, 9]);
                     assert_eq!(&***s, CStr::from_bytes_with_nul(b"I like trains\0").unwrap());
                     // compare the fd to stdin
-                    let stat1 = ::nix::sys::stat::fstat(fd.as_raw_fd()).unwrap();
-                    let stat2 = ::nix::sys::stat::fstat(0).unwrap();
+                    let stat1 = rustix::fs::fstat(&fd).unwrap();
+                    let stat2 = rustix::fs::fstat(std::io::stdin()).unwrap();
                     assert_eq!(stat1.st_dev, stat2.st_dev);
                     assert_eq!(stat1.st_ino, stat2.st_ino);
                 } else {
@@ -98,8 +97,8 @@ macro_rules! clientdata_impls {
                     assert_eq!(&**a, &[10, 20, 30, 40, 50, 60, 70, 80, 90]);
                     assert_eq!(&***s, CStr::from_bytes_with_nul(b"I want cake\0").unwrap());
                     // compare the fd to stdout
-                    let stat1 = ::nix::sys::stat::fstat(fd.as_raw_fd()).unwrap();
-                    let stat2 = ::nix::sys::stat::fstat(1).unwrap();
+                    let stat1 = rustix::fs::fstat(&fd).unwrap();
+                    let stat2 = rustix::fs::fstat(std::io::stdout()).unwrap();
                     assert_eq!(stat1.st_dev, stat2.st_dev);
                     assert_eq!(stat1.st_ino, stat2.st_ino);
                 } else {
Index: wayland-backend/src/types/server.rs
===================================================================
--- wayland-backend.orig/src/types/server.rs
+++ wayland-backend/src/types/server.rs
@@ -66,9 +66,9 @@ pub enum DisconnectReason {
 #[derive(Debug, Clone, Copy)]
 pub struct Credentials {
     /// pid of the client
-    pub pid: nix::libc::pid_t,
+    pub pid: rustix::process::RawPid,
     /// uid of the client
-    pub uid: nix::libc::uid_t,
+    pub uid: rustix::process::RawUid,
     /// gid of the client
-    pub gid: nix::libc::gid_t,
+    pub gid: rustix::process::RawGid,
 }
