Description: Disable tests that rely on test tarballs
 The test tarballs are not included in the crate on crates.io and hence are not
 included in the Debian package. I figure that it is better to run some of the
 tests than none of the tests.
Author: Peter Michael Green <plugwash@debian.org>

Index: tar/tests/all.rs
===================================================================
--- tar.orig/tests/all.rs
+++ tar/tests/all.rs
@@ -23,17 +23,17 @@ macro_rules! t {
     };
 }
 
-macro_rules! tar {
+/*macro_rules! tar {
     ($e:expr) => {
         &include_bytes!(concat!("archives/", $e))[..]
     };
-}
+}*/
 
 mod header;
 
 /// test that we can concatenate the simple.tar archive and extract the same entries twice when we
 /// use the ignore_zeros option.
-#[test]
+/*#[test]
 fn simple_concat() {
     let bytes = tar!("simple.tar");
     let mut archive_bytes = Vec::new();
@@ -76,9 +76,9 @@ fn simple_concat() {
 
         names
     }
-}
+}*/
 
-#[test]
+/*#[test]
 fn header_impls() {
     let mut ar = Archive::new(Cursor::new(tar!("simple.tar")));
     let hn = Header::new_old();
@@ -91,9 +91,9 @@ fn header_impls() {
         let h2b = h2.as_bytes();
         assert!(h1b[..] == h2b[..] && h2b[..] != hnb[..])
     }
-}
+}*/
 
-#[test]
+/*#[test]
 fn header_impls_missing_last_header() {
     let mut ar = Archive::new(Cursor::new(tar!("simple_missing_last_header.tar")));
     let hn = Header::new_old();
@@ -106,9 +106,9 @@ fn header_impls_missing_last_header() {
         let h2b = h2.as_bytes();
         assert!(h1b[..] == h2b[..] && h2b[..] != hnb[..])
     }
-}
+}*/
 
-#[test]
+/*#[test]
 fn reading_files() {
     let rdr = Cursor::new(tar!("reading_files.tar"));
     let mut ar = Archive::new(rdr);
@@ -127,7 +127,7 @@ fn reading_files() {
     assert_eq!(s, "b\nb\nb\nb\nb\nb\nb\nb\nb\nb\nb\n");
 
     assert!(entries.next().is_none());
-}
+}*/
 
 #[test]
 fn writing_files() {
@@ -221,7 +221,7 @@ fn reading_entries_common<R: Read>(mut e
     assert!(entries.next().is_none());
 }
 
-#[test]
+/*#[test]
 fn reading_entries() {
     let rdr = Cursor::new(tar!("reading_files.tar"));
     let mut ar = Archive::new(rdr);
@@ -234,6 +234,7 @@ fn reading_entries_with_seek() {
     let mut ar = Archive::new(rdr);
     reading_entries_common(ar.entries_with_seek().unwrap());
 }
+*/
 
 struct LoggingReader<R> {
     inner: R,
@@ -264,6 +265,7 @@ impl<T: Seek> Seek for LoggingReader<T>
     }
 }
 
+/*
 #[test]
 fn skipping_entries_with_seek() {
     let mut reader = LoggingReader::new(Cursor::new(tar!("reading_files.tar")));
@@ -281,6 +283,7 @@ fn skipping_entries_with_seek() {
     assert!(files == files_seekable);
     assert!(seekable_reader.read_bytes < reader.read_bytes);
 }
+*/
 
 fn check_dirtree(td: &TempDir) {
     let dir_a = td.path().join("a");
@@ -291,6 +294,7 @@ fn check_dirtree(td: &TempDir) {
     assert!(fs::metadata(&file_c).map(|m| m.is_file()).unwrap_or(false));
 }
 
+/*
 #[test]
 fn extracting_directories() {
     let td = TempBuilder::new().prefix("tar-rs").tempdir().unwrap();
@@ -1187,8 +1191,9 @@ fn reading_sparse() {
     assert!(s[0x2fa0 + 6..0x4000].chars().all(|x| x == '\u{0}'));
 
     assert!(entries.next().is_none());
-}
+}*/
 
+/*
 #[test]
 fn extract_sparse() {
     let rdr = Cursor::new(tar!("sparse.tar"));
@@ -1254,7 +1259,7 @@ fn sparse_with_trailing() {
     assert_eq!(&s[..0xc], "0MB through\n");
     assert!(s[0xc..0x100_000].chars().all(|x| x == '\u{0}'));
     assert_eq!(&s[0x100_000..], "1MB through\n");
-}
+}*/
 
 #[test]
 fn writing_sparse() {
@@ -1485,15 +1490,15 @@ fn tar_directory_containing_symlink_to_d
     ar.finish().unwrap();
 }
 
-#[test]
+/*#[test]
 fn long_path() {
     let td = t!(TempBuilder::new().prefix("tar-rs").tempdir());
     let rdr = Cursor::new(tar!("7z_long_path.tar"));
     let mut ar = Archive::new(rdr);
     assert!(ar.unpack(td.path()).is_ok());
-}
+}*/
 
-#[test]
+/*#[test]
 fn unpack_path_larger_than_windows_max_path() {
     let dir_name = "iamaprettylongnameandtobepreciseiam91characterslongwhichsomethinkisreallylongandothersdonot";
     // 183 character directory name
@@ -1504,7 +1509,7 @@ fn unpack_path_larger_than_windows_max_p
     let mut ar = Archive::new(rdr);
     // should unpack path greater than windows MAX_PATH length of 260 characters
     assert!(ar.unpack(td.path()).is_ok());
-}
+}*/
 
 #[test]
 fn append_long_multibyte() {
@@ -1689,7 +1694,7 @@ fn ownership_preserving() {
     }
 }
 
-#[test]
+/*#[test]
 #[cfg(unix)]
 fn pax_and_gnu_uid_gid() {
     let tarlist = [tar!("biguid_gnu.tar"), tar!("biguid_pax.tar")];
@@ -1714,4 +1719,4 @@ fn pax_and_gnu_uid_gid() {
             assert!(ar.unpack(td.path()).is_err());
         }
     }
-}
+}*/
