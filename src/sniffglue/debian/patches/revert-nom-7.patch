This patch is mostly a revert of https://github.com/kpcyrd/sniffglue/commit/20527db5722f756b720402beaff15f211565b6ba
adapted for use in the Debian package.

Index: sniffglue/src/lib.rs
===================================================================
--- sniffglue.orig/src/lib.rs
+++ sniffglue/src/lib.rs
@@ -1,5 +1,7 @@
 #![allow(clippy::upper_case_acronyms)]
 
+#[macro_use] extern crate nom;
+
 pub mod centrifuge;
 pub mod errors;
 pub mod link;
Index: sniffglue/src/nom_http.rs
===================================================================
--- sniffglue.orig/src/nom_http.rs
+++ sniffglue/src/nom_http.rs
@@ -7,22 +7,17 @@
 // extern crate nom;
 
 use nom::IResult;
-use nom::branch::alt;
-use nom::bytes::complete::{tag, take_while1};
-use nom::character::complete::char;
-use nom::multi::many1;
-use nom::sequence::{delimited, pair, preceded, terminated};
 // use std::env;
 // use std::fs::File;
 
-#[derive(Debug, PartialEq, Clone, Copy)]
+#[derive(Debug, Clone, Copy)]
 pub struct Request<'a> {
     pub method:  &'a [u8],
     pub uri:     &'a [u8],
     pub version: &'a [u8],
 }
 
-#[derive(Debug, PartialEq)]
+#[derive(Debug)]
 pub struct Header<'a> {
     pub name:  &'a [u8],
     pub value: Vec<&'a [u8]>,
@@ -68,84 +63,92 @@ fn is_version(c: u8) -> bool {
     (b'0'..=b'9').contains(&c) || c == b'.'
 }
 
-fn line_ending(input: &[u8]) -> IResult<&[u8], &[u8]> {
-    alt((tag(b"\r\n"), tag(b"\n")))(input)
-}
+named!(line_ending, alt!(tag!("\r\n") | tag!("\n")));
 
 fn request_line(input: &[u8]) -> IResult<&[u8], Request> {
-    let (input, method) = take_while1(is_token)(input)?;
-    let (input, _) = take_while1(is_space)(input)?;
-    let (input, uri) = take_while1(is_not_space)(input)?;
-    let (input, _) = take_while1(is_space)(input)?;
-    let (input, version) = http_version(input)?;
-    let (input, _) = line_ending(input)?;
-
-    Ok((input, Request {
+  do_parse!(input,
+    method: take_while1!(is_token)     >>
+            take_while1!(is_space)     >>
+    uri:    take_while1!(is_not_space) >>
+            take_while1!(is_space)     >>
+    version: http_version              >>
+    line_ending                        >>
+    ( Request {
         method,
         uri,
         version,
-    }))
+    } )
+  )
 }
 
-fn http_version(input: &[u8]) -> IResult<&[u8], &[u8]> {
-    preceded(
-        tag(b"HTTP/"),
-        take_while1(is_version)
-    )(input)
-}
-
-fn message_header_value(input: &[u8]) -> IResult<&[u8], &[u8]> {
-    delimited(
-        take_while1(is_horizontal_space),
-        take_while1(not_line_ending),
-        line_ending
-    )(input)
-}
+named!(http_version, preceded!(
+    tag!("HTTP/"),
+    take_while1!(is_version)
+));
+
+named!(message_header_value, delimited!(
+    take_while1!(is_horizontal_space),
+    take_while1!(not_line_ending),
+    line_ending
+));
 
 fn message_header(input: &[u8]) -> IResult<&[u8], Header> {
-    let (input, name) = take_while1(is_token)(input)?;
-    let (input, _) = char(':')(input)?;
-    let (input, value) = many1(message_header_value)(input)?;
+  do_parse!(input,
+    name:   take_while1!(is_token)       >>
+            char!(':')                   >>
+    value: many1!(message_header_value)  >>
 
-    Ok((input, Header {
+    ( Header {
         name,
         value,
-    }))
+    } )
+  )
 }
 
 pub fn request(input: &[u8]) -> IResult<&[u8], (Request, Vec<Header>)> {
-    terminated(
-        pair(request_line, many1(message_header)),
-        line_ending
-    )(input)
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn asdf() {
-        let (_, (req, headers)) = request(b"GET / HTTP/1.1
-Host: example.com
-User-Agent: just/testing
-
-").unwrap();
-
-        assert_eq!(req, Request {
-            method: b"GET",
-            uri: b"/",
-            version: b"1.1",
-        });
-        assert_eq!(headers, &[
-            Header {
-                name: b"Host",
-                value: vec![b"example.com"],
-            },
-            Header {
-                name: b"User-Agent",
-                value: vec![b"just/testing"],
-            },
-        ]);
+  terminated!(input,
+    pair!(request_line, many1!(message_header)),
+    line_ending
+  )
+}
+
+
+/*
+pub fn parse(data:&[u8]) -> Option<Vec<(Request, Vec<Header>)>> {
+  let mut buf = &data[..];
+  let mut v = Vec::new();
+  loop {
+    match request(buf) {
+      IResult::Done(b, r) => {
+        buf = b;
+        v.push(r);
+
+        if b.is_empty() {
+
+    //println!("{}", i);
+          break;
+        }
+      },
+      IResult::Error(_e) => return None/*panic!("{:?}", e)*/,
+      IResult::Incomplete(_) => return None/*panic!("Incomplete!")*/,
+    }
+  }
+
+  Some(v)
+}
+
+fn main() {
+    let mut contents: Vec<u8> = Vec::new();
+
+    {
+        use std::io::Read;
+
+        let mut file = File::open(env::args().nth(1).expect("File to read")).ok().expect("Failed to open file");
+
+        let _ = file.read_to_end(&mut contents).unwrap();
     }
+    
+    let mut buf = &contents[..];
+    loop { parse(buf); }
 }
+*/
Index: sniffglue/Cargo.toml
===================================================================
--- sniffglue.orig/Cargo.toml
+++ sniffglue/Cargo.toml
@@ -66,7 +66,7 @@ version = "0.4"
 version = "0.23"
 
 [dependencies.nom]
-version = "7"
+version = "6"
 
 [dependencies.num_cpus]
 version = "1.6"
@@ -75,7 +75,7 @@ version = "1.6"
 version = "0.1.3"
 
 [dependencies.pktparse]
-version = "0.7"
+version = "0.5"
 features = ["serde"]
 
 [dependencies.reduce]
@@ -105,6 +105,6 @@ version = "0.5"
 [dependencies.users]
 version = "0.11"
 [target."cfg(target_os=\"linux\")".dependencies.syscallz]
-version = "0.16"
+version = "0.15"
 [badges.travis-ci]
 repository = "kpcyrd/sniffglue"
