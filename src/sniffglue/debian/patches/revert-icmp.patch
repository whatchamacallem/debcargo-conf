This patch reverts the code changes from https://github.com/kpcyrd/sniffglue/commit/9856ac29d7d1e265d6732f5b4b2ba51602086578
the icmp support depends on a new pktparse which depends on nom 7. 

Related dependency changes are handled in other patches.

Index: sniffglue/README.md
===================================================================
--- sniffglue.orig/README.md
+++ sniffglue/README.md
@@ -86,7 +86,7 @@ Or you can build a Debian package via [c
 - [X] arp
 - [X] tcp
 - [X] udp
-- [X] icmp
+- [ ] icmp
 - [X] http
 - [X] tls
 - [X] dns
Index: sniffglue/src/centrifuge/icmp.rs
===================================================================
--- sniffglue.orig/src/centrifuge/icmp.rs
+++ /dev/null
@@ -1,14 +0,0 @@
-use pktparse::icmp;
-
-use crate::structs::CentrifugeError;
-use crate::structs::icmp::ICMP;
-
-pub fn parse(remaining: &[u8]) -> Result<(icmp::IcmpHeader, ICMP), CentrifugeError> {
-    if let Ok((remaining, icmp_hdr)) = icmp::parse_icmp_header(remaining) {
-        Ok((icmp_hdr, ICMP {
-            data: remaining.to_vec(),
-        }))
-    } else {
-        Err(CentrifugeError::InvalidPacket)
-    }
-}
Index: sniffglue/src/centrifuge/mod.rs
===================================================================
--- sniffglue.orig/src/centrifuge/mod.rs
+++ sniffglue/src/centrifuge/mod.rs
@@ -11,7 +11,6 @@ use crate::link::DataLink;
 pub mod arp;
 pub mod tcp;
 pub mod udp;
-pub mod icmp;
 pub mod cjdns;
 pub mod sll;
 
@@ -104,10 +103,6 @@ pub fn parse_ipv4(data: &[u8]) -> Result
                 Ok((udp_hdr, udp)) => UDP(udp_hdr, udp),
                 Err(_) => Unknown(remaining.to_vec()),
             },
-            IPProtocol::ICMP => match icmp::parse(remaining) {
-                Ok((icmp_hdr, icmp)) => ICMP(icmp_hdr, icmp),
-                Err(_) => Unknown(remaining.to_vec()),
-            },
             _ => {
                 Unknown(remaining.to_vec())
             }
Index: sniffglue/src/fmt.rs
===================================================================
--- sniffglue.orig/src/fmt.rs
+++ sniffglue/src/fmt.rs
@@ -1,12 +1,10 @@
 use std::sync::Arc;
 
 use ansi_term::Color::{self, Yellow, Blue, Green, Red, Purple, Fixed};
-use bstr::ByteSlice;
 use reduce::Reduce;
 use sha2::{Sha512, Digest};
 use std::cmp;
 use std::fmt::Debug;
-use pktparse::icmp::{IcmpHeader, IcmpCode, IcmpData};
 
 use crate::structs::ether;
 use crate::structs::arp;
@@ -16,7 +14,6 @@ use crate::structs::ipv4;
 use crate::structs::ipv6;
 use crate::structs::tcp;
 use crate::structs::udp;
-use crate::structs::icmp;
 use crate::structs::tls;
 use crate::structs::raw::Raw;
 use crate::structs::prelude::*;
@@ -189,7 +186,6 @@ impl Format {
         match next {
             ipv4::IPv4::TCP(tcp_hdr, tcp) => Some(self.format_compact_ip_tcp(out, ip_hdr, &tcp_hdr, tcp)),
             ipv4::IPv4::UDP(udp_hdr, udp) => Some(self.format_compact_ip_udp(out, ip_hdr, udp_hdr, udp)),
-            ipv4::IPv4::ICMP(icmp_hdr, icmp) => Some(self.format_compact_ip_icmp(out, ip_hdr, icmp_hdr, icmp)),
             ipv4::IPv4::Unknown(data) => self.format_compact_ip_unknown(out, ip_hdr, &data),
         }
     }
@@ -383,49 +379,6 @@ impl Format {
         }
     }
 
-    fn format_compact_ip_icmp<IP: IPHeader>(&self, out: &mut String, ip_hdr: &IP, icmp_hdr: IcmpHeader, icmp: icmp::ICMP) -> Color {
-        let code = match icmp_hdr.code {
-            IcmpCode::EchoReply => Some("icmp/pong"),
-            /*
-            IcmpCode::Reserved,
-            */
-            IcmpCode::DestinationUnreachable(_) => Some("icmp/unrch"),
-            /*
-            IcmpCode::DestinationUnreachable(Unreachable),
-            IcmpCode::SourceQuench,
-            IcmpCode::Redirect(Redirect),
-            */
-            IcmpCode::EchoRequest => Some("icmp/ping"),
-            /*
-            IcmpCode::RouterAdvertisment,
-            IcmpCode::RouterSolicication,
-            */
-            IcmpCode::TimeExceeded(_) => Some("icmp/ttl"),
-            /*
-            IcmpCode::ParameterProblem(ParameterProblem),
-            IcmpCode::Timestamp,
-            IcmpCode::TimestampReply,
-            IcmpCode::ExtendedEchoRequest,
-            IcmpCode::ExtendedEchoReply(ExtendedEchoReply),
-            IcmpCode::Other(u16)
-            */
-            _ => None,
-        };
-        out.push_str(&format!("[{:10}] {:18} -> {:22} [code={:?}",
-                        code.unwrap_or("icmp"),
-                        ip_hdr.source_addr(),
-                        ip_hdr.dest_addr(),
-                        icmp_hdr.code));
-
-        if icmp_hdr.data != IcmpData::None {
-            out.push_str(&format!(", data={:?}", icmp_hdr.data));
-        }
-
-        out.push_str(&format!("] {:?}", icmp.data.as_bstr()));
-
-        Blue
-    }
-
     #[inline]
     fn print_debugging(&self, packet: Raw) {
         use crate::structs::raw::Raw::Unknown;
@@ -456,11 +409,6 @@ impl Format {
                 println!("{}udp: {:?}",  "\t".repeat(indent+1), udp_hdr);
                 println!("{}{}",         "\t".repeat(indent+2), self.print_debugging_udp(udp));
             },
-            IPv4(ip_hdr, ipv4::IPv4::ICMP(icmp_hdr, icmp)) => {
-                println!("{}ipv4: {:?}", "\t".repeat(indent), ip_hdr);
-                println!("{}icmp: {:?}",  "\t".repeat(indent+1), icmp_hdr);
-                println!("{}{:?}",         "\t".repeat(indent+2), icmp.data);
-            },
             IPv4(ip_hdr, ipv4::IPv4::Unknown(data)) => {
                 println!("{}ipv4: {:?}",     "\t".repeat(indent), ip_hdr);
                 println!("{}unknown: {:?}",  "\t".repeat(indent+1), data);
Index: sniffglue/src/structs/icmp.rs
===================================================================
--- sniffglue.orig/src/structs/icmp.rs
+++ /dev/null
@@ -1,36 +0,0 @@
-use crate::structs::NoiseLevel;
-use pktparse::icmp::{IcmpHeader, IcmpCode};
-use serde::Serialize;
-
-#[derive(Debug, PartialEq, Serialize)]
-pub struct ICMP {
-    pub data: Vec<u8>,
-}
-
-impl ICMP {
-    pub fn noise_level(&self, header: &IcmpHeader) -> NoiseLevel {
-        match header.code {
-            IcmpCode::EchoReply => NoiseLevel::One,
-            /*
-            IcmpCode::Reserved,
-            IcmpCode::DestinationUnreachable(_) =>
-            IcmpCode::DestinationUnreachable(Unreachable),
-            IcmpCode::SourceQuench,
-            IcmpCode::Redirect(Redirect),
-            */
-            IcmpCode::EchoRequest => NoiseLevel::One,
-            /*
-            IcmpCode::RouterAdvertisment,
-            IcmpCode::RouterSolicication,
-            IcmpCode::TimeExceeded(_) => NoiseLevel::One,
-            IcmpCode::ParameterProblem(ParameterProblem),
-            IcmpCode::Timestamp,
-            IcmpCode::TimestampReply,
-            IcmpCode::ExtendedEchoRequest,
-            IcmpCode::ExtendedEchoReply(ExtendedEchoReply),
-            IcmpCode::Other(u16)
-            */
-            _ => NoiseLevel::Two,
-        }
-    }
-}
Index: sniffglue/src/structs/ipv4.rs
===================================================================
--- sniffglue.orig/src/structs/ipv4.rs
+++ sniffglue/src/structs/ipv4.rs
@@ -1,4 +1,5 @@
-use crate::structs::{tcp, udp, icmp};
+use crate::structs::tcp;
+use crate::structs::udp;
 use crate::structs::NoiseLevel;
 use serde::Serialize;
 
@@ -6,7 +7,6 @@ use serde::Serialize;
 pub enum IPv4 {
     TCP(pktparse::tcp::TcpHeader, tcp::TCP),
     UDP(pktparse::udp::UdpHeader, udp::UDP),
-    ICMP(pktparse::icmp::IcmpHeader, icmp::ICMP),
     Unknown(Vec<u8>),
 }
 
@@ -16,7 +16,6 @@ impl IPv4 {
         match *self {
             TCP(ref header, ref tcp) => tcp.noise_level(header),
             UDP(_, ref udp) => udp.noise_level(),
-            ICMP(ref header, ref icmp) => icmp.noise_level(header),
             Unknown(_) => NoiseLevel::Maximum,
         }
     }
Index: sniffglue/src/structs/mod.rs
===================================================================
--- sniffglue.orig/src/structs/mod.rs
+++ sniffglue/src/structs/mod.rs
@@ -36,7 +36,6 @@ pub mod raw;
 pub mod ether;
 pub mod arp;
 pub mod cjdns;
-pub mod icmp;
 pub mod ipv4;
 pub mod ipv6;
 pub mod ip;
