Always enable cc even if the feature is not enabled.

Some Debian architectures need outline asm, and Debian does not ship pre-built
outline asm.

Index: rustix/Cargo.toml
===================================================================
--- rustix.orig/Cargo.toml
+++ rustix/Cargo.toml
@@ -110,9 +110,9 @@ version = "2.0.0"
 [dev-dependencies.tempfile]
 version = "3.5.0"
 
-[build-dependencies.cc]
+[build-dependencies.cc_dep]
 version = "1.0.68"
-optional = true
+package = "cc"
 
 [features]
 all-apis = [
@@ -173,6 +173,7 @@ rustc-dep-of-std = [
     "linux-raw-sys/rustc-dep-of-std",
     "bitflags/rustc-dep-of-std",
 ]
+cc = []
 std = ["bitflags/std"]
 stdio = []
 system = ["linux-raw-sys/system"]
Index: rustix/build.rs
===================================================================
--- rustix.orig/build.rs
+++ rustix/build.rs
@@ -1,5 +1,4 @@
-#[cfg(feature = "cc")]
-use cc::Build;
+use cc_dep::Build;
 use std::env::var;
 use std::io::Write;
 
@@ -165,16 +164,16 @@ fn link_in_librustix_outline(arch: &str,
     println!("cargo:rerun-if-changed={}", to);
 
     // If "cc" is not enabled, use a pre-built library.
-    #[cfg(not(feature = "cc"))]
+    /*#[cfg(not(feature = "cc"))]
     {
         let _ = asm_name;
         println!("cargo:rustc-link-search={}/{}", OUTLINE_PATH, profile);
         println!("cargo:rustc-link-lib=static={}", name);
-    }
+    }*/
 
     // If "cc" is enabled, build the library from source, update the pre-built
     // version, and assert that the pre-built version is checked in.
-    #[cfg(feature = "cc")]
+    //#[cfg(feature = "cc")]
     {
         let out_dir = var("OUT_DIR").unwrap();
         // Add `-gdwarf-3` so that we always get the same output, regardless of
