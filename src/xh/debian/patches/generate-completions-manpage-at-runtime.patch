Description: Cherry-pick upstream commit for runtime --generate option
 adapted to Debian packaging: generation for nushell is removed, updates to
 pre-generated completions and man page are removed (they are not used).
Origin: https://github.com/ducaale/xh/commit/196ca1f162a4f1c27ecaf4e6ca79631ffa0a1ee6
Last-Update: 2025-01-11
---
From 196ca1f162a4f1c27ecaf4e6ca79631ffa0a1ee6 Mon Sep 17 00:00:00 2001
From: Fotis Gimian <fgimiansoftware@gmail.com>
Date: Mon, 6 Jan 2025 23:24:36 +1100
Subject: [PATCH] Switch to generating completions at runtime (#393)

* Allow for completion and man page generation at runtime and support for Elvish and Nshull

* Refine runtime generation based on feedback provided

diff --git a/CHANGELOG.md b/CHANGELOG.md
index d184942c..47ded2c8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
+## Unreleased
+### Features
+- Add `--generate` option to generate the man page and shell completions at runtime
+- Add support for Elvish and Nushell shell completions
+
 ## [0.23.1] - 2025-01-02
 ### Security fixes
 - Upgrade to ruzstd v0.7.3 to fix RUSTSEC-2024-0400, see #396 (@zuisong)
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -110,7 +110,7 @@
 
 [dependencies.clap_complete]
 version = "4.4"
-optional = true
+#optional = true
 
 [dependencies.cookie_store]
 version = "0.21"
@@ -192,7 +192,7 @@
 
 [dependencies.roff]
 version = "0.2.1"
-optional = true
+#optional = true
 
 [dependencies.rpassword]
 version = "7.2.0"
@@ -300,7 +300,6 @@
 
 [features]
 default = [
-    "man-completion-gen",
     #"online-tests",
     "rustls",
     #"network-interface",
@@ -309,4 +308,0 @@
-man-completion-gen = [
-    "clap_complete",
-    "roff",
-]
diff --git a/RELEASE-CHECKLIST.md b/RELEASE-CHECKLIST.md
index d8b215e8..fcb00308 100644
--- a/RELEASE-CHECKLIST.md
+++ b/RELEASE-CHECKLIST.md
@@ -4,9 +4,15 @@
 - Update `CHANGELOG.md` (rename unreleased header to the current date, add any missing changes).
 - Run `cargo update` to update dependencies.
 - Bump up the version in `Cargo.toml` and run `cargo check` to update `Cargo.lock`.
-- Run the following to update man pages and shell-completion files.
+- Run the following to update shell-completion files and man pages.
   ```sh
-  cargo run --all-features -- generate-completions completions && cargo run --all-features -- generate-manpages doc
+  cargo run --all-features -- --generate complete-bash > completions/xh.bash
+  cargo run --all-features -- --generate complete-elvish > completions/xh.elv
+  cargo run --all-features -- --generate complete-fish > completions/xh.fish
+  cargo run --all-features -- --generate complete-nushell > completions/xh.nu
+  cargo run --all-features -- --generate complete-powershell > completions/_xh.ps1
+  cargo run --all-features -- --generate complete-zsh > completions/_xh
+  cargo run --all-features -- --generate man > doc/xh.1
   ```
 - Commit changes and push them to remote.
 - Add git tag e.g `git tag v0.9.0`.
diff --git a/src/cli.rs b/src/cli.rs
index a6b37d59..8d227a18 100644
--- a/src/cli.rs
+++ b/src/cli.rs
@@ -367,6 +367,27 @@ Example: --print=Hb"
     #[clap(long)]
     pub curl_long: bool,
 
+    /// Generate shell completions or man pages.
+    #[arg(
+        long,
+        value_name = "KIND",
+        hide_possible_values = true,
+        long_help = "\
+Generate shell completions or man pages. Possible values are:
+
+    complete-bash
+    complete-elvish
+    complete-fish
+    //complete-nushell (Debian: not packaged)
+    complete-powershell
+    complete-zsh
+    man
+
+Example: xh --generate=complete-bash > xh.bash",
+        conflicts_with = "raw_method_or_url"
+    )]
+    pub generate: Option<Generate>,
+
     /// Print help.
     #[clap(long, action = ArgAction::HelpShort)]
     pub help: Option<bool>,
@@ -381,8 +402,8 @@ Example: --print=Hb"
     ///
     /// A leading colon works as shorthand for localhost. ":8000" is equivalent
     /// to "localhost:8000", and ":/path" is equivalent to "localhost/path".
-    #[clap(value_name = "[METHOD] URL")]
-    raw_method_or_url: String,
+    #[clap(value_name = "[METHOD] URL", required = true)]
+    raw_method_or_url: Option<String>,
 
     /// Optional key-value pairs to be included in the request.
     ///
@@ -480,21 +501,28 @@ impl Cli {
         let matches = app.try_get_matches_from_mut(iter)?;
         let mut cli = Self::from_arg_matches(&matches)?;
 
-        match cli.raw_method_or_url.as_str() {
-            "help" => {
-                // opt-out of clap's auto-generated possible values help for --pretty
-                // as we already list them in the long_help
-                app = app.mut_arg("pretty", |a| a.hide_possible_values(true));
+        app.get_bin_name()
+            .and_then(|name| name.split('.').next())
+            .unwrap_or("xh")
+            .clone_into(&mut cli.bin_name);
 
-                app.print_long_help().unwrap();
-                safe_exit();
-            }
-            "generate-completions" => return Err(generate_completions(app, cli.raw_rest_args)),
-            "generate-manpages" => return Err(generate_manpages(app, cli.raw_rest_args)),
-            _ => {}
+        if cli.generate.is_some() {
+            return Ok(cli);
         }
+
+        let mut raw_method_or_url = cli.raw_method_or_url.clone().unwrap();
+
+        if raw_method_or_url == "help" {
+            // opt-out of clap's auto-generated possible values help for --pretty
+            // as we already list them in the long_help
+            app = app.mut_arg("pretty", |a| a.hide_possible_values(true));
+
+            app.print_long_help().unwrap();
+            safe_exit();
+        }
+
         let mut rest_args = mem::take(&mut cli.raw_rest_args).into_iter();
-        let raw_url = match parse_method(&cli.raw_method_or_url) {
+        let raw_url = match parse_method(&raw_method_or_url) {
             Some(method) => {
                 cli.method = Some(method);
                 rest_args.next().ok_or_else(|| {
@@ -506,7 +534,7 @@ impl Cli {
             }
             None => {
                 cli.method = None;
-                mem::take(&mut cli.raw_method_or_url)
+                mem::take(&mut raw_method_or_url)
             }
         };
         for request_item in rest_args {
@@ -517,11 +545,6 @@ impl Cli {
             );
         }
 
-        app.get_bin_name()
-            .and_then(|name| name.split('.').next())
-            .unwrap_or("xh")
-            .clone_into(&mut cli.bin_name);
-
         if matches!(cli.bin_name.as_str(), "https" | "xhs" | "xhttps") {
             cli.https = true;
         }
@@ -625,9 +648,12 @@ impl Cli {
             })
             .collect();
 
-        app.args(negations)
+        let mut app = app.args(negations)
             .after_help(format!("Each option can be reset with a --no-OPTION argument.\n\nRun \"{} help\" for more complete documentation.", env!("CARGO_PKG_NAME")))
-            .after_long_help("Each option can be reset with a --no-OPTION argument.")
+            .after_long_help("Each option can be reset with a --no-OPTION argument.");
+
+        app.build();
+        app
     }
 
     pub fn logger_config(&self) -> env_logger::Builder {
@@ -744,209 +770,6 @@ fn construct_url(
     Ok(url)
 }
 
-#[cfg(feature = "man-completion-gen")]
-// This signature is a little weird: we either return an error or don't return at all
-fn generate_completions(mut app: clap::Command, rest_args: Vec<String>) -> clap::error::Error {
-    let bin_name = app.get_bin_name().unwrap().to_string();
-    if rest_args.len() != 1 {
-        return app.error(
-            clap::error::ErrorKind::WrongNumberOfValues,
-            "Usage: xh generate-completions <DIRECTORY>",
-        );
-    }
-
-    for &shell in clap_complete::Shell::value_variants() {
-        // Elvish complains about multiple deprecations and these don't seem to work
-        if shell != clap_complete::Shell::Elvish {
-            clap_complete::generate_to(shell, &mut app, &bin_name, &rest_args[0]).unwrap();
-        }
-    }
-    safe_exit();
-}
-
-#[cfg(feature = "man-completion-gen")]
-fn generate_manpages(mut app: clap::Command, rest_args: Vec<String>) -> clap::error::Error {
-    use roff::{bold, italic, roman, Roff};
-    use time::OffsetDateTime as DateTime;
-
-    if rest_args.len() != 1 {
-        return app.error(
-            clap::error::ErrorKind::WrongNumberOfValues,
-            "Usage: xh generate-manpages <DIRECTORY>",
-        );
-    }
-
-    let items: Vec<_> = app.get_arguments().filter(|i| !i.is_hide_set()).collect();
-
-    let mut request_items_roff = Roff::new();
-    let request_items = items
-        .iter()
-        .find(|opt| opt.get_id() == "raw_rest_args")
-        .unwrap();
-    let request_items_help = request_items
-        .get_long_help()
-        .or_else(|| request_items.get_help())
-        .expect("request_items is missing help")
-        .to_string();
-
-    // replace the indents in request_item help with proper roff controls
-    // For example:
-    //
-    // ```
-    // normal help normal help
-    // normal help normal help
-    //
-    //   request-item-1
-    //     help help
-    //
-    //   request-item-2
-    //     help help
-    //
-    // normal help normal help
-    // ```
-    //
-    // Should look like this with roff controls
-    //
-    // ```
-    // normal help normal help
-    // normal help normal help
-    // .RS 12
-    // .TP
-    // request-item-1
-    // help help
-    // .TP
-    // request-item-2
-    // help help
-    // .RE
-    //
-    // .RS
-    // normal help normal help
-    // .RE
-    // ```
-    let lines: Vec<&str> = request_items_help.lines().collect();
-    let mut rs = false;
-    for i in 0..lines.len() {
-        if lines[i].is_empty() {
-            let prev = lines[i - 1].chars().take_while(|&x| x == ' ').count();
-            let next = lines[i + 1].chars().take_while(|&x| x == ' ').count();
-            if prev != next && next > 0 {
-                if !rs {
-                    request_items_roff.control("RS", ["8"]);
-                    rs = true;
-                }
-                request_items_roff.control("TP", ["4"]);
-            } else if prev != next && next == 0 {
-                request_items_roff.control("RE", []);
-                request_items_roff.text(vec![roman("")]);
-                request_items_roff.control("RS", []);
-            } else {
-                request_items_roff.text(vec![roman(lines[i])]);
-            }
-        } else {
-            request_items_roff.text(vec![roman(lines[i].trim())]);
-        }
-    }
-    request_items_roff.control("RE", []);
-
-    let mut options_roff = Roff::new();
-    let non_pos_items = items
-        .iter()
-        .filter(|a| !a.is_positional())
-        .collect::<Vec<_>>();
-
-    for opt in non_pos_items {
-        let mut header = vec![];
-        if let Some(short) = opt.get_short() {
-            header.push(bold(format!("-{}", short)));
-        }
-        if let Some(long) = opt.get_long() {
-            if !header.is_empty() {
-                header.push(roman(", "));
-            }
-            header.push(bold(format!("--{}", long)));
-        }
-        if opt.get_action().takes_values() {
-            let value_name = &opt.get_value_names().unwrap();
-            if opt.get_long().is_some() {
-                header.push(roman("="));
-            } else {
-                header.push(roman(" "));
-            }
-
-            if opt.get_id() == "auth" {
-                header.push(italic("USER"));
-                header.push(roman("["));
-                header.push(italic(":PASS"));
-                header.push(roman("] | "));
-                header.push(italic("TOKEN"));
-            } else {
-                header.push(italic(value_name.join(" ")));
-            }
-        }
-        let mut body = vec![];
-
-        let mut help = opt
-            .get_long_help()
-            .or_else(|| opt.get_help())
-            .expect("option is missing help")
-            .to_string();
-        if !help.ends_with('.') {
-            help.push('.')
-        }
-        body.push(roman(help));
-
-        let possible_values = opt.get_possible_values();
-        if !possible_values.is_empty()
-            && !opt.is_hide_possible_values_set()
-            && opt.get_id() != "pretty"
-        {
-            let possible_values_text = format!(
-                "\n\n[possible values: {}]",
-                possible_values
-                    .iter()
-                    .map(|v| v.get_name())
-                    .collect::<Vec<_>>()
-                    .join(", ")
-            );
-            body.push(roman(possible_values_text));
-        }
-        options_roff.control("TP", ["4"]);
-        options_roff.text(header);
-        options_roff.text(body);
-    }
-
-    let mut manpage = fs::read_to_string(format!("{}/man-template.roff", rest_args[0])).unwrap();
-
-    let current_date = {
-        let (year, month, day) = DateTime::now_utc().date().to_calendar_date();
-        format!("{}-{:02}-{:02}", year, u8::from(month), day)
-    };
-
-    manpage = manpage.replace("{{date}}", &current_date);
-    manpage = manpage.replace("{{version}}", app.get_version().unwrap());
-    manpage = manpage.replace("{{request_items}}", request_items_roff.to_roff().trim());
-    manpage = manpage.replace("{{options}}", options_roff.to_roff().trim());
-
-    fs::write(format!("{}/xh.1", rest_args[0]), manpage).unwrap();
-    safe_exit();
-}
-
-#[cfg(not(feature = "man-completion-gen"))]
-fn generate_completions(mut _app: clap::Command, _rest_args: Vec<String>) -> clap::error::Error {
-    clap::Error::raw(
-        clap::error::ErrorKind::InvalidSubcommand,
-        "generate-completions requires enabling man-completion-gen feature\n",
-    )
-}
-
-#[cfg(not(feature = "man-completion-gen"))]
-fn generate_manpages(mut _app: clap::Command, _rest_args: Vec<String>) -> clap::error::Error {
-    clap::Error::raw(
-        clap::error::ErrorKind::InvalidSubcommand,
-        "generate-manpages requires enabling man-completion-gen feature\n",
-    )
-}
-
 #[derive(Default, ValueEnum, Copy, Clone, Debug, PartialEq, Eq)]
 pub enum AuthType {
     #[default]
@@ -1353,6 +1176,17 @@ pub enum HttpVersion {
     Http2PriorKnowledge,
 }
 
+#[derive(ValueEnum, Copy, Clone, Debug, PartialEq, Eq)]
+pub enum Generate {
+    CompleteBash,
+    CompleteElvish,
+    CompleteFish,
+    //CompleteNushell,
+    CompletePowershell,
+    CompleteZsh,
+    Man,
+}
+
 /// HTTPie uses Python's str.decode(). That one's very accepting of different spellings.
 /// encoding_rs is not.
 ///
@@ -1870,4 +1704,16 @@ mod tests {
         assert!(Resolve::from_str("example.com:::1").is_ok());
         assert!(Resolve::from_str("example.com:[::1]").is_ok());
     }
+
+    #[test]
+    fn generate() {
+        let cli = parse(["--generate", "complete-bash"]).unwrap();
+        assert_eq!(cli.generate, Some(Generate::CompleteBash));
+        assert_eq!(cli.raw_method_or_url, None);
+    }
+
+    #[test]
+    fn generate_with_url() {
+        parse(["--generate", "complete-zsh", "example.org"]).unwrap_err();
+    }
 }
diff --git a/src/generation.rs b/src/generation.rs
new file mode 100644
index 00000000..317306b0
--- /dev/null
+++ b/src/generation.rs
@@ -0,0 +1,195 @@
+use std::io;
+
+use clap_complete::Shell;
+//use clap_complete_nushell::Nushell;
+
+use crate::cli::Cli;
+use crate::cli::Generate;
+
+const MAN_TEMPLATE: &str = include_str!("../doc/man-template.roff");
+
+pub fn generate(bin_name: &str, generate: Generate) {
+    let mut app = Cli::into_app();
+
+    match generate {
+        Generate::CompleteBash => {
+            clap_complete::generate(Shell::Bash, &mut app, bin_name, &mut io::stdout());
+        }
+        Generate::CompleteElvish => {
+            clap_complete::generate(Shell::Elvish, &mut app, bin_name, &mut io::stdout());
+        }
+        Generate::CompleteFish => {
+            clap_complete::generate(Shell::Fish, &mut app, bin_name, &mut io::stdout());
+        }
+        /*Generate::CompleteNushell => {
+            clap_complete::generate(Nushell, &mut app, bin_name, &mut io::stdout());
+        }*/
+        Generate::CompletePowershell => {
+            clap_complete::generate(Shell::PowerShell, &mut app, bin_name, &mut io::stdout());
+        }
+        Generate::CompleteZsh => {
+            clap_complete::generate(Shell::Zsh, &mut app, bin_name, &mut io::stdout());
+        }
+        Generate::Man => {
+            generate_manpages(&mut app);
+        }
+    }
+}
+
+fn generate_manpages(app: &mut clap::Command) {
+    use roff::{bold, italic, roman, Roff};
+    use time::OffsetDateTime as DateTime;
+
+    let items: Vec<_> = app.get_arguments().filter(|i| !i.is_hide_set()).collect();
+
+    let mut request_items_roff = Roff::new();
+    let request_items = items
+        .iter()
+        .find(|opt| opt.get_id() == "raw_rest_args")
+        .unwrap();
+    let request_items_help = request_items
+        .get_long_help()
+        .or_else(|| request_items.get_help())
+        .expect("request_items is missing help")
+        .to_string();
+
+    // replace the indents in request_item help with proper roff controls
+    // For example:
+    //
+    // ```
+    // normal help normal help
+    // normal help normal help
+    //
+    //   request-item-1
+    //     help help
+    //
+    //   request-item-2
+    //     help help
+    //
+    // normal help normal help
+    // ```
+    //
+    // Should look like this with roff controls
+    //
+    // ```
+    // normal help normal help
+    // normal help normal help
+    // .RS 12
+    // .TP
+    // request-item-1
+    // help help
+    // .TP
+    // request-item-2
+    // help help
+    // .RE
+    //
+    // .RS
+    // normal help normal help
+    // .RE
+    // ```
+    let lines: Vec<&str> = request_items_help.lines().collect();
+    let mut rs = false;
+    for i in 0..lines.len() {
+        if lines[i].is_empty() {
+            let prev = lines[i - 1].chars().take_while(|&x| x == ' ').count();
+            let next = lines[i + 1].chars().take_while(|&x| x == ' ').count();
+            if prev != next && next > 0 {
+                if !rs {
+                    request_items_roff.control("RS", ["8"]);
+                    rs = true;
+                }
+                request_items_roff.control("TP", ["4"]);
+            } else if prev != next && next == 0 {
+                request_items_roff.control("RE", []);
+                request_items_roff.text(vec![roman("")]);
+                request_items_roff.control("RS", []);
+            } else {
+                request_items_roff.text(vec![roman(lines[i])]);
+            }
+        } else {
+            request_items_roff.text(vec![roman(lines[i].trim())]);
+        }
+    }
+    request_items_roff.control("RE", []);
+
+    let mut options_roff = Roff::new();
+    let non_pos_items = items
+        .iter()
+        .filter(|a| !a.is_positional())
+        .collect::<Vec<_>>();
+
+    for opt in non_pos_items {
+        let mut header = vec![];
+        if let Some(short) = opt.get_short() {
+            header.push(bold(format!("-{}", short)));
+        }
+        if let Some(long) = opt.get_long() {
+            if !header.is_empty() {
+                header.push(roman(", "));
+            }
+            header.push(bold(format!("--{}", long)));
+        }
+        if opt.get_action().takes_values() {
+            let value_name = &opt.get_value_names().unwrap();
+            if opt.get_long().is_some() {
+                header.push(roman("="));
+            } else {
+                header.push(roman(" "));
+            }
+
+            if opt.get_id() == "auth" {
+                header.push(italic("USER"));
+                header.push(roman("["));
+                header.push(italic(":PASS"));
+                header.push(roman("] | "));
+                header.push(italic("TOKEN"));
+            } else {
+                header.push(italic(value_name.join(" ")));
+            }
+        }
+        let mut body = vec![];
+
+        let mut help = opt
+            .get_long_help()
+            .or_else(|| opt.get_help())
+            .expect("option is missing help")
+            .to_string();
+        if !help.ends_with('.') {
+            help.push('.')
+        }
+        body.push(roman(help));
+
+        let possible_values = opt.get_possible_values();
+        if !possible_values.is_empty()
+            && !opt.is_hide_possible_values_set()
+            && opt.get_id() != "pretty"
+        {
+            let possible_values_text = format!(
+                "\n\n[possible values: {}]",
+                possible_values
+                    .iter()
+                    .map(|v| v.get_name())
+                    .collect::<Vec<_>>()
+                    .join(", ")
+            );
+            body.push(roman(possible_values_text));
+        }
+        options_roff.control("TP", ["4"]);
+        options_roff.text(header);
+        options_roff.text(body);
+    }
+
+    let mut manpage = MAN_TEMPLATE.to_string();
+
+    let current_date = {
+        let (year, month, day) = DateTime::now_utc().date().to_calendar_date();
+        format!("{}-{:02}-{:02}", year, u8::from(month), day)
+    };
+
+    manpage = manpage.replace("{{date}}", &current_date);
+    manpage = manpage.replace("{{version}}", app.get_version().unwrap());
+    manpage = manpage.replace("{{request_items}}", request_items_roff.to_roff().trim());
+    manpage = manpage.replace("{{options}}", options_roff.to_roff().trim());
+
+    print!("{manpage}");
+}
diff --git a/src/main.rs b/src/main.rs
index 006a5ee3..c8f95cf3 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,6 +5,7 @@ mod cli;
 mod decoder;
 mod download;
 mod formatting;
+mod generation;
 mod middleware;
 mod nested_json;
 mod netrc;
@@ -101,6 +102,11 @@ fn main() {
 }
 
 fn run(args: Cli) -> Result<i32> {
+    if let Some(generate) = args.generate {
+        generation::generate(&args.bin_name, generate);
+        return Ok(0);
+    }
+
     if args.curl {
         to_curl::print_curl_translation(args)?;
         return Ok(0);
