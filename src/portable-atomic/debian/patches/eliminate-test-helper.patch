Index: rust-portable-atomic-1.9.0/src/tests/helper.rs
===================================================================
--- rust-portable-atomic-1.9.0.orig/src/tests/helper.rs
+++ rust-portable-atomic-1.9.0/src/tests/helper.rs
@@ -4,6 +4,28 @@
 
 use core::sync::atomic::Ordering;
 
+pub(crate) const LOAD_ORDERINGS: [Ordering; 3] = [Ordering::Relaxed, Ordering::Acquire, Ordering::SeqCst];
+pub(crate) const STORE_ORDERINGS: [Ordering; 3] = [Ordering::Relaxed, Ordering::Release, Ordering::SeqCst];
+pub(crate) const SWAP_ORDERINGS: [Ordering; 5] =
+    [Ordering::Relaxed, Ordering::Release, Ordering::Acquire, Ordering::AcqRel, Ordering::SeqCst];
+pub(crate) const COMPARE_EXCHANGE_ORDERINGS: [(Ordering, Ordering); 15] = [
+    (Ordering::Relaxed, Ordering::Relaxed),
+    (Ordering::Relaxed, Ordering::Acquire),
+    (Ordering::Relaxed, Ordering::SeqCst),
+    (Ordering::Acquire, Ordering::Relaxed),
+    (Ordering::Acquire, Ordering::Acquire),
+    (Ordering::Acquire, Ordering::SeqCst),
+    (Ordering::Release, Ordering::Relaxed),
+    (Ordering::Release, Ordering::Acquire),
+    (Ordering::Release, Ordering::SeqCst),
+    (Ordering::AcqRel, Ordering::Relaxed),
+    (Ordering::AcqRel, Ordering::Acquire),
+    (Ordering::AcqRel, Ordering::SeqCst),
+    (Ordering::SeqCst, Ordering::Relaxed),
+    (Ordering::SeqCst, Ordering::Acquire),
+    (Ordering::SeqCst, Ordering::SeqCst),
+];
+
 macro_rules! __test_atomic_common {
     ($atomic_type:ty, $value_type:ty) => {
         #[test]
@@ -61,7 +83,7 @@ macro_rules! __test_atomic_int_load_stor
         #[test]
         fn static_load_only() {
             static VAR: $atomic_type = <$atomic_type>::new(10);
-            for &order in &test_helper::LOAD_ORDERINGS {
+            for &order in &LOAD_ORDERINGS {
                 assert_eq!(VAR.load(order), 10);
             }
         }
@@ -71,7 +93,7 @@ macro_rules! __test_atomic_int_load_stor
             test_load_ordering(|order| VAR.load(order));
             test_store_ordering(|order| VAR.store(10, order));
             for (&load_order, &store_order) in
-                test_helper::LOAD_ORDERINGS.iter().zip(&test_helper::STORE_ORDERINGS)
+                LOAD_ORDERINGS.iter().zip(&STORE_ORDERINGS)
             {
                 assert_eq!(VAR.load(load_order), 10);
                 VAR.store(5, store_order);
@@ -137,7 +159,7 @@ macro_rules! __test_atomic_float_load_st
         #[test]
         fn static_load_only() {
             static VAR: $atomic_type = <$atomic_type>::new(10.);
-            for &order in &test_helper::LOAD_ORDERINGS {
+            for &order in &LOAD_ORDERINGS {
                 assert_eq!(VAR.load(order), 10.);
             }
         }
@@ -147,7 +169,7 @@ macro_rules! __test_atomic_float_load_st
             test_load_ordering(|order| VAR.load(order));
             test_store_ordering(|order| VAR.store(10., order));
             for (&load_order, &store_order) in
-                test_helper::LOAD_ORDERINGS.iter().zip(&test_helper::STORE_ORDERINGS)
+                LOAD_ORDERINGS.iter().zip(&STORE_ORDERINGS)
             {
                 assert_eq!(VAR.load(load_order), 10.);
                 VAR.store(5., store_order);
@@ -181,7 +203,7 @@ macro_rules! __test_atomic_bool_load_sto
         #[test]
         fn static_load_only() {
             static VAR: $atomic_type = <$atomic_type>::new(false);
-            for &order in &test_helper::LOAD_ORDERINGS {
+            for &order in &LOAD_ORDERINGS {
                 assert_eq!(VAR.load(order), false);
             }
         }
@@ -191,7 +213,7 @@ macro_rules! __test_atomic_bool_load_sto
             test_load_ordering(|order| VAR.load(order));
             test_store_ordering(|order| VAR.store(false, order));
             for (&load_order, &store_order) in
-                test_helper::LOAD_ORDERINGS.iter().zip(&test_helper::STORE_ORDERINGS)
+                LOAD_ORDERINGS.iter().zip(&STORE_ORDERINGS)
             {
                 assert_eq!(VAR.load(load_order), false);
                 VAR.store(true, store_order);
@@ -227,7 +249,7 @@ macro_rules! __test_atomic_ptr_load_stor
         #[test]
         fn static_load_only() {
             static VAR: $atomic_type = <$atomic_type>::new(ptr::null_mut());
-            for &order in &test_helper::LOAD_ORDERINGS {
+            for &order in &LOAD_ORDERINGS {
                 assert_eq!(VAR.load(order), ptr::null_mut());
             }
         }
@@ -239,7 +261,7 @@ macro_rules! __test_atomic_ptr_load_stor
             let mut v = 1_u8;
             let p = &mut v as *mut u8;
             for (&load_order, &store_order) in
-                test_helper::LOAD_ORDERINGS.iter().zip(&test_helper::STORE_ORDERINGS)
+                LOAD_ORDERINGS.iter().zip(&STORE_ORDERINGS)
             {
                 assert_eq!(VAR.load(load_order), ptr::null_mut());
                 VAR.store(p, store_order);
@@ -264,7 +286,7 @@ macro_rules! __test_atomic_int {
         fn swap() {
             let a = <$atomic_type>::new(5);
             test_swap_ordering(|order| a.swap(5, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 assert_eq!(a.swap(10, order), 5);
                 assert_eq!(a.swap(5, order), 10);
             }
@@ -275,7 +297,7 @@ macro_rules! __test_atomic_int {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange(5, 5, success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(5);
                 assert_eq!(a.compare_exchange(5, 10, success, failure), Ok(5));
                 assert_eq!(a.load(Ordering::Relaxed), 10);
@@ -289,7 +311,7 @@ macro_rules! __test_atomic_int {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange_weak(4, 4, success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(4);
                 assert_eq!(a.compare_exchange_weak(6, 8, success, failure), Err(4));
                 let mut old = a.load(Ordering::Relaxed);
@@ -307,7 +329,7 @@ macro_rules! __test_atomic_int {
         fn fetch_add() {
             let a = <$atomic_type>::new(0);
             test_swap_ordering(|order| a.fetch_add(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0);
                 assert_eq!(a.fetch_add(10, order), 0);
                 assert_eq!(a.load(Ordering::Relaxed), 10);
@@ -320,7 +342,7 @@ macro_rules! __test_atomic_int {
         fn add() {
             let a = <$atomic_type>::new(0);
             test_swap_ordering(|order| a.add(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0);
                 a.add(10, order);
                 assert_eq!(a.load(Ordering::Relaxed), 10);
@@ -333,7 +355,7 @@ macro_rules! __test_atomic_int {
         fn fetch_sub() {
             let a = <$atomic_type>::new(20);
             test_swap_ordering(|order| a.fetch_sub(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(20);
                 assert_eq!(a.fetch_sub(10, order), 20);
                 assert_eq!(a.load(Ordering::Relaxed), 10);
@@ -346,7 +368,7 @@ macro_rules! __test_atomic_int {
         fn sub() {
             let a = <$atomic_type>::new(20);
             test_swap_ordering(|order| a.sub(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(20);
                 a.sub(10, order);
                 assert_eq!(a.load(Ordering::Relaxed), 10);
@@ -359,7 +381,7 @@ macro_rules! __test_atomic_int {
         fn fetch_and() {
             let a = <$atomic_type>::new(0b101101);
             test_swap_ordering(|order| a.fetch_and(0b101101, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b101101);
                 assert_eq!(a.fetch_and(0b110011, order), 0b101101);
                 assert_eq!(a.load(Ordering::Relaxed), 0b100001);
@@ -369,7 +391,7 @@ macro_rules! __test_atomic_int {
         fn and() {
             let a = <$atomic_type>::new(0b101101);
             test_swap_ordering(|order| a.and(0b101101, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b101101);
                 a.and(0b110011, order);
                 assert_eq!(a.load(Ordering::Relaxed), 0b100001);
@@ -379,7 +401,7 @@ macro_rules! __test_atomic_int {
         fn fetch_nand() {
             let a = <$atomic_type>::new(0x13);
             test_swap_ordering(|order| a.fetch_nand(0x31, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0x13);
                 assert_eq!(a.fetch_nand(0x31, order), 0x13);
                 assert_eq!(a.load(Ordering::Relaxed), !(0x13 & 0x31));
@@ -389,7 +411,7 @@ macro_rules! __test_atomic_int {
         fn fetch_or() {
             let a = <$atomic_type>::new(0b101101);
             test_swap_ordering(|order| a.fetch_or(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b101101);
                 assert_eq!(a.fetch_or(0b110011, order), 0b101101);
                 assert_eq!(a.load(Ordering::Relaxed), 0b111111);
@@ -399,7 +421,7 @@ macro_rules! __test_atomic_int {
         fn or() {
             let a = <$atomic_type>::new(0b101101);
             test_swap_ordering(|order| a.or(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b101101);
                 a.or(0b110011, order);
                 assert_eq!(a.load(Ordering::Relaxed), 0b111111);
@@ -409,7 +431,7 @@ macro_rules! __test_atomic_int {
         fn fetch_xor() {
             let a = <$atomic_type>::new(0b101101);
             test_swap_ordering(|order| a.fetch_xor(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b101101);
                 assert_eq!(a.fetch_xor(0b110011, order), 0b101101);
                 assert_eq!(a.load(Ordering::Relaxed), 0b011110);
@@ -419,7 +441,7 @@ macro_rules! __test_atomic_int {
         fn xor() {
             let a = <$atomic_type>::new(0b101101);
             test_swap_ordering(|order| a.xor(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b101101);
                 a.xor(0b110011, order);
                 assert_eq!(a.load(Ordering::Relaxed), 0b011110);
@@ -429,7 +451,7 @@ macro_rules! __test_atomic_int {
         fn fetch_max() {
             let a = <$atomic_type>::new(23);
             test_swap_ordering(|order| a.fetch_max(23, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(23);
                 assert_eq!(a.fetch_max(22, order), 23);
                 assert_eq!(a.load(Ordering::Relaxed), 23);
@@ -449,7 +471,7 @@ macro_rules! __test_atomic_int {
         fn fetch_min() {
             let a = <$atomic_type>::new(23);
             test_swap_ordering(|order| a.fetch_min(23, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(23);
                 assert_eq!(a.fetch_min(24, order), 23);
                 assert_eq!(a.load(Ordering::Relaxed), 23);
@@ -469,7 +491,7 @@ macro_rules! __test_atomic_int {
         fn fetch_not() {
             let a = <$atomic_type>::new(1);
             test_swap_ordering(|order| a.fetch_not(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(1);
                 assert_eq!(a.fetch_not(order), 1);
                 assert_eq!(a.load(Ordering::Relaxed), !1);
@@ -479,7 +501,7 @@ macro_rules! __test_atomic_int {
         fn not() {
             let a = <$atomic_type>::new(1);
             test_swap_ordering(|order| a.not(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(1);
                 a.not(order);
                 assert_eq!(a.load(Ordering::Relaxed), !1);
@@ -489,7 +511,7 @@ macro_rules! __test_atomic_int {
         fn fetch_neg() {
             let a = <$atomic_type>::new(5);
             test_swap_ordering(|order| a.fetch_neg(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(5);
                 assert_eq!(a.fetch_neg(order), 5);
                 assert_eq!(a.load(Ordering::Relaxed), <$int_type>::wrapping_neg(5));
@@ -506,7 +528,7 @@ macro_rules! __test_atomic_int {
         fn neg() {
             let a = <$atomic_type>::new(5);
             test_swap_ordering(|order| a.neg(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(5);
                 a.neg(order);
                 assert_eq!(a.load(Ordering::Relaxed), <$int_type>::wrapping_neg(5));
@@ -523,7 +545,7 @@ macro_rules! __test_atomic_int {
         fn bit_set() {
             let a = <$atomic_type>::new(0b0001);
             test_swap_ordering(|order| assert!(a.bit_set(0, order)));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b0000);
                 assert!(!a.bit_set(0, order));
                 assert_eq!(a.load(Ordering::Relaxed), 0b0001);
@@ -535,7 +557,7 @@ macro_rules! __test_atomic_int {
         fn bit_clear() {
             let a = <$atomic_type>::new(0b0000);
             test_swap_ordering(|order| assert!(!a.bit_clear(0, order)));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b0001);
                 assert!(a.bit_clear(0, order));
                 assert_eq!(a.load(Ordering::Relaxed), 0b0000);
@@ -547,7 +569,7 @@ macro_rules! __test_atomic_int {
         fn bit_toggle() {
             let a = <$atomic_type>::new(0b0000);
             test_swap_ordering(|order| a.bit_toggle(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0b0000);
                 assert!(!a.bit_toggle(0, order));
                 assert_eq!(a.load(Ordering::Relaxed), 0b0001);
@@ -557,7 +579,7 @@ macro_rules! __test_atomic_int {
         }
         ::quickcheck::quickcheck! {
             fn quickcheck_swap(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.swap(y, order), x);
                     assert_eq!(a.swap(x, order), y);
@@ -583,7 +605,7 @@ macro_rules! __test_atomic_int {
                         break z;
                     }
                 };
-                for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+                for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.compare_exchange(x, y, success, failure).unwrap(), x);
                     assert_eq!(a.load(Ordering::Relaxed), y);
@@ -593,7 +615,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_add(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_add(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), x.wrapping_add(y));
@@ -604,7 +626,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_add(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.add(y, order);
                     assert_eq!(a.load(Ordering::Relaxed), x.wrapping_add(y));
@@ -615,7 +637,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_sub(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_sub(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), x.wrapping_sub(y));
@@ -626,7 +648,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_sub(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.sub(y, order);
                     assert_eq!(a.load(Ordering::Relaxed), x.wrapping_sub(y));
@@ -637,7 +659,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_and(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_and(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), x & y);
@@ -648,7 +670,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_and(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.and(y, order);
                     assert_eq!(a.load(Ordering::Relaxed), x & y);
@@ -659,7 +681,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_nand(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_nand(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), !(x & y));
@@ -670,7 +692,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_or(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_or(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), x | y);
@@ -681,7 +703,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_or(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.or(y, order);
                     assert_eq!(a.load(Ordering::Relaxed), x | y);
@@ -692,7 +714,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_xor(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_xor(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), x ^ y);
@@ -703,7 +725,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_xor(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.xor(y, order);
                     assert_eq!(a.load(Ordering::Relaxed), x ^ y);
@@ -714,7 +736,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_max(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_max(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), core::cmp::max(x, y));
@@ -725,7 +747,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_min(x: $int_type, y: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_min(y, order), x);
                     assert_eq!(a.load(Ordering::Relaxed), core::cmp::min(x, y));
@@ -736,7 +758,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_not(x: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_not(order), x);
                     assert_eq!(a.load(Ordering::Relaxed), !x);
@@ -746,7 +768,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_not(x: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.not(order);
                     assert_eq!(a.load(Ordering::Relaxed), !x);
@@ -756,7 +778,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_fetch_neg(x: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.fetch_neg(order), x);
                     assert_eq!(a.load(Ordering::Relaxed), x.wrapping_neg());
@@ -766,7 +788,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_neg(x: $int_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     a.neg(order);
                     assert_eq!(a.load(Ordering::Relaxed), x.wrapping_neg());
@@ -776,7 +798,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_bit_set(x: $int_type, bit: u32) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     let b = a.bit_set(bit, order);
                     let mask = <$int_type>::wrapping_shl(1, bit);
@@ -786,7 +808,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_bit_clear(x: $int_type, bit: u32) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     let b = a.bit_clear(bit, order);
                     let mask = <$int_type>::wrapping_shl(1, bit);
@@ -796,7 +818,7 @@ macro_rules! __test_atomic_int {
                 true
             }
             fn quickcheck_bit_toggle(x: $int_type, bit: u32) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     let b = a.bit_toggle(bit, order);
                     let mask = <$int_type>::wrapping_shl(1, bit);
@@ -933,7 +955,7 @@ macro_rules! __test_atomic_float {
         fn swap() {
             let a = <$atomic_type>::new(5.);
             test_swap_ordering(|order| a.swap(5., order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 assert_eq!(a.swap(10., order), 5.);
                 assert_eq!(a.swap(5., order), 10.);
             }
@@ -944,7 +966,7 @@ macro_rules! __test_atomic_float {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange(5., 5., success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(5.);
                 assert_eq!(a.compare_exchange(5., 10., success, failure), Ok(5.));
                 assert_eq!(a.load(Ordering::Relaxed), 10.);
@@ -958,7 +980,7 @@ macro_rules! __test_atomic_float {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange_weak(4., 4., success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(4.);
                 assert_eq!(a.compare_exchange_weak(6., 8., success, failure), Err(4.));
                 let mut old = a.load(Ordering::Relaxed);
@@ -976,7 +998,7 @@ macro_rules! __test_atomic_float {
         fn fetch_add() {
             let a = <$atomic_type>::new(0.);
             test_swap_ordering(|order| a.fetch_add(0., order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(0.);
                 assert_eq!(a.fetch_add(10., order), 0.);
                 assert_eq!(a.load(Ordering::Relaxed), 10.);
@@ -989,7 +1011,7 @@ macro_rules! __test_atomic_float {
         fn fetch_sub() {
             let a = <$atomic_type>::new(20.);
             test_swap_ordering(|order| a.fetch_sub(0., order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(20.);
                 assert_eq!(a.fetch_sub(10., order), 20.);
                 assert_eq!(a.load(Ordering::Relaxed), 10.);
@@ -1002,7 +1024,7 @@ macro_rules! __test_atomic_float {
         fn fetch_max() {
             let a = <$atomic_type>::new(23.);
             test_swap_ordering(|order| a.fetch_max(23., order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(23.);
                 assert_eq!(a.fetch_max(22., order), 23.);
                 assert_eq!(a.load(Ordering::Relaxed), 23.);
@@ -1014,7 +1036,7 @@ macro_rules! __test_atomic_float {
         fn fetch_min() {
             let a = <$atomic_type>::new(23.);
             test_swap_ordering(|order| a.fetch_min(23., order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(23.);
                 assert_eq!(a.fetch_min(24., order), 23.);
                 assert_eq!(a.load(Ordering::Relaxed), 23.);
@@ -1026,7 +1048,7 @@ macro_rules! __test_atomic_float {
         fn fetch_neg() {
             let a = <$atomic_type>::new(5.);
             test_swap_ordering(|order| a.fetch_neg(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(5.);
                 assert_eq!(a.fetch_neg(order), 5.);
                 assert_eq!(a.load(Ordering::Relaxed), -5.);
@@ -1038,7 +1060,7 @@ macro_rules! __test_atomic_float {
         fn fetch_abs() {
             let a = <$atomic_type>::new(23.);
             test_swap_ordering(|order| a.fetch_abs(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(-23.);
                 assert_eq!(a.fetch_abs(order), -23.);
                 assert_eq!(a.load(Ordering::Relaxed), 23.);
@@ -1048,7 +1070,7 @@ macro_rules! __test_atomic_float {
         }
         ::quickcheck::quickcheck! {
             fn quickcheck_swap(x: $float_type, y: $float_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.swap(y, order), x);
                     assert_float_op_eq!(a.swap(x, order), y);
@@ -1062,7 +1084,7 @@ macro_rules! __test_atomic_float {
                         break z;
                     }
                 };
-                for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+                for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.compare_exchange(x, y, success, failure).unwrap(), x);
                     assert_float_op_eq!(a.load(Ordering::Relaxed), y);
@@ -1081,7 +1103,7 @@ macro_rules! __test_atomic_float {
                     // https://github.com/rust-lang/rust/issues/73288
                     return true;
                 }
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.fetch_add(y, order), x);
                     assert_float_op_eq!(a.load(Ordering::Relaxed), x + y);
@@ -1098,7 +1120,7 @@ macro_rules! __test_atomic_float {
                     // https://github.com/rust-lang/rust/issues/73288
                     return true;
                 }
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.fetch_sub(y, order), x);
                     assert_float_op_eq!(a.load(Ordering::Relaxed), x - y);
@@ -1109,7 +1131,7 @@ macro_rules! __test_atomic_float {
                 true
             }
             fn quickcheck_fetch_max(x: $float_type, y: $float_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.fetch_max(y, order), x);
                     assert_float_op_eq!(a.load(Ordering::Relaxed), x.max(y));
@@ -1120,7 +1142,7 @@ macro_rules! __test_atomic_float {
                 true
             }
             fn quickcheck_fetch_min(x: $float_type, y: $float_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.fetch_min(y, order), x);
                     assert_float_op_eq!(a.load(Ordering::Relaxed), x.min(y));
@@ -1131,7 +1153,7 @@ macro_rules! __test_atomic_float {
                 true
             }
             fn quickcheck_fetch_neg(x: $float_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.fetch_neg(order), x);
                     assert_float_op_eq!(a.load(Ordering::Relaxed), -x);
@@ -1141,7 +1163,7 @@ macro_rules! __test_atomic_float {
                 true
             }
             fn quickcheck_fetch_abs(x: $float_type) -> bool {
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_float_op_eq!(a.fetch_abs(order), x);
                     assert_float_op_eq!(a.fetch_abs(order), x.abs());
@@ -1162,7 +1184,7 @@ macro_rules! __test_atomic_bool {
         fn swap() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| a.swap(true, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 assert_eq!(a.swap(true, order), true);
                 assert_eq!(a.swap(false, order), true);
                 assert_eq!(a.swap(false, order), false);
@@ -1175,7 +1197,7 @@ macro_rules! __test_atomic_bool {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange(true, true, success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 assert_eq!(a.compare_exchange(true, false, success, failure), Ok(true));
                 assert_eq!(a.load(Ordering::Relaxed), false);
@@ -1189,7 +1211,7 @@ macro_rules! __test_atomic_bool {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange_weak(false, false, success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(false);
                 assert_eq!(a.compare_exchange_weak(true, true, success, failure), Err(false));
                 let mut old = a.load(Ordering::Relaxed);
@@ -1207,7 +1229,7 @@ macro_rules! __test_atomic_bool {
         fn fetch_and() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| assert_eq!(a.fetch_and(true, order), true));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 assert_eq!(a.fetch_and(false, order), true);
                 assert_eq!(a.load(Ordering::Relaxed), false);
@@ -1226,7 +1248,7 @@ macro_rules! __test_atomic_bool {
         fn and() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| a.and(true, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 a.and(false, order);
                 assert_eq!(a.load(Ordering::Relaxed), false);
@@ -1245,7 +1267,7 @@ macro_rules! __test_atomic_bool {
         fn fetch_or() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| assert_eq!(a.fetch_or(false, order), true));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 assert_eq!(a.fetch_or(false, order), true);
                 assert_eq!(a.load(Ordering::Relaxed), true);
@@ -1264,7 +1286,7 @@ macro_rules! __test_atomic_bool {
         fn or() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| a.or(false, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 a.or(false, order);
                 assert_eq!(a.load(Ordering::Relaxed), true);
@@ -1283,7 +1305,7 @@ macro_rules! __test_atomic_bool {
         fn fetch_xor() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| assert_eq!(a.fetch_xor(false, order), true));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 assert_eq!(a.fetch_xor(false, order), true);
                 assert_eq!(a.load(Ordering::Relaxed), true);
@@ -1302,7 +1324,7 @@ macro_rules! __test_atomic_bool {
         fn xor() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| a.xor(false, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 a.xor(false, order);
                 assert_eq!(a.load(Ordering::Relaxed), true);
@@ -1320,7 +1342,7 @@ macro_rules! __test_atomic_bool {
         ::quickcheck::quickcheck! {
             fn quickcheck_compare_exchange(x: bool, y: bool) -> bool {
                 let z = !y;
-                for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+                for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.compare_exchange(x, y, success, failure).unwrap(), x);
                     assert_eq!(a.load(Ordering::Relaxed), y);
@@ -1343,7 +1365,7 @@ macro_rules! __test_atomic_ptr {
             let a = <$atomic_type>::new(ptr::null_mut());
             test_swap_ordering(|order| a.swap(ptr::null_mut(), order));
             let x = &mut 1;
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 assert_eq!(a.swap(x, order), ptr::null_mut());
                 assert_eq!(a.swap(ptr::null_mut(), order), x as *mut _);
             }
@@ -1354,7 +1376,7 @@ macro_rules! __test_atomic_ptr {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange(ptr::null_mut(), ptr::null_mut(), success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(ptr::null_mut());
                 let x = &mut 1;
                 assert_eq!(
@@ -1375,7 +1397,7 @@ macro_rules! __test_atomic_ptr {
             test_compare_exchange_ordering(|success, failure| {
                 a.compare_exchange_weak(ptr::null_mut(), ptr::null_mut(), success, failure)
             });
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(ptr::null_mut());
                 let x = &mut 1;
                 assert_eq!(a.compare_exchange_weak(x, x, success, failure), Err(ptr::null_mut()));
@@ -1393,7 +1415,7 @@ macro_rules! __test_atomic_ptr {
             fn quickcheck_swap(x: usize, y: usize) -> bool {
                 let x = sptr::invalid_mut(x);
                 let y = sptr::invalid_mut(y);
-                for &order in &test_helper::SWAP_ORDERINGS {
+                for &order in &SWAP_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.swap(y, order), x);
                     assert_eq!(a.swap(x, order), y);
@@ -1410,7 +1432,7 @@ macro_rules! __test_atomic_ptr {
                 let x = sptr::invalid_mut(x);
                 let y = sptr::invalid_mut(y);
                 let z = sptr::invalid_mut(z);
-                for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+                for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(a.compare_exchange(x, y, success, failure).unwrap(), x);
                     assert_eq!(a.load(Ordering::Relaxed), y);
@@ -1435,7 +1457,7 @@ macro_rules! __test_atomic_int_pub {
         fn fetch_update() {
             let a = <$atomic_type>::new(7);
             test_compare_exchange_ordering(|set, fetch| a.fetch_update(set, fetch, |x| Some(x)));
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(7);
                 assert_eq!(a.fetch_update(success, failure, |_| None), Err(7));
                 assert_eq!(a.fetch_update(success, failure, |x| Some(x + 1)), Ok(7));
@@ -1476,7 +1498,7 @@ macro_rules! __test_atomic_int_pub {
                         break z;
                     }
                 };
-                for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+                for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                     let a = <$atomic_type>::new(x);
                     assert_eq!(
                         a.fetch_update(success, failure, |_| Some(y))
@@ -1509,7 +1531,7 @@ macro_rules! __test_atomic_float_pub {
         fn fetch_update() {
             let a = <$atomic_type>::new(7.);
             test_compare_exchange_ordering(|set, fetch| a.fetch_update(set, fetch, |x| Some(x)));
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(7.);
                 assert_eq!(a.fetch_update(success, failure, |_| None), Err(7.));
                 assert_eq!(a.fetch_update(success, failure, |x| Some(x + 1.)), Ok(7.));
@@ -1552,7 +1574,7 @@ macro_rules! __test_atomic_bool_pub {
         fn fetch_nand() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| assert_eq!(a.fetch_nand(false, order), true));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 assert_eq!(a.fetch_nand(false, order), true);
                 assert_eq!(a.load(Ordering::Relaxed), true);
@@ -1572,7 +1594,7 @@ macro_rules! __test_atomic_bool_pub {
         fn fetch_not() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| a.fetch_not(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 assert_eq!(a.fetch_not(order), true);
                 assert_eq!(a.load(Ordering::Relaxed), false);
@@ -1585,7 +1607,7 @@ macro_rules! __test_atomic_bool_pub {
         fn not() {
             let a = <$atomic_type>::new(true);
             test_swap_ordering(|order| a.fetch_not(order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let a = <$atomic_type>::new(true);
                 a.not(order);
                 assert_eq!(a.load(Ordering::Relaxed), false);
@@ -1598,7 +1620,7 @@ macro_rules! __test_atomic_bool_pub {
         fn fetch_update() {
             let a = <$atomic_type>::new(false);
             test_compare_exchange_ordering(|set, fetch| a.fetch_update(set, fetch, |x| Some(x)));
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(false);
                 assert_eq!(a.fetch_update(success, failure, |_| None), Err(false));
                 assert_eq!(a.fetch_update(success, failure, |x| Some(!x)), Ok(false));
@@ -1642,7 +1664,7 @@ macro_rules! __test_atomic_ptr_pub {
         fn fetch_update() {
             let a = <$atomic_type>::new(ptr::null_mut());
             test_compare_exchange_ordering(|set, fetch| a.fetch_update(set, fetch, |x| Some(x)));
-            for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+            for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
                 let a = <$atomic_type>::new(ptr::null_mut());
                 assert_eq!(a.fetch_update(success, failure, |_| None), Err(ptr::null_mut()));
                 assert_eq!(
@@ -1764,7 +1786,7 @@ macro_rules! __test_atomic_ptr_pub {
         fn bit_set() {
             let a = <$atomic_type>::new(ptr::null_mut::<u64>().cast::<u8>().map_addr(|a| a | 1));
             test_swap_ordering(|order| assert!(a.bit_set(0, order)));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let pointer = &mut 1u64 as *mut u64 as *mut u8;
                 let atom = <$atomic_type>::new(pointer);
                 // Tag the bottom bit of the pointer.
@@ -1779,7 +1801,7 @@ macro_rules! __test_atomic_ptr_pub {
         fn bit_clear() {
             let a = <$atomic_type>::new(ptr::null_mut::<u64>().cast::<u8>());
             test_swap_ordering(|order| assert!(!a.bit_clear(0, order)));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let pointer = &mut 1u64 as *mut u64 as *mut u8;
                 // A tagged pointer
                 let atom = <$atomic_type>::new(pointer.map_addr(|a| a | 1));
@@ -1792,7 +1814,7 @@ macro_rules! __test_atomic_ptr_pub {
         fn bit_toggle() {
             let a = <$atomic_type>::new(ptr::null_mut::<u64>().cast::<u8>());
             test_swap_ordering(|order| a.bit_toggle(0, order));
-            for &order in &test_helper::SWAP_ORDERINGS {
+            for &order in &SWAP_ORDERINGS {
                 let pointer = &mut 1u64 as *mut u64 as *mut u8;
                 let atom = <$atomic_type>::new(pointer);
                 // Toggle a tag bit on the pointer.
@@ -2016,10 +2038,10 @@ pub(crate) fn assert_panic<T: std::fmt::
         .unwrap_or_else(|| msg.downcast_ref::<&'static str>().copied().unwrap().into())
 }
 pub(crate) fn rand_load_ordering() -> Ordering {
-    test_helper::LOAD_ORDERINGS[fastrand::usize(0..test_helper::LOAD_ORDERINGS.len())]
+    LOAD_ORDERINGS[fastrand::usize(0..LOAD_ORDERINGS.len())]
 }
 pub(crate) fn test_load_ordering<T: std::fmt::Debug>(f: impl Fn(Ordering) -> T) {
-    for &order in &test_helper::LOAD_ORDERINGS {
+    for &order in &LOAD_ORDERINGS {
         f(order);
     }
 
@@ -2035,10 +2057,10 @@ pub(crate) fn test_load_ordering<T: std:
     }
 }
 pub(crate) fn rand_store_ordering() -> Ordering {
-    test_helper::STORE_ORDERINGS[fastrand::usize(0..test_helper::STORE_ORDERINGS.len())]
+    STORE_ORDERINGS[fastrand::usize(0..STORE_ORDERINGS.len())]
 }
 pub(crate) fn test_store_ordering<T: std::fmt::Debug>(f: impl Fn(Ordering) -> T) {
-    for &order in &test_helper::STORE_ORDERINGS {
+    for &order in &STORE_ORDERINGS {
         f(order);
     }
 
@@ -2054,18 +2076,18 @@ pub(crate) fn test_store_ordering<T: std
     }
 }
 pub(crate) fn rand_compare_exchange_ordering() -> (Ordering, Ordering) {
-    test_helper::COMPARE_EXCHANGE_ORDERINGS
-        [fastrand::usize(0..test_helper::COMPARE_EXCHANGE_ORDERINGS.len())]
+    COMPARE_EXCHANGE_ORDERINGS
+        [fastrand::usize(0..COMPARE_EXCHANGE_ORDERINGS.len())]
 }
 pub(crate) fn test_compare_exchange_ordering<T: std::fmt::Debug>(
     f: impl Fn(Ordering, Ordering) -> T,
 ) {
-    for &(success, failure) in &test_helper::COMPARE_EXCHANGE_ORDERINGS {
+    for &(success, failure) in &COMPARE_EXCHANGE_ORDERINGS {
         f(success, failure);
     }
 
     if !skip_should_panic_test() {
-        for &order in &test_helper::SWAP_ORDERINGS {
+        for &order in &SWAP_ORDERINGS {
             let msg = assert_panic(|| f(order, Ordering::AcqRel));
             assert!(
                 msg == "there is no such thing as an acquire-release failure ordering"
@@ -2084,10 +2106,10 @@ pub(crate) fn test_compare_exchange_orde
     }
 }
 pub(crate) fn rand_swap_ordering() -> Ordering {
-    test_helper::SWAP_ORDERINGS[fastrand::usize(0..test_helper::SWAP_ORDERINGS.len())]
+    SWAP_ORDERINGS[fastrand::usize(0..SWAP_ORDERINGS.len())]
 }
 pub(crate) fn test_swap_ordering<T: std::fmt::Debug>(f: impl Fn(Ordering) -> T) {
-    for &order in &test_helper::SWAP_ORDERINGS {
+    for &order in &SWAP_ORDERINGS {
         f(order);
     }
 }
Index: rust-portable-atomic-1.9.0/src/imp/detect/auxv.rs
===================================================================
--- rust-portable-atomic-1.9.0.orig/src/imp/detect/auxv.rs
+++ rust-portable-atomic-1.9.0/src/imp/detect/auxv.rs
@@ -360,7 +360,7 @@ mod arch {
 mod tests {
     use super::*;
 
-    #[cfg(any(target_os = "linux", target_os = "android"))]
+    /*#[cfg(any(target_os = "linux", target_os = "android"))]
     #[cfg(target_pointer_width = "64")]
     #[test]
     fn test_linux_like() {
@@ -474,7 +474,7 @@ mod tests {
                 );
             }
         }
-    }
+    }*/
 
     #[allow(clippy::cast_sign_loss)]
     #[cfg(all(target_arch = "aarch64", target_os = "android"))]
@@ -764,7 +764,7 @@ mod tests {
     // without actually running tests on these platforms.
     // See also tools/codegen/src/ffi.rs.
     // TODO(codegen): auto-generate this test
-    #[allow(
+    /*#[allow(
         clippy::cast_possible_wrap,
         clippy::cast_sign_loss,
         clippy::cast_possible_truncation,
@@ -849,5 +849,5 @@ mod tests {
                 );
             }
         }
-    };
+    };*/
 }
Index: rust-portable-atomic-1.9.0/src/imp/detect/common.rs
===================================================================
--- rust-portable-atomic-1.9.0.orig/src/imp/detect/common.rs
+++ rust-portable-atomic-1.9.0/src/imp/detect/common.rs
@@ -162,7 +162,7 @@ mod c_types {
     pub(crate) type c_char = i8;
 
     // Static assertions for C type definitions.
-    #[cfg(test)]
+    /*#[cfg(test)]
     const _: fn() = || {
         use test_helper::{libc, sys};
         let _: c_int = 0 as std::os::raw::c_int;
@@ -176,7 +176,7 @@ mod c_types {
         )))]
         let _: c_char = 0 as std::os::raw::c_char;
         let _: c_char = 0 as sys::c_char;
-    };
+    };*/
 }
 
 #[allow(
@@ -254,55 +254,55 @@ mod tests_common {
     #[test]
     #[cfg_attr(portable_atomic_test_outline_atomics_detect_false, ignore)]
     fn test_detect() {
-        let proc_cpuinfo = test_helper::cpuinfo::ProcCpuinfo::new();
+        //let proc_cpuinfo = test_helper::cpuinfo::ProcCpuinfo::new();
         if detect().has_lse() {
             assert!(detect().test(CpuInfo::HAS_LSE));
-            if let Ok(proc_cpuinfo) = proc_cpuinfo {
+            /*if let Ok(proc_cpuinfo) = proc_cpuinfo {
                 assert!(proc_cpuinfo.lse);
-            }
+            }*/
         } else {
             assert!(!detect().test(CpuInfo::HAS_LSE));
-            if let Ok(proc_cpuinfo) = proc_cpuinfo {
+            /*if let Ok(proc_cpuinfo) = proc_cpuinfo {
                 assert!(!proc_cpuinfo.lse);
-            }
+            }*/
         }
         if detect().has_lse2() {
             assert!(detect().test(CpuInfo::HAS_LSE));
             assert!(detect().test(CpuInfo::HAS_LSE2));
-            if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse2: Some(lse2), .. }) = proc_cpuinfo {
+            /*if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse2: Some(lse2), .. }) = proc_cpuinfo {
                 assert!(lse2);
-            }
+            }*/
         } else {
             assert!(!detect().test(CpuInfo::HAS_LSE2));
-            if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse2: Some(lse2), .. }) = proc_cpuinfo {
+            /*if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse2: Some(lse2), .. }) = proc_cpuinfo {
                 assert!(!lse2);
-            }
+            }*/
         }
         if detect().has_lse128() {
             assert!(detect().test(CpuInfo::HAS_LSE));
             assert!(detect().test(CpuInfo::HAS_LSE2));
             assert!(detect().test(CpuInfo::HAS_LSE128));
-            if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse128: Some(lse128), .. }) = proc_cpuinfo
+            /*if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse128: Some(lse128), .. }) = proc_cpuinfo
             {
                 assert!(lse128);
-            }
+            }*/
         } else {
             assert!(!detect().test(CpuInfo::HAS_LSE128));
-            if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse128: Some(lse128), .. }) = proc_cpuinfo
+            /*if let Ok(test_helper::cpuinfo::ProcCpuinfo { lse128: Some(lse128), .. }) = proc_cpuinfo
             {
                 assert!(!lse128);
-            }
+            }*/
         }
         if detect().has_rcpc3() {
             assert!(detect().test(CpuInfo::HAS_RCPC3));
-            if let Ok(test_helper::cpuinfo::ProcCpuinfo { rcpc3: Some(rcpc3), .. }) = proc_cpuinfo {
+            /*if let Ok(test_helper::cpuinfo::ProcCpuinfo { rcpc3: Some(rcpc3), .. }) = proc_cpuinfo {
                 assert!(rcpc3);
-            }
+            }*/
         } else {
             assert!(!detect().test(CpuInfo::HAS_RCPC3));
-            if let Ok(test_helper::cpuinfo::ProcCpuinfo { rcpc3: Some(rcpc3), .. }) = proc_cpuinfo {
+            /*if let Ok(test_helper::cpuinfo::ProcCpuinfo { rcpc3: Some(rcpc3), .. }) = proc_cpuinfo {
                 assert!(!rcpc3);
-            }
+            }*/
         }
     }
     #[cfg(target_arch = "powerpc64")]
Index: rust-portable-atomic-1.9.0/src/imp/riscv.rs
===================================================================
--- rust-portable-atomic-1.9.0.orig/src/imp/riscv.rs
+++ rust-portable-atomic-1.9.0/src/imp/riscv.rs
@@ -569,6 +569,7 @@ atomic_ptr!([T] AtomicPtr, *mut T, "d");
 #[cfg(test)]
 mod tests {
     use super::*;
+    use crate::tests::helper::SWAP_ORDERINGS;
 
     test_atomic_ptr_load_store!();
     test_atomic_int_load_store!(i8);
@@ -602,7 +603,7 @@ mod tests {
                 fn quickcheck_swap(x: usize, y: usize) -> bool {
                     let x = sptr::invalid_mut(x);
                     let y = sptr::invalid_mut(y);
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.swap(y, order), x);
                         assert_eq!(a.swap(x, order), y);
@@ -630,7 +631,7 @@ mod tests {
         ($atomic_type:ty, $int_type:ident) => {
             ::quickcheck::quickcheck! {
                 fn quickcheck_swap(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.swap(y, order), x);
                         assert_eq!(a.swap(x, order), y);
@@ -638,7 +639,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_add(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_add(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), x.wrapping_add(y));
@@ -649,7 +650,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_sub(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_sub(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), x.wrapping_sub(y));
@@ -660,7 +661,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_and(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_and(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), x & y);
@@ -671,7 +672,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_or(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_or(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), x | y);
@@ -682,7 +683,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_xor(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_xor(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), x ^ y);
@@ -693,7 +694,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_max(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_max(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), core::cmp::max(x, y));
@@ -704,7 +705,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_min(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_min(y, order), x);
                         assert_eq!(a.load(Ordering::Relaxed), core::cmp::min(x, y));
@@ -715,7 +716,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_not(x: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         let a = <$atomic_type>::new(x);
                         assert_eq!(a.fetch_not(order), x);
                         assert_eq!(a.load(Ordering::Relaxed), !x);
@@ -749,7 +750,7 @@ mod tests {
             use crate::tests::helper::*;
             ::quickcheck::quickcheck! {
                 fn quickcheck_fetch_and(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         for base in [0, !0] {
                             let mut arr = Align16([
                                 <$atomic_type>::new(base),
@@ -789,7 +790,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_or(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         for base in [0, !0] {
                             let mut arr = Align16([
                                 <$atomic_type>::new(base),
@@ -829,7 +830,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_xor(x: $int_type, y: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         for base in [0, !0] {
                             let mut arr = Align16([
                                 <$atomic_type>::new(base),
@@ -869,7 +870,7 @@ mod tests {
                     true
                 }
                 fn quickcheck_fetch_not(x: $int_type) -> bool {
-                    for &order in &test_helper::SWAP_ORDERINGS {
+                    for &order in &SWAP_ORDERINGS {
                         for base in [0, !0] {
                             let mut arr = Align16([
                                 <$atomic_type>::new(base),
