--- a/lib.rs
+++ b/lib.rs
@@ -783,6 +783,23 @@
         let (effective_target, explicit_target) =
             find_effective_target(&options.clang_args);
 
+        // pass time64 options for glibc to libclang
+        // In theory we don't have to worry about 64-bit architectures as the
+        // options are supposed to be no-ops there. However in practice the
+        // time64 options seem to cause some problems on mips64el, so if the
+        // first part of the target string contains "64" we assume the target
+        // is 64-bit and do not pass the flags.
+
+        // We also have to exclude i368, since debian has decided to exclude
+        // that from the time64 transition . We also check for
+        // i468, i568 and i686. I'm not sure if it's possible for them to appear
+        // here, but it seems safer to check for them than not.
+        if (!effective_target.split("-").next().unwrap().contains("64")) && (!effective_target.starts_with("i386")) && (!effective_target.starts_with("i486")) && (!effective_target.starts_with("i586")) && (!effective_target.starts_with("i686")) {
+            options
+                .clang_args
+                .extend(["-D_FILE_OFFSET_BITS=64".into(), "-D_TIME_BITS=64".into()]);
+        }
+
         let is_host_build =
             rust_to_clang_target(HOST_TARGET) == effective_target;
 
