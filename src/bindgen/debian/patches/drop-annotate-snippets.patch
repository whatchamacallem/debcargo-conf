and avoid pulling annotate-snippets, which needs a breaking update for cargo 0.81

Index: bindgen/Cargo.toml
===================================================================
--- bindgen.orig/Cargo.toml
+++ bindgen/Cargo.toml
@@ -41,11 +41,6 @@ repository = "https://github.com/rust-la
 name = "bindgen"
 path = "lib.rs"
 
-[dependencies.annotate-snippets]
-version = "0.9.1"
-features = ["color"]
-optional = true
-
 [dependencies.bitflags]
 version = "2.2.1"
 
@@ -119,7 +114,7 @@ default = [
     "runtime",
     "which-rustfmt",
 ]
-experimental = ["dep:annotate-snippets"]
+experimental = []
 logging = ["dep:log"]
 runtime = ["clang-sys/runtime"]
 static = ["clang-sys/static"]
Index: bindgen/codegen/mod.rs
===================================================================
--- bindgen.orig/codegen/mod.rs
+++ bindgen/codegen/mod.rs
@@ -4326,49 +4326,6 @@ fn unsupported_abi_diagnostic(
         fn_name,
         error
     );
-
-    #[cfg(feature = "experimental")]
-    if ctx.options().emit_diagnostics {
-        use crate::diagnostics::{get_line, Diagnostic, Level, Slice};
-
-        let mut diag = Diagnostic::default();
-        diag.with_title(
-            format!(
-                "Skipping {}function `{}` because the {}",
-                if variadic { "variadic " } else { "" },
-                fn_name,
-                error
-            ),
-            Level::Warn,
-        )
-        .add_annotation(
-            "No code will be generated for this function.",
-            Level::Warn,
-        )
-        .add_annotation(
-            format!(
-                "The configured Rust version is {}.",
-                String::from(ctx.options().rust_target)
-            ),
-            Level::Note,
-        );
-
-        if let Some(loc) = location {
-            let (file, line, col, _) = loc.location();
-
-            if let Some(filename) = file.name() {
-                if let Ok(Some(source)) = get_line(&filename, line) {
-                    let mut slice = Slice::default();
-                    slice
-                        .with_source(source)
-                        .with_location(filename, line, col);
-                    diag.add_slice(slice);
-                }
-            }
-        }
-
-        diag.display()
-    }
 }
 
 fn variadic_fn_diagnostic(
@@ -4380,33 +4337,6 @@ fn variadic_fn_diagnostic(
         "Cannot generate wrapper for the static variadic function `{}`.",
         fn_name,
     );
-
-    #[cfg(feature = "experimental")]
-    if _ctx.options().emit_diagnostics {
-        use crate::diagnostics::{get_line, Diagnostic, Level, Slice};
-
-        let mut diag = Diagnostic::default();
-
-        diag.with_title(format!("Cannot generate wrapper for the static function `{}`.", fn_name), Level::Warn)
-            .add_annotation("The `--wrap-static-fns` feature does not support variadic functions.", Level::Note)
-            .add_annotation("No code will be generated for this function.", Level::Note);
-
-        if let Some(loc) = _location {
-            let (file, line, col, _) = loc.location();
-
-            if let Some(filename) = file.name() {
-                if let Ok(Some(source)) = get_line(&filename, line) {
-                    let mut slice = Slice::default();
-                    slice
-                        .with_source(source)
-                        .with_location(filename, line, col);
-                    diag.add_slice(slice);
-                }
-            }
-        }
-
-        diag.display()
-    }
 }
 
 fn objc_method_codegen(
Index: bindgen/ir/context.rs
===================================================================
--- bindgen.orig/ir/context.rs
+++ bindgen/ir/context.rs
@@ -2988,20 +2988,4 @@ impl TemplateParameters for PartialType
 
 fn unused_regex_diagnostic(item: &str, name: &str, _ctx: &BindgenContext) {
     warn!("unused option: {} {}", name, item);
-
-    #[cfg(feature = "experimental")]
-    if _ctx.options().emit_diagnostics {
-        use crate::diagnostics::{Diagnostic, Level};
-
-        Diagnostic::default()
-            .with_title(
-                format!("Unused regular expression: `{}`.", item),
-                Level::Warn,
-            )
-            .add_annotation(
-                format!("This regular expression was passed to `{}`.", name),
-                Level::Note,
-            )
-            .display();
-    }
 }
Index: bindgen/ir/var.rs
===================================================================
--- bindgen.orig/ir/var.rs
+++ bindgen/ir/var.rs
@@ -448,41 +448,4 @@ fn duplicated_macro_diagnostic(
 ) {
     warn!("Duplicated macro definition: {}", macro_name);
 
-    #[cfg(feature = "experimental")]
-    // FIXME (pvdrz & amanjeev): This diagnostic message shows way too often to be actually
-    // useful. We have to change the logic where this function is called to be able to emit this
-    // message only when the duplication is an actuall issue.
-    //
-    // If I understood correctly, `bindgen` ignores all `#undef` directives. Meaning that this:
-    // ```c
-    // #define FOO 1
-    // #undef FOO
-    // #define FOO 2
-    // ```
-    //
-    // Will trigger this message even though there's nothing wrong with it.
-    #[allow(clippy::overly_complex_bool_expr)]
-    if false && _ctx.options().emit_diagnostics {
-        use crate::diagnostics::{get_line, Diagnostic, Level, Slice};
-        use std::borrow::Cow;
-
-        let mut slice = Slice::default();
-        let mut source = Cow::from(macro_name);
-
-        let (file, line, col, _) = _location.location();
-        if let Some(filename) = file.name() {
-            if let Ok(Some(code)) = get_line(&filename, line) {
-                source = code.into();
-            }
-            slice.with_location(filename, line, col);
-        }
-
-        slice.with_source(source);
-
-        Diagnostic::default()
-            .with_title("Duplicated macro definition.", Level::Warn)
-            .add_slice(slice)
-            .add_annotation("This macro had a duplicate.", Level::Note)
-            .display();
-    }
 }
Index: bindgen/lib.rs
===================================================================
--- bindgen.orig/lib.rs
+++ bindgen/lib.rs
@@ -42,8 +42,6 @@ mod time;
 pub mod callbacks;
 
 mod clang;
-#[cfg(feature = "experimental")]
-mod diagnostics;
 mod features;
 mod ir;
 mod parse;
@@ -462,53 +460,6 @@ impl BindgenOptions {
         ];
 
         let record_matches = self.record_matches;
-        #[cfg(feature = "experimental")]
-        {
-            let sets_len = REGEX_SETS_LEN + self.abi_overrides.len();
-            let names = if self.emit_diagnostics {
-                <[&str; REGEX_SETS_LEN]>::into_iter([
-                    "--blocklist-type",
-                    "--blocklist-function",
-                    "--blocklist-item",
-                    "--blocklist-file",
-                    "--opaque-type",
-                    "--allowlist-type",
-                    "--allowlist-function",
-                    "--allowlist-var",
-                    "--allowlist-file",
-                    "--bitfield-enum",
-                    "--newtype-enum",
-                    "--newtype-global-enum",
-                    "--rustified-enum",
-                    "--rustified-enum-non-exhaustive",
-                    "--constified-enum-module",
-                    "--constified-enum",
-                    "--type-alias",
-                    "--new-type-alias",
-                    "--new-type-alias-deref",
-                    "--bindgen-wrapper-union",
-                    "--manually-drop-union",
-                    "--no-partialeq",
-                    "--no-copy",
-                    "--no-debug",
-                    "--no-default",
-                    "--no-hash",
-                    "--must-use",
-                ])
-                .chain((0..self.abi_overrides.len()).map(|_| "--override-abi"))
-                .map(Some)
-                .collect()
-            } else {
-                vec![None; sets_len]
-            };
-
-            for (regex_set, name) in
-                self.abi_overrides.values_mut().chain(regex_sets).zip(names)
-            {
-                regex_set.build_with_diagnostics(record_matches, name);
-            }
-        }
-        #[cfg(not(feature = "experimental"))]
         for regex_set in self.abi_overrides.values_mut().chain(regex_sets) {
             regex_set.build(record_matches);
         }
@@ -571,22 +522,6 @@ fn deprecated_target_diagnostic(target:
     let target = String::from(target);
     warn!("The {} Rust target is deprecated. If you have a good reason to use this target please report it at https://github.com/rust-lang/rust-bindgen/issues", target,);
 
-    #[cfg(feature = "experimental")]
-    if _options.emit_diagnostics {
-        use crate::diagnostics::{Diagnostic, Level};
-
-        let mut diagnostic = Diagnostic::default();
-        diagnostic.with_title(
-            format!("The {} Rust target is deprecated.", target),
-            Level::Warn,
-        );
-        diagnostic.add_annotation(
-            "This Rust target was passed to `--rust-target`",
-            Level::Info,
-        );
-        diagnostic.add_annotation("If you have a good reason to use this target please report it at https://github.com/rust-lang/rust-bindgen/issues", Level::Help);
-        diagnostic.display();
-    }
 }
 
 #[cfg(feature = "runtime")]
@@ -1060,18 +995,6 @@ impl Bindings {
 fn rustfmt_non_fatal_error_diagnostic(msg: &str, _options: &BindgenOptions) {
     warn!("{}", msg);
 
-    #[cfg(feature = "experimental")]
-    if _options.emit_diagnostics {
-        use crate::diagnostics::{Diagnostic, Level};
-
-        Diagnostic::default()
-            .with_title(msg, Level::Warn)
-            .add_annotation(
-                "The bindings will be generated but not formatted.",
-                Level::Note,
-            )
-            .display();
-    }
 }
 
 impl std::fmt::Display for Bindings {
Index: bindgen/regex_set.rs
===================================================================
--- bindgen.orig/regex_set.rs
+++ bindgen/regex_set.rs
@@ -104,10 +104,6 @@ impl RegexSet {
             Ok(x) => Some(x),
             Err(e) => {
                 warn!("Invalid regex in {:?}: {:?}", self.items, e);
-                #[cfg(feature = "experimental")]
-                if let Some(name) = _name {
-                    invalid_regex_warning(self, e, name);
-                }
                 None
             }
         }
@@ -139,66 +135,3 @@ impl RegexSet {
         true
     }
 }
-
-#[cfg(feature = "experimental")]
-fn invalid_regex_warning(
-    set: &RegexSet,
-    err: regex::Error,
-    name: &'static str,
-) {
-    use crate::diagnostics::{Diagnostic, Level, Slice};
-
-    let mut diagnostic = Diagnostic::default();
-
-    match err {
-        regex::Error::Syntax(string) => {
-            if string.starts_with("regex parse error:\n") {
-                let mut source = String::new();
-
-                let mut parsing_source = true;
-
-                for line in string.lines().skip(1) {
-                    if parsing_source {
-                        if line.starts_with(' ') {
-                            source.push_str(line);
-                            source.push('\n');
-                            continue;
-                        }
-                        parsing_source = false;
-                    }
-                    let error = "error: ";
-                    if line.starts_with(error) {
-                        let (_, msg) = line.split_at(error.len());
-                        diagnostic.add_annotation(msg.to_owned(), Level::Error);
-                    } else {
-                        diagnostic.add_annotation(line.to_owned(), Level::Info);
-                    }
-                }
-                let mut slice = Slice::default();
-                slice.with_source(source);
-                diagnostic.add_slice(slice);
-
-                diagnostic.with_title(
-                    "Error while parsing a regular expression.",
-                    Level::Warn,
-                );
-            } else {
-                diagnostic.with_title(string, Level::Warn);
-            }
-        }
-        err => {
-            let err = err.to_string();
-            diagnostic.with_title(err, Level::Warn);
-        }
-    }
-
-    diagnostic.add_annotation(
-        format!("This regular expression was passed via `{}`.", name),
-        Level::Note,
-    );
-
-    if set.items.iter().any(|item| item == "*") {
-        diagnostic.add_annotation("Wildcard patterns \"*\" are no longer considered valid. Use \".*\" instead.", Level::Help);
-    }
-    diagnostic.display();
-}
