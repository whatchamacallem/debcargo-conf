Index: rcgen/examples/rsa-irc-openssl.rs
===================================================================
--- rcgen.orig/examples/rsa-irc-openssl.rs
+++ rcgen/examples/rsa-irc-openssl.rs
@@ -19,8 +19,7 @@ fn main() -> Result<(), Box<dyn std::err
 
 	let cert = Certificate::from_params(params)?;
 	let pem_serialized = cert.serialize_pem()?;
-	let pem = pem::parse(&pem_serialized)?;
-	let der_serialized = pem.contents();
+	let der_serialized = pem::parse(&pem_serialized).unwrap().contents;
 	let hash = ring::digest::digest(&ring::digest::SHA512, &der_serialized);
 	let hash_hex: String = hash.as_ref().iter().map(|b| format!("{b:02x}")).collect();
 	println!("sha-512 fingerprint: {hash_hex}");
Index: rcgen/examples/rsa-irc.rs
===================================================================
--- rcgen.orig/examples/rsa-irc.rs
+++ rcgen/examples/rsa-irc.rs
@@ -25,8 +25,7 @@ fn main() -> Result<(), Box<dyn std::err
 
 	let cert = Certificate::from_params(params)?;
 	let pem_serialized = cert.serialize_pem()?;
-	let pem = pem::parse(&pem_serialized)?;
-	let der_serialized = pem.contents();
+	let der_serialized = pem::parse(&pem_serialized).unwrap().contents;
 	let hash = ring::digest::digest(&ring::digest::SHA512, &der_serialized);
 	let hash_hex: String = hash.as_ref().iter().map(|b| format!("{:02x}", b)).collect();
 	println!("sha-512 fingerprint: {hash_hex}");
Index: rcgen/src/csr.rs
===================================================================
--- rcgen.orig/src/csr.rs
+++ rcgen/src/csr.rs
@@ -38,7 +38,7 @@ impl CertificateSigningRequest {
 	#[cfg(all(feature = "pem", feature = "x509-parser"))]
 	pub fn from_pem(pem_str: &str) -> Result<Self, RcgenError> {
 		let csr = pem::parse(pem_str).or(Err(RcgenError::CouldNotParseCertificationRequest))?;
-		Self::from_der(csr.contents())
+		Self::from_der(&csr.contents)
 	}
 
 	/// Parse a certificate signing request from DER-encoded bytes
@@ -103,7 +103,10 @@ impl CertificateSigningRequest {
 		let contents = self
 			.params
 			.serialize_der_with_signer(&self.public_key, ca)?;
-		let p = Pem::new("CERTIFICATE", contents);
+		let p = Pem {
+			tag : "CERTIFICATE".to_string(),
+			contents : contents,
+		};
 		Ok(pem::encode_config(&p, crate::ENCODE_CONFIG))
 	}
 }
Index: rcgen/src/crl.rs
===================================================================
--- rcgen.orig/src/crl.rs
+++ rcgen/src/crl.rs
@@ -79,7 +79,10 @@ impl CertificateRevocationList {
 	#[cfg(feature = "pem")]
 	pub fn serialize_pem_with_signer(&self, ca: &Certificate) -> Result<String, RcgenError> {
 		let contents = self.serialize_der_with_signer(ca)?;
-		let p = Pem::new("X509 CRL", contents);
+		let p = Pem {
+			tag: "X509 CRL".to_string(),
+			contents: contents,
+		};
 		Ok(pem::encode_config(&p, ENCODE_CONFIG))
 	}
 }
Index: rcgen/src/lib.rs
===================================================================
--- rcgen.orig/src/lib.rs
+++ rcgen/src/lib.rs
@@ -570,7 +570,7 @@ impl CertificateParams {
 	#[cfg(all(feature = "pem", feature = "x509-parser"))]
 	pub fn from_ca_cert_pem(pem_str: &str, key_pair: KeyPair) -> Result<Self, RcgenError> {
 		let certificate = pem::parse(pem_str).or(Err(RcgenError::CouldNotParseCertificate))?;
-		Self::from_ca_cert_der(certificate.contents(), key_pair)
+		Self::from_ca_cert_der(&certificate.contents, key_pair)
 	}
 
 	/// Parses a ca certificate from the DER format for signing
@@ -1545,22 +1545,28 @@ impl Certificate {
 	/// Serializes the certificate to the ASCII PEM format
 	#[cfg(feature = "pem")]
 	pub fn serialize_pem(&self) -> Result<String, RcgenError> {
-		let contents = self.serialize_der()?;
-		let p = Pem::new("CERTIFICATE", contents);
+		let p = Pem {
+			tag : "CERTIFICATE".to_string(),
+			contents : self.serialize_der()?,
+		};
 		Ok(pem::encode_config(&p, ENCODE_CONFIG))
 	}
 	/// Serializes the certificate, signed with another certificate's key, to the ASCII PEM format
 	#[cfg(feature = "pem")]
 	pub fn serialize_pem_with_signer(&self, ca: &Certificate) -> Result<String, RcgenError> {
-		let contents = self.serialize_der_with_signer(ca)?;
-		let p = Pem::new("CERTIFICATE", contents);
+		let p = Pem {
+			tag : "CERTIFICATE".to_string(),
+			contents : self.serialize_der_with_signer(ca)?,
+		};
 		Ok(pem::encode_config(&p, ENCODE_CONFIG))
 	}
 	/// Serializes the certificate signing request to the ASCII PEM format
 	#[cfg(feature = "pem")]
 	pub fn serialize_request_pem(&self) -> Result<String, RcgenError> {
-		let contents = self.serialize_request_der()?;
-		let p = Pem::new("CERTIFICATE REQUEST", contents);
+		let p = Pem {
+			tag : "CERTIFICATE REQUEST".to_string(),
+			contents : self.serialize_request_der()?,
+		};
 		Ok(pem::encode_config(&p, ENCODE_CONFIG))
 	}
 	/// Serializes the private key in PKCS#8 format
Index: rcgen/src/key_pair.rs
===================================================================
--- rcgen.orig/src/key_pair.rs
+++ rcgen/src/key_pair.rs
@@ -66,7 +66,7 @@ impl KeyPair {
 	#[cfg(feature = "pem")]
 	pub fn from_pem(pem_str: &str) -> Result<Self, RcgenError> {
 		let private_key = pem::parse(pem_str)?;
-		let private_key_der: &[_] = private_key.contents();
+		let private_key_der: &[_] = &private_key.contents;
 		Ok(private_key_der.try_into()?)
 	}
 
@@ -89,7 +89,7 @@ impl KeyPair {
 		alg: &'static SignatureAlgorithm,
 	) -> Result<Self, RcgenError> {
 		let private_key = pem::parse(pem_str)?;
-		let private_key_der: &[_] = private_key.contents();
+		let private_key_der: &[_] = &private_key.contents;
 		Ok(Self::from_der_and_sign_algo(private_key_der, alg)?)
 	}
 
@@ -300,8 +300,10 @@ impl KeyPair {
 	/// The returned string can be interpreted with `openssl pkey --inform PEM -pubout -pubin -text`
 	#[cfg(feature = "pem")]
 	pub fn public_key_pem(&self) -> String {
-		let contents = self.public_key_der();
-		let p = Pem::new("PUBLIC KEY", contents);
+		let p = Pem {
+			tag : "PUBLIC KEY".to_string(),
+			contents : self.public_key_der(),
+		};
 		pem::encode_config(&p, ENCODE_CONFIG)
 	}
 	/// Serializes the key pair (including the private key) in PKCS#8 format in DER
@@ -339,8 +341,10 @@ impl KeyPair {
 	/// Serializes the key pair (including the private key) in PKCS#8 format in PEM
 	#[cfg(feature = "pem")]
 	pub fn serialize_pem(&self) -> String {
-		let contents = self.serialize_der();
-		let p = Pem::new("PRIVATE KEY", contents);
+		let p = Pem {
+			tag : "PRIVATE KEY".to_string(),
+			contents : self.serialize_der(),
+		};
 		pem::encode_config(&p, ENCODE_CONFIG)
 	}
 }
Index: rcgen/src/main.rs
===================================================================
--- rcgen.orig/src/main.rs
+++ rcgen/src/main.rs
@@ -22,8 +22,7 @@ fn main() -> Result<(), Box<dyn std::err
 	let cert = Certificate::from_params(params)?;
 
 	let pem_serialized = cert.serialize_pem()?;
-	let pem = pem::parse(&pem_serialized)?;
-	let der_serialized = pem.contents();
+	let der_serialized = pem::parse(&pem_serialized).unwrap().contents;
 	println!("{pem_serialized}");
 	println!("{}", cert.serialize_private_key_pem());
 	std::fs::create_dir_all("certs/")?;
Index: rcgen/Cargo.toml
===================================================================
--- rcgen.orig/Cargo.toml
+++ rcgen/Cargo.toml
@@ -43,7 +43,7 @@ name = "rsa-irc-openssl"
 required-features = ["pem"]
 
 [dependencies.pem]
-version = "2.0.1"
+version = "1.0.0"
 optional = true
 
 [dependencies.ring]
