commit 34bca59247f1485b0e40072534058fd6d797c0c2
Author: Daniel McCarney <daniel@binaryparadox.net>
Date:   Sat Jun 17 14:19:17 2023 -0400

    CertificateParams: lift AKI extension fn.
    
    Previously the `CertificateParams` type's `write_cert` fn had a code
    fragment used to write the authority key identifier (AKI) extension
    defined by RFC 5280 Section 4.2.1.1[0]
    
    Later, in RFC 5280 Section 5.2.1, there is text saying:
    > Conforming CRL issuers MUST use the key identifier method, and MUST
    > include this extension in all CRLs issued.
    
    Conveniently, the AKI extension implementation for CRLs is identical to
    certificates. Both use the definition from 4.2.1.1.
    
    In preparation for supporting generation of CRLs that adhere to the
    specification this commit lifts the existing code for AKI serialization
    to a free-standing version named `write_x509_authority_key_identifier`.
    The existing `CertificateParams.write_cert` code is updated to use this
    function.
    
    [0]: https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.1
    [1]: https://www.rfc-editor.org/rfc/rfc5280#section-5.2.1

diff --git a/src/lib.rs b/src/lib.rs
index a34cd3c96..91c91fb76 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1067,20 +1067,7 @@ impl CertificateParams {
 				writer.next().write_tagged(Tag::context(3), |writer| {
 					writer.write_sequence(|writer| {
 						if self.use_authority_key_identifier_extension {
-							// Write Authority Key Identifier (when issued by a CA)
-							// RFC 5280 states:
-							//   'The keyIdentifier field of the authorityKeyIdentifier extension MUST
-							//    be included in all certificates generated by conforming CAs to
-							//    facilitate certification path construction.  There is one exception;
-							//    where a CA distributes its public key in the form of a "self-signed"
-							//    certificate, the authority key identifier MAY be omitted.'
-							write_x509_extension(writer.next(), OID_AUTHORITY_KEY_IDENTIFIER, false, |writer| {
-								writer.write_sequence(|writer| {
-									writer.next().write_tagged_implicit(Tag::context(0), |writer| {
-										writer.write_bytes(ca.get_key_identifier().as_ref())
-									})
-								});
-							});
+							write_x509_authority_key_identifier(writer.next(), ca)
 						}
 						// Write subject_alt_names
 						if !self.subject_alt_names.is_empty() {
@@ -1664,6 +1651,27 @@ fn write_x509_extension(writer :DERWriter, extension_oid :&[u64], is_critical :b
 	})
 }
 
+/// Serializes an X.509v3 authority key identifier extension according to RFC 5280.
+fn write_x509_authority_key_identifier(writer :DERWriter, ca :&Certificate) {
+	// Write Authority Key Identifier
+	// RFC 5280 states:
+	//   'The keyIdentifier field of the authorityKeyIdentifier extension MUST
+	//    be included in all certificates generated by conforming CAs to
+	//    facilitate certification path construction.  There is one exception;
+	//    where a CA distributes its public key in the form of a "self-signed"
+	//    certificate, the authority key identifier MAY be omitted.'
+	// In addition, for CRLs:
+	//    'Conforming CRL issuers MUST use the key identifier method, and MUST
+	//     include this extension in all CRLs issued.'
+	write_x509_extension(writer, OID_AUTHORITY_KEY_IDENTIFIER, false, |writer| {
+		writer.write_sequence(|writer| {
+			writer.next().write_tagged_implicit(Tag::context(0), |writer| {
+				writer.write_bytes(ca.get_key_identifier().as_ref())
+			})
+		});
+	});
+}
+
 enum SignAlgo {
 	EcDsa(&'static EcdsaSigningAlgorithm),
 	EdDsa(&'static EdDSAParameters),
