--- a/Cargo.toml
+++ b/Cargo.toml
@@ -29,10 +29,10 @@
 version = "0.2"
 
 [dependencies.proc-macro2]
-version = "0.4"
+version = "1"
 
 [dependencies.quote]
-version = "0.6"
+version = "1"
 
 [dependencies.serde]
 version = "1"
@@ -47,6 +47,6 @@
 version = "0.6"
 
 [dependencies.syn]
-version = "0.15"
+version = "1"
 features = ["full", "parsing", "printing", "clone-impls"]
 default-features = false
--- a/src/macro_js_export.rs
+++ b/src/macro_js_export.rs
@@ -262,7 +262,8 @@
     quote! { #(#output)* }
 }
 
-fn into_export( ident: syn::Ident, decl: &syn::FnDecl ) -> Export {
+fn into_export( decl: &syn::Signature ) -> Export {
+    let ident = decl.ident.clone();
     assert!( decl.generics.lifetimes().next().is_none(), "Lifetimes are not yet not supported" );
     assert!( decl.generics.type_params().next().is_none(), "Generics are not supported" );
     assert!( decl.generics.where_clause.is_none(), "`where` clauses are not supported" );
@@ -276,22 +277,14 @@
     let mut args = Vec::new();
     for (index, arg) in decl.inputs.iter().cloned().enumerate() {
         match arg {
-            syn::FnArg::SelfRef( .. ) => panic!( "`&self` is not supported" ),
-            syn::FnArg::SelfValue( .. ) => panic!( "`self` is not supported" ),
-            syn::FnArg::Ignored( ty ) => {
-                let ident = syn::Ident::new( &format!( "__arg_{}", index ), Span::call_site() );
-                args.push( ExportArg {
-                    ident,
-                    ty: match_type( &ty )
-                });
-            },
-            syn::FnArg::Captured( cap ) => {
-                match cap.pat {
+            syn::FnArg::Receiver( .. ) => panic!( "`self` is not supported" ),
+            syn::FnArg::Typed( syn::PatType { pat, ty, .. } ) => {
+                match *pat {
                     syn::Pat::Wild( _ ) => {
                         let ident = syn::Ident::new( &format!( "__arg_{}", index ), Span::call_site() );
                         args.push( ExportArg {
                             ident,
-                            ty: match_type( &cap.ty )
+                            ty: match_type( &ty )
                         });
                     },
                     syn::Pat::Ident( pat ) => {
@@ -301,13 +294,12 @@
 
                         args.push( ExportArg {
                             ident: pat.ident,
-                            ty: match_type( &cap.ty )
+                            ty: match_type( &ty )
                         });
                     },
                     _ => panic!( "Argument patterns are not supported" )
                 }
-            },
-            syn::FnArg::Inferred( _ ) => panic!( "inferred argument types are not supported" )
+            }
         }
     }
 
@@ -329,7 +321,7 @@
 
     match item {
         syn::Item::Fn( ref function ) => {
-            exports.push( into_export( function.ident.clone(), &function.decl ) );
+            exports.push( into_export( &function.sig ) );
         },
         _ => panic!( "`#[js_export]` attached to an unsupported element!" )
     }
--- a/src/macro_async_test.rs
+++ b/src/macro_async_test.rs
@@ -29,7 +29,7 @@
 }
 
 // TODO: There must be a cleaner way to do this.
-fn check_decl( decl: &syn::FnDecl ) -> TestKind {
+fn check_decl( decl: &syn::Signature ) -> TestKind {
     assert!( decl.generics.lifetimes().next().is_none(), "Lifetimes are yet not supported" );
     assert!( decl.generics.where_clause.is_none(), "`where` clauses are not supported" );
     assert!( decl.variadic.is_none(), "Variadic functions are not supported" );
@@ -137,19 +137,17 @@
         panic!( "Expected a function with a single argument!" );
     }
 
-    let arg = decl.inputs.last().unwrap().into_value();
-    match arg {
-        syn::FnArg::SelfRef( .. ) => panic!( "`&self` is not supported" ),
-        syn::FnArg::SelfValue( .. ) => panic!( "`self` is not supported" ),
-        syn::FnArg::Ignored( .. ) =>  panic!( "ignored args are not supported" ),
-        syn::FnArg::Captured( cap ) => {
-            match cap.pat {
+    let arg = decl.inputs.last().unwrap();
+    match *arg {
+        syn::FnArg::Receiver( .. ) => panic!( "`self` is not supported" ),
+        syn::FnArg::Typed( syn::PatType { ref pat, ref ty, .. } ) => {
+            match **pat {
                 syn::Pat::Ident( ref pat ) => {
                     assert!( pat.by_ref.is_none(), "`ref` bindings are not supported" );
                     assert!( pat.mutability.is_none(), "`mut` bindings are not supported" );
                     assert!( pat.subpat.is_none(), "Subpatterns are not supported" );
 
-                    match cap.ty {
+                    match **ty {
                         syn::Type::Path(
                             syn::TypePath {
                                 qself: None,
@@ -177,16 +175,15 @@
                 },
                 _ => panic!( "Argument patterns are not supported" )
             }
-        },
-        syn::FnArg::Inferred( _ ) => panic!( "inferred argument types are not supported" )
+        }
     }
 }
 
 fn async_test_impl( item: syn::Item ) -> proc_macro2::TokenStream {
     let (ident, block, test_kind) = match item {
         syn::Item::Fn( function ) => {
-            let test_kind = check_decl( &function.decl );
-            (function.ident, function.block, test_kind)
+            let test_kind = check_decl( &function.sig );
+            (function.sig.ident.clone(), function.block, test_kind)
         },
         _ => panic!( "`#[async_test]` attached to an unsupported element!" )
     };
