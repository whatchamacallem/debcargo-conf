--- a/src/main.rs
+++ b/src/main.rs
@@ -17,7 +17,6 @@
 use std::path::{PathBuf, Path};
 
 use cargo::core::{Workspace, GitReference, SourceId, enable_nightly_features};
-use cargo::CliResult;
 use cargo::util::{Config, CargoResult, CargoResultExt};
 use cargo::util::Sha256;
 use docopt::Docopt;
@@ -123,11 +122,11 @@
         .unwrap_or_else(|e| e.exit());
     let result = real_main(options, &mut config);
     if let Err(e) = result {
-        cargo::exit_with_error(e, &mut *config.shell());
+        cargo::exit_with_error(e.into(), &mut *config.shell());
     }
 }
 
-fn real_main(options: Options, config: &mut Config) -> CliResult {
+fn real_main(options: Options, config: &mut Config) -> CargoResult<()> {
     if options.flag_version {
         println!("{} {}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"));
         return Ok(());
@@ -158,13 +157,11 @@
 
     fs::create_dir_all(&path).chain_err(|| {
         format!("failed to create: `{}`", path.display())
-    }).map_err(|e| cargo::CargoError::from(e))?;
+    })?;
 
     if !is_multi_sources && options.flag_no_merge_sources {
-        let mut file = File::create(sources_file)
-            .map_err(|e| cargo::CargoError::from(e))?;
-        file.write_all(json!([]).to_string().as_bytes())
-            .map_err(|e| cargo::CargoError::from(e))?;
+        let mut file = File::create(sources_file)?;
+        file.write_all(json!([]).to_string().as_bytes())?;
     }
 
     let workspaces = match options.flag_sync {
@@ -197,7 +194,7 @@
         !options.flag_no_merge_sources,
     ).chain_err(|| {
         format!("failed to sync")
-    }).map_err(|e| cargo::CargoError::from(e))?;
+    })?;
 
     if !options.flag_quiet.unwrap_or(false) {
         eprint!("To use vendored sources, add this to your .cargo/config for this project:\n\n");
@@ -252,6 +249,8 @@
         }
     }
 
+    let mut checksums = HashMap::new();
+
     for ws in workspaces {
         let (packages, resolve) = cargo::ops::resolve_ws(&ws).chain_err(|| {
             "failed to load pkg lockfile"
@@ -271,6 +270,8 @@
             ids.insert(pkg.clone(), packages.get_one(pkg).chain_err(|| {
                 "failed to fetch package"
             })?.clone());
+
+            checksums.insert(pkg.clone(), resolve.checksums().get(&pkg).cloned());
         }
     }
 
@@ -357,7 +358,7 @@
         if sources.insert(id.source_id()) && !merge_sources {
             fs::create_dir_all(&source_dir).chain_err(|| {
                 format!("failed to create: `{}`", source_dir.display())
-            }).map_err(|e| cargo::CargoError::from(e))?;
+            })?;
         }
         let dst = source_dir.join(&dst_name);
         added_crates.push(dst.clone());
@@ -381,7 +382,7 @@
 
         // Finally, emit the metadata about this package
         let json = json!({
-            "package": pkg.summary().checksum(),
+            "package": checksums.get(id),
             "files": map,
         });
 
