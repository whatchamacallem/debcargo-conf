Description: Remove tests and examples for successful compilation
 The examples should not be compiled, so they have been removed.
 The tests are broken, so they are also removed, so the package
 compiles successfully.
Author: Avery Murray <caverym@disroot.org>
Origin: upstream
Reviewed-by: Ben Westover <kwestover.kw@gmail.com>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/examples/basename.rs
+++ /dev/null
@@ -1,77 +0,0 @@
-use jargon_args::Jargon;
-
-// Not required, but a helper struct to contain arguments and their data.
-struct Args {
-    multiple: bool,
-    suffix: Option<String>,
-    zero: bool,
-    names: Vec<String>,
-}
-
-fn main() {
-    let mut j: Jargon = Jargon::from_env(); // Get an instance of Jargon using `std::env::args()`
-
-    if j.contains(["-h", "--help"]) { // check for help argument
-        print!("{}", HELP);
-        return;
-    }
-
-    if j.contains(["-v", "--version"]) { // check for version argument
-        println!(
-            "basename example for Jargon crate {}",
-            env!("CARGO_PKG_VERSION")
-        );
-        return;
-    }
-
-    let args = Args { // fill helper struct
-        multiple: j.contains(["-a", "--multiple"]), // multiple
-        suffix: j.option_arg(["-s", "--suffix"]), // suffix to remove
-        zero: j.contains(["-z", "--zero"]), // terminate lines with null
-        names: j.finish(), // get names
-    };
-
-    if args.names.is_empty() { // check if there are names
-        println!("Missing NAMES");
-        return;
-    }
-
-    let mut v: Vec<String> = vec![print(&args, &args.names[0])]; // initiate vector of names
-
-    if args.multiple { // fill the rest if `-a` or `--multiple` was passed
-        args.names.iter().skip(1).for_each(|name| v.append(&mut vec![print(&args, name)]));
-    }
-
-    if args.zero { // terminate with null if `-z` or `--zero` was passed
-        v.iter().for_each(|name| print!("{}", name));
-    } else { // terminate each name with space or new line
-        v.iter().for_each(|name| println!("{} ", name));
-    }
-}
-
-// extract basename and remove suffix
-fn print(args: &Args, name: &String) -> String {
-    if let Some(name) = name.split('/').last() {
-        if let Some(suffix) = &args.suffix {
-            if name.ends_with(suffix) {
-                if let Some(n) = name.strip_suffix(suffix) {
-                    return n.to_string();
-                }
-            }
-        }
-        return name.to_string();
-    }
-    name.to_string()
-}
-
-const HELP: &str = "Usage: basename NAME [SUFFIX]
-  or:  basename OPTION... NAME...
-Print NAME with any leading directory components removed.
-If specified, also remove a trailing SUFFIX.
-
-  -a, --multiple       support multiple arguments and treat each as a NAME
-  -s, --suffix SUFFIX  remove a trailing SUFFIX; implies -a
-  -z, --zero           end each output line with NUL, not newline
-  -h, --help     display this help and exit
-  -v, --version  output version information and exit
-";
--- a/examples/name.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-use jargon_args::*;
-
-fn main() {
-    let mut j: Jargon = Jargon::from_env();
-    let name_key: Key = "--name".into();
-
-    match j.option_arg(name_key.clone()) {
-        Some(n) => println!("Your name: {}", n),
-        None => eprintln!("Missing argument: {}", name_key),
-    }
-}
--- a/examples/subcommand.rs
+++ /dev/null
@@ -1,16 +0,0 @@
-use jargon_args::Jargon;
-
-fn main() {
-    let mut j: Jargon = Jargon::from_env();
-
-    j.on_subcommand("list", list);
-    j.on_subcommand("backwards", list_backwards);
-}
-
-fn list(v: Vec<String>) {
-    v.iter().skip(1).for_each(|x| println!("{}", x))
-}
-
-fn list_backwards(v: Vec<String>) {
-    v.iter().skip(1).rev().for_each(|x| println!("{}", x))
-}
--- a/examples/subcontinued.rs
+++ /dev/null
@@ -1,22 +0,0 @@
-use jargon_args::Jargon;
-
-fn main() {
-    let mut j: Jargon = Jargon::from_env();
-    j.on_subcommand("go", go);
-}
-
-fn go(v: Vec<String>) {
-    println!("go!");
-    let mut j: Jargon = Jargon::from_vec(v);
-    j.on_subcommand("goo", goo)
-}
-
-fn goo(v: Vec<String>) {
-    println!("goo!");
-    let mut j: Jargon = Jargon::from_vec(v);
-    j.on_subcommand("gooo", gooo)
-}
-
-fn gooo(_: Vec<String>) {
-    println!("gooo!");
-}
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -23,6 +23,3 @@
 pub use error::*;
 pub use jargons::*;
 pub use keys::*;
-
-#[cfg(test)]
-mod tests;
--- a/src/tests.rs
+++ /dev/null
@@ -1,973 +0,0 @@
-use crate::{Error, Jargon, Key};
-
-#[test]
-fn short_key() {
-    let key: Key = "-a".into();
-
-    assert_eq!(
-        key,
-        Key::Short {
-            char: '-',
-            txt: 'a'
-        }
-    )
-}
-
-#[test]
-fn long_key() {
-    let key: Key = "--all".into();
-
-    assert_eq!(
-        key,
-        Key::Long {
-            char: '-',
-            txt: "all".to_string()
-        }
-    )
-}
-
-#[test]
-fn sub_key() {
-    let key: Key = "beans".into();
-
-    assert_eq!(
-        key,
-        Key::Sub {
-            txt: "beans".into(),
-        }
-    )
-}
-
-#[test]
-fn dual_key_be() {
-    let dk: Key = ["-a", "--all"].into();
-
-    assert_eq!(
-        dk,
-        Key::Dual {
-            char: '-',
-            s_txt: 'a',
-            l_txt: "all".to_string(),
-        }
-    )
-}
-
-#[test]
-fn dual_key_le() {
-    let dk: Key = ["--all", "-a"].into();
-
-    assert_eq!(
-        dk,
-        Key::Dual {
-            char: '-',
-            s_txt: 'a',
-            l_txt: "all".to_string(),
-        }
-    )
-}
-
-#[test]
-#[should_panic]
-fn dual_key_with_sub() {
-    let _: Key = ["-all", "beans"].into();
-}
-
-#[test]
-fn fmt_short_key() {
-    let key: Key = "-a".into();
-    assert_eq!(format!("{}", key), "-a".to_string(),)
-}
-
-#[test]
-fn fmt_long_key() {
-    let key: Key = "--all".into();
-    assert_eq!(format!("{}", key), "--all".to_string(),)
-}
-
-#[test]
-fn fmt_dual_key() {
-    let key: Key = ["-a", "--all"].into();
-    assert_eq!(format!("{}", key), "-a, --all".to_string(),)
-}
-
-#[test]
-fn fmt_sub_key() {
-    let key: Key = "beans".into();
-    assert_eq!(format!("{}", key), "beans".to_string())
-}
-
-#[test]
-fn jargon() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-a".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert_eq!(
-        j,
-        Jargon {
-            0: [
-                "jargon".to_string(),
-                "-a".to_string(),
-                "-b".to_string(),
-                "beans".to_string(),
-            ]
-            .to_vec(),
-        }
-    )
-}
-
-#[test]
-fn jargon_finish() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-a".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    j.contains("-a");
-
-    assert_eq!(j.finish(), vec!["-b".to_string(), "beans".to_string(),])
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_short_t() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-a".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains_nomut("-a"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-a".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_short_f() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains_nomut("-a"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_short_t_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-a".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains("-a"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_short_f_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains("-a"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_long_t() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "--all".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains_nomut("--all"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "--all".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_long_f() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains_nomut("--all"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_long_t_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "--all".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains("--all"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_long_f_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains("--all"));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_dual_s_t() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-a".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains_nomut(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-a".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_dual_s_f() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains_nomut(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_dual_s_t_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-a".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_dual_l_f_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_dual_l_t() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "--all".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains_nomut(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "--all".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn jargon_contains_dual_l_f() {
-    let j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(!j.contains_nomut(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_contains_dual_l_t_rmv() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon".to_string(),
-        "--all".to_string(),
-        "-b".to_string(),
-        "beans".to_string(),
-    ]);
-
-    assert!(j.contains(["-a", "--all"]));
-
-    assert_eq!(
-        j,
-        Jargon(vec![
-            "jargon".to_string(),
-            "-b".to_string(),
-            "beans".to_string(),
-        ])
-    )
-}
-
-#[test]
-fn jargon_arg_option_short_t() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "-a".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("-a"), Some("hello".to_string()),)
-}
-
-#[test]
-fn jargon_arg_option_short_fa() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "-a".to_string(),
-        "--hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("-a"), None,)
-}
-
-#[test]
-fn jargon_arg_option_short_fm() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "-a".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("-a"), None,)
-}
-
-#[test]
-fn jargon_arg_option_short_f() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("-a"), None,)
-}
-
-#[test]
-fn jargon_arg_option_long_t() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "--all".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("--all"), Some("hello".to_string()),)
-}
-
-#[test]
-fn jargon_arg_option_long_fa() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "--all".to_string(),
-        "--hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("--all"), None,)
-}
-
-#[test]
-fn jargon_arg_option_long_fm() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "--all".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("--all"), None,)
-}
-
-#[test]
-fn jargon_arg_option_long_f() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg("--all"), None,)
-}
-
-#[test]
-fn jargon_arg_option_dual_s_t() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "-a".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), Some("hello".to_string()),)
-}
-
-#[test]
-fn jargon_arg_option_dual_s_fa() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "-a".to_string(),
-        "--hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), None,)
-}
-
-#[test]
-fn jargon_arg_option_dual_s_fm() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "-a".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), None,)
-}
-
-#[test]
-fn jargon_arg_option_dual_s_f() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), None,)
-}
-
-#[test]
-fn jargon_arg_option_dual_l_t() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "--all".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), Some("hello".to_string()),)
-}
-
-#[test]
-fn jargon_arg_option_dual_l_fa() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "--all".to_string(),
-        "--hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), None,)
-}
-
-#[test]
-fn jargon_arg_option_dual_l_fm() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "--all".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), None,)
-}
-
-#[test]
-fn jargon_arg_option_dual_l_f() {
-    let mut j = Jargon::from_vec(vec![
-        "jargon_arg_option_short_t".to_string(),
-        "hello".to_string(),
-        "world".to_string(),
-    ]);
-
-    assert_eq!(j.option_arg(["-a", "--all"]), None,)
-}
-
-#[test]
-fn key_short_is_short() {
-    let k: Key = "-a".into();
-    assert!(k.is_short())
-}
-
-#[test]
-fn key_short_is_long() {
-    let k: Key = "-a".into();
-    assert!(!k.is_long())
-}
-
-#[test]
-fn key_short_is_dual() {
-    let k: Key = "-a".into();
-    assert!(!k.is_dual())
-}
-
-#[test]
-fn key_short_is_sub() {
-    let k: Key = "-a".into();
-    assert!(!k.is_sub())
-}
-
-#[test]
-fn key_long_is_short() {
-    let k: Key = "--all".into();
-    assert!(!k.is_short())
-}
-
-#[test]
-fn key_long_is_long() {
-    let k: Key = "--all".into();
-    assert!(k.is_long())
-}
-
-#[test]
-fn key_long_is_dual() {
-    let k: Key = "--all".into();
-    assert!(!k.is_dual())
-}
-
-#[test]
-fn key_long_is_sub() {
-    let k: Key = "--all".into();
-    assert!(!k.is_sub())
-}
-
-#[test]
-fn key_dual_is_short() {
-    let k: Key = ["-a", "--all"].into();
-    assert!(!k.is_short())
-}
-
-#[test]
-fn key_dual_is_long() {
-    let k: Key = ["-a", "--all"].into();
-    assert!(!k.is_long())
-}
-
-#[test]
-fn key_dual_is_dual() {
-    let k: Key = ["-a", "--all"].into();
-    assert!(k.is_dual())
-}
-
-#[test]
-fn key_dual_is_sub() {
-    let k: Key = ["-a", "--all"].into();
-    assert!(!k.is_sub())
-}
-
-#[test]
-fn key_sub_is_short() {
-    let k: Key = "subcmd".into();
-    assert!(!k.is_short())
-}
-
-#[test]
-fn key_sub_is_long() {
-    let k: Key = "subcmd".into();
-    assert!(!k.is_long())
-}
-
-#[test]
-fn key_sub_is_dual() {
-    let k: Key = "subcmd".into();
-    assert!(!k.is_dual())
-}
-
-#[test]
-fn key_sub_is_sub() {
-    let k: Key = "subcmd".into();
-    assert!(k.is_sub())
-}
-
-#[test]
-fn key_short_char() {
-    let k: Key = "-a".into();
-    assert_eq!(k.char(), '-',)
-}
-
-#[test]
-fn key_long_char() {
-    let k: Key = "--all".into();
-    assert_eq!(k.char(), '-')
-}
-
-#[test]
-fn key_dual_char() {
-    let k: Key = ["-a", "--all"].into();
-    assert_eq!(k.char(), '-')
-}
-
-#[test]
-fn key_sub_char() {
-    let k: Key = "beans".into();
-    assert_eq!(k.char(), '\0',)
-}
-
-#[test]
-fn key_short_text() {
-    let k: Key = "-a".into();
-    assert_eq!(k.text(), "a".to_string(),)
-}
-
-#[test]
-fn key_long_text() {
-    let k: Key = "--all".into();
-    assert_eq!(k.text(), "all".to_string(),)
-}
-
-#[test]
-fn key_dual_text() {
-    let k: Key = ["-a", "--all"].into();
-    assert_eq!(k.text(), "all",)
-}
-
-#[test]
-fn key_sub_text() {
-    let k: Key = "beans".into();
-    assert_eq!(k.text(), "beans",)
-}
-
-#[test]
-fn from_env() {
-    let j = Jargon::from_env();
-    assert!(!j.0.is_empty());
-}
-
-#[test]
-fn on_sub_v_e() {
-    let mut j = Jargon::from_vec(vec!["on_sub".to_string(), "subsub".to_string()]);
-
-    fn subsub(v: Vec<String>) {
-        assert_eq!(v, vec!["subsub".to_string(),])
-    }
-
-    j.on_subcommand("subsub", subsub);
-}
-
-#[test]
-fn on_sub_v_w() {
-    let mut j = Jargon::from_vec(vec![
-        "on_sub".to_string(),
-        "subsub".to_string(),
-        "test".to_string(),
-    ]);
-
-    fn subsub(v: Vec<String>) {
-        assert_eq!(v, vec!["subsub".to_string(), "test".to_string(),])
-    }
-
-    j.on_subcommand("subsub", subsub);
-}
-
-#[test]
-fn on_sub_none() {
-    let mut j = Jargon::from_vec(vec!["on_sub".to_string(), "test".to_string()]);
-
-    fn subsub(_: Vec<String>) {
-        panic!()
-    }
-
-    j.on_subcommand("subsub", subsub);
-}
-
-#[test]
-fn on_sub_opt_e() {
-    let mut j = Jargon::from_vec(vec!["on_sub".to_string(), "subsub".to_string()]);
-
-    fn subsub(_: Vec<String>) -> Option<u8> {
-        Some(1u8)
-    }
-
-    assert_eq!(j.opt_on_subcommand("subsub", subsub), Some(1u8),)
-}
-
-#[test]
-fn on_sub_opt_w() {
-    let mut j = Jargon::from_vec(vec![
-        "on_sub".to_string(),
-        "subsub".to_string(),
-        "test".to_string(),
-    ]);
-
-    fn subsub(v: Vec<String>) -> Option<u8> {
-        assert_eq!(v, vec!["subsub".to_string(), "test".to_string(),]);
-
-        Some(1u8)
-    }
-
-    assert_eq!(j.opt_on_subcommand("subsub", subsub), Some(1u8),)
-}
-
-#[test]
-fn on_sub_opt_none() {
-    let mut j = Jargon::from_vec(vec!["on_sub".to_string(), "test".to_string()]);
-
-    fn subsub(_: Vec<String>) -> Option<u8> {
-        panic!()
-    }
-
-    assert_eq!(j.opt_on_subcommand("subsub", subsub), None,)
-}
-
-#[test]
-fn on_sub_res_e() {
-    let mut j = Jargon::from_vec(vec!["on_sub".to_string(), "subsub".to_string()]);
-
-    fn subsub(_: Vec<String>) -> Result<(), Error> {
-        Ok(())
-    }
-
-    assert_eq!(j.res_on_subcommand("subsub", subsub), Ok(()))
-}
-
-#[test]
-fn on_sub_res_none() {
-    let mut j = Jargon::from_vec(vec!["on_sub".to_string(), "test".to_string()]);
-
-    fn subsub(_: Vec<String>) -> Result<(), Error> {
-        panic!()
-    }
-
-    assert_eq!(
-        j.res_on_subcommand("subsub", subsub),
-        Err(Error::MissingArg("subsub".into())),
-    )
-}
-
-#[test]
-fn on_sub_res_w() {
-    let mut j = Jargon::from_vec(vec![
-        "on_sub".to_string(),
-        "subsub".to_string(),
-        "test".to_string(),
-    ]);
-
-    fn subsub(_: Vec<String>) -> Result<(), Error> {
-        Ok(())
-    }
-
-    assert_eq!(j.res_on_subcommand("subsub", subsub), Ok(()))
-}
-
-#[test]
-fn sub_mut_s_e() {
-    let mut j: Jargon = Jargon::from_vec(vec!["sub_mut_s".to_string(), "subsub".to_string()]);
-
-    if let Some(v) = j.subcommand("subsub") {
-        assert_eq!(v, vec!["subsub".to_string(),])
-    }
-}
-
-#[test]
-fn sub_mut_s_w() {
-    let mut j: Jargon = Jargon::from_vec(vec![
-        "sub_mut_s".to_string(),
-        "subsub".to_string(),
-        "test".to_string(),
-    ]);
-
-    if let Some(v) = j.subcommand("subsub") {
-        assert_eq!(v, vec!["subsub".to_string(), "test".to_string(),])
-    }
-}
-
-#[test]
-fn sub_mut_none() {
-    let mut j: Jargon = Jargon::from_vec(vec!["sub_mut_none".to_string(), "test".to_string()]);
-
-    assert_eq!(j.subcommand("subsub"), None,)
-}
-
-#[test]
-#[cfg(feature = "no_mut")]
-fn sub_s_e() {
-    let j: Jargon = Jargon::from_vec(vec!["sub_mut_s".to_string(), "subsub".to_string()]);
-
-    if let Some(v) = j.subcommand_nomut("subsub") {
-        assert_eq!(v, vec!["subsub".to_string(),])
-    }
-}
-
-#[test]
-fn sub_s_w() {
-    let mut j: Jargon = Jargon::from_vec(vec![
-        "sub_mut_s".to_string(),
-        "subsub".to_string(),
-        "test".to_string(),
-    ]);
-
-    if let Some(v) = j.subcommand("subsub") {
-        assert_eq!(v, vec!["subsub".to_string(), "test".to_string(),])
-    }
-}
-
-#[test]
-fn sub_none() {
-    let mut j: Jargon = Jargon::from_vec(vec!["sub_mut_none".to_string(), "test".to_string()]);
-
-    assert_eq!(j.subcommand("subsub"), None,)
-}
-
-#[test]
-fn fmt_error_missing() {
-    assert_eq!(
-        Error::MissingArg("--all".into()).to_string(),
-        "Missing argument: '--all'".to_string(),
-    )
-}
-
-#[test]
-fn fmt_error_other() {
-    let e = Error::Other(std::io::Error::new(std::io::ErrorKind::AddrInUse, "test").to_string());
-    assert_eq!(e.to_string(), "test".to_string(),)
-}
