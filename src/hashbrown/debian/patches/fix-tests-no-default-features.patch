This patch fixes the tests if the allocator-api2 feature is disabled.

It also attempts to fix the tests if the "ahash" feature is disabled
but currently the code doesn't build at all without that feature.

Index: hashbrown/src/map.rs
===================================================================
--- hashbrown.orig/src/map.rs
+++ hashbrown/src/map.rs
@@ -6711,6 +6711,7 @@ mod test_map {
     use super::{HashMap, RawEntryMut};
     use alloc::string::{String, ToString};
     use alloc::sync::Arc;
+    #[cfg(feature="allocator-api2")]
     use allocator_api2::alloc::{AllocError, Allocator, Global};
     use core::alloc::Layout;
     use core::ptr::NonNull;
@@ -6722,6 +6723,7 @@ mod test_map {
     use std::vec::Vec;
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_zero_capacities() {
         type HM = HashMap<i32, i32>;
 
@@ -6754,6 +6756,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_create_capacity_zero() {
         let mut m = HashMap::with_capacity(0);
 
@@ -6764,6 +6767,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_insert() {
         let mut m = HashMap::new();
         assert_eq!(m.len(), 0);
@@ -6776,6 +6780,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_clone() {
         let mut m = HashMap::new();
         assert_eq!(m.len(), 0);
@@ -6791,6 +6796,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_clone_from() {
         let mut m = HashMap::new();
         let mut m2 = HashMap::new();
@@ -6837,6 +6843,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_drops() {
         DROP_VECTOR.with(|slot| {
             *slot.borrow_mut() = vec![0; 200];
@@ -6896,6 +6903,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_into_iter_drops() {
         DROP_VECTOR.with(|v| {
             *v.borrow_mut() = vec![0; 200];
@@ -6957,12 +6965,14 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_empty_remove() {
         let mut m: HashMap<i32, bool> = HashMap::new();
         assert_eq!(m.remove(&0), None);
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_empty_entry() {
         let mut m: HashMap<i32, bool> = HashMap::new();
         match m.entry(0) {
@@ -6974,6 +6984,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_empty_entry_ref() {
         let mut m: HashMap<std::string::String, bool> = HashMap::new();
         match m.entry_ref("poneyland") {
@@ -6985,6 +6996,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_empty_iter() {
         let mut m: HashMap<i32, bool> = HashMap::new();
         assert_eq!(m.drain().next(), None);
@@ -7000,6 +7012,7 @@ mod test_map {
 
     #[test]
     #[cfg_attr(miri, ignore)] // FIXME: takes too long
+    #[cfg(feature="ahash")]
     fn test_lots_of_insertions() {
         let mut m = HashMap::new();
 
@@ -7063,6 +7076,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_find_mut() {
         let mut m = HashMap::new();
         assert!(m.insert(1, 12).is_none());
@@ -7077,6 +7091,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_insert_overwrite() {
         let mut m = HashMap::new();
         assert!(m.insert(1, 2).is_none());
@@ -7086,6 +7101,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_insert_conflicts() {
         let mut m = HashMap::with_capacity(4);
         assert!(m.insert(1, 2).is_none());
@@ -7097,6 +7113,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_conflict_remove() {
         let mut m = HashMap::with_capacity(4);
         assert!(m.insert(1, 2).is_none());
@@ -7114,6 +7131,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_insert_unique_unchecked() {
         let mut map = HashMap::new();
         let (k1, v1) = map.insert_unique_unchecked(10, 11);
@@ -7126,6 +7144,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_is_empty() {
         let mut m = HashMap::with_capacity(4);
         assert!(m.insert(1, 2).is_none());
@@ -7135,6 +7154,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_remove() {
         let mut m = HashMap::new();
         m.insert(1, 2);
@@ -7143,6 +7163,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_remove_entry() {
         let mut m = HashMap::new();
         m.insert(1, 2);
@@ -7151,6 +7172,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_iterate() {
         let mut m = HashMap::with_capacity(4);
         for i in 0..32 {
@@ -7168,6 +7190,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_keys() {
         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];
         let map: HashMap<_, _> = vec.into_iter().collect();
@@ -7179,6 +7202,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_values() {
         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];
         let map: HashMap<_, _> = vec.into_iter().collect();
@@ -7190,6 +7214,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_values_mut() {
         let vec = vec![(1, 1), (2, 2), (3, 3)];
         let mut map: HashMap<_, _> = vec.into_iter().collect();
@@ -7204,6 +7229,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_into_keys() {
         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];
         let map: HashMap<_, _> = vec.into_iter().collect();
@@ -7216,6 +7242,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_into_values() {
         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];
         let map: HashMap<_, _> = vec.into_iter().collect();
@@ -7228,6 +7255,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_find() {
         let mut m = HashMap::new();
         assert!(m.get(&1).is_none());
@@ -7239,6 +7267,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_eq() {
         let mut m1 = HashMap::new();
         m1.insert(1, 2);
@@ -7257,6 +7286,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_show() {
         let mut map = HashMap::new();
         let empty: HashMap<i32, i32> = HashMap::new();
@@ -7271,6 +7301,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_expand() {
         let mut m = HashMap::new();
 
@@ -7289,6 +7320,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_behavior_resize_policy() {
         let mut m = HashMap::new();
 
@@ -7345,6 +7377,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_reserve_shrink_to_fit() {
         let mut m = HashMap::new();
         m.insert(0, 0);
@@ -7382,6 +7415,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_from_iter() {
         let xs = [(1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];
 
@@ -7395,6 +7429,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_size_hint() {
         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];
 
@@ -7408,6 +7443,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_iter_len() {
         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];
 
@@ -7421,6 +7457,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_mut_size_hint() {
         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];
 
@@ -7434,6 +7471,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_iter_mut_len() {
         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];
 
@@ -7447,6 +7485,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_index() {
         let mut map = HashMap::new();
 
@@ -7459,6 +7498,7 @@ mod test_map {
 
     #[test]
     #[should_panic]
+    #[cfg(feature="ahash")]
     fn test_index_nonexistent() {
         let mut map = HashMap::new();
 
@@ -7471,6 +7511,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_entry() {
         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];
 
@@ -7521,6 +7562,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_entry_ref() {
         let xs = [
             ("One".to_owned(), 10),
@@ -7578,6 +7620,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_entry_take_doesnt_corrupt() {
         #![allow(deprecated)] //rand
                               // Test for #19292
@@ -7614,6 +7657,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_entry_ref_take_doesnt_corrupt() {
         #![allow(deprecated)] //rand
                               // Test for #19292
@@ -7652,6 +7696,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_extend_ref_k_ref_v() {
         let mut a = HashMap::new();
         a.insert(1, "one");
@@ -7669,6 +7714,7 @@ mod test_map {
 
     #[test]
     #[allow(clippy::needless_borrow)]
+    #[cfg(feature="ahash")]
     fn test_extend_ref_kv_tuple() {
         use std::ops::AddAssign;
         let mut a = HashMap::new();
@@ -7700,6 +7746,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_capacity_not_less_than_len() {
         let mut a = HashMap::new();
         let mut item = 0;
@@ -7725,6 +7772,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_occupied_entry_key() {
         let mut a = HashMap::new();
         let key = "hello there";
@@ -7743,6 +7791,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_occupied_entry_ref_key() {
         let mut a = HashMap::new();
         let key = "hello there";
@@ -7761,6 +7810,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_vacant_entry_key() {
         let mut a = HashMap::new();
         let key = "hello there";
@@ -7779,6 +7829,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_vacant_entry_ref_key() {
         let mut a: HashMap<std::string::String, &str> = HashMap::new();
         let key = "hello there";
@@ -7797,6 +7848,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_occupied_entry_replace_entry_with() {
         let mut a = HashMap::new();
 
@@ -7840,6 +7892,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_occupied_entry_ref_replace_entry_with() {
         let mut a: HashMap<std::string::String, &str> = HashMap::new();
 
@@ -7883,6 +7936,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_entry_and_replace_entry_with() {
         let mut a = HashMap::new();
 
@@ -7932,6 +7986,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_entry_ref_and_replace_entry_with() {
         let mut a = HashMap::new();
 
@@ -7981,6 +8036,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_raw_occupied_entry_replace_entry_with() {
         let mut a = HashMap::new();
 
@@ -8028,6 +8084,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_raw_entry_and_replace_entry_with() {
         let mut a = HashMap::new();
 
@@ -8086,6 +8143,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_replace_entry_with_doesnt_corrupt() {
         #![allow(deprecated)] //rand
                               // Test for #19292
@@ -8116,6 +8174,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_replace_entry_ref_with_doesnt_corrupt() {
         #![allow(deprecated)] //rand
                               // Test for #19292
@@ -8148,6 +8207,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_retain() {
         let mut map: HashMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();
 
@@ -8159,6 +8219,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_extract_if() {
         {
             let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x * 10)).collect();
@@ -8177,6 +8238,7 @@ mod test_map {
 
     #[test]
     #[cfg_attr(miri, ignore)] // FIXME: no OOM signalling (https://github.com/rust-lang/miri/issues/613)
+    #[cfg(feature="ahash")]
     fn test_try_reserve() {
         use crate::TryReserveError::{AllocError, CapacityOverflow};
 
@@ -8211,6 +8273,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_raw_entry() {
         use super::RawEntryMut::{Occupied, Vacant};
 
@@ -8448,6 +8511,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_get_each_mut() {
         let mut map = HashMap::new();
         map.insert("foo".to_owned(), 0);
@@ -8479,6 +8543,7 @@ mod test_map {
 
     #[test]
     #[should_panic = "panic in drop"]
+    #[cfg(feature="ahash")]
     fn test_clone_from_double_drop() {
         #[derive(Clone)]
         struct CheckedDrop {
@@ -8523,6 +8588,7 @@ mod test_map {
 
     #[test]
     #[should_panic = "panic in clone"]
+    #[cfg(feature="ahash")]
     fn test_clone_from_memory_leaks() {
         use alloc::vec::Vec;
 
@@ -8590,6 +8656,7 @@ mod test_map {
         }
     }
 
+    #[cfg(feature="allocator-api2")]
     unsafe impl Allocator for MyAlloc {
         fn allocate(&self, layout: Layout) -> std::result::Result<NonNull<[u8]>, AllocError> {
             let g = Global;
@@ -8603,6 +8670,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_hashmap_into_iter_bug() {
         let dropped: Arc<AtomicI8> = Arc::new(AtomicI8::new(1));
 
@@ -8673,6 +8741,7 @@ mod test_map {
     ///
     /// This function does not panic, but returns an error as a `String`
     /// to distinguish between a test panic and an error in the input data.
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn get_test_map<I, T, A>(
         iter: I,
         mut fun: impl FnMut(u64) -> T,
@@ -8768,6 +8837,7 @@ mod test_map {
 
     #[test]
     #[should_panic = "panic in clone"]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_clone_memory_leaks_and_double_drop_one() {
         let dropped: Arc<AtomicI8> = Arc::new(AtomicI8::new(2));
 
@@ -8794,6 +8864,7 @@ mod test_map {
 
     #[test]
     #[should_panic = "panic in drop"]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_clone_memory_leaks_and_double_drop_two() {
         let dropped: Arc<AtomicI8> = Arc::new(AtomicI8::new(2));
 
@@ -8828,6 +8899,7 @@ mod test_map {
     /// We check that we have a working table if the clone operation from another
     /// thread ended in a panic (when buckets of maps are equal to each other).
     #[test]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_catch_panic_clone_from_when_len_is_equal() {
         use std::thread;
 
@@ -8893,6 +8965,7 @@ mod test_map {
     /// We check that we have a working table if the clone operation from another
     /// thread ended in a panic (when buckets of maps are not equal to each other).
     #[test]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_catch_panic_clone_from_when_len_is_not_equal() {
         use std::thread;
 
Index: hashbrown/src/raw/mod.rs
===================================================================
--- hashbrown.orig/src/raw/mod.rs
+++ hashbrown/src/raw/mod.rs
@@ -2970,6 +2970,7 @@ impl RawTableInner {
     ///
     /// * The [`RawTableInner`] must have properly initialized control bytes.
     #[inline(always)]
+    #[cfg(feature="ahash")]
     unsafe fn full_buckets_indices(&self) -> FullBucketsIndices {
         // SAFETY:
         // 1. Since the caller of this function ensures that the control bytes
@@ -3044,6 +3045,7 @@ impl RawTableInner {
     /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
     #[allow(clippy::inline_always)]
     #[inline(always)]
+    #[cfg(feature="ahash")]
     unsafe fn resize_inner<A>(
         &mut self,
         alloc: &A,
@@ -4671,9 +4673,11 @@ mod test_map {
     /// CHECKING THAT WE DON'T TRY TO DROP DATA IF THE `ITEMS`
     /// ARE ZERO, EVEN IF WE HAVE `FULL` CONTROL BYTES.
     #[test]
+    #[cfg(feature="allocator-api2")]
     fn test_catch_panic_clone_from() {
         use ::alloc::sync::Arc;
         use ::alloc::vec::Vec;
+        #[cfg(feature="allocator-api2")]
         use allocator_api2::alloc::{AllocError, Allocator, Global};
         use core::sync::atomic::{AtomicI8, Ordering};
         use std::thread;
@@ -4694,6 +4698,7 @@ mod test_map {
             }
         }
 
+        #[cfg(feature="allocator-api2")]
         unsafe impl Allocator for MyAlloc {
             fn allocate(&self, layout: Layout) -> std::result::Result<NonNull<[u8]>, AllocError> {
                 let g = Global;
Index: hashbrown/src/set.rs
===================================================================
--- hashbrown.orig/src/set.rs
+++ hashbrown/src/set.rs
@@ -2505,6 +2505,7 @@ mod test_set {
     use std::vec::Vec;
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_zero_capacities() {
         type HS = HashSet<i32>;
 
@@ -2537,6 +2538,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_disjoint() {
         let mut xs = HashSet::new();
         let mut ys = HashSet::new();
@@ -2559,6 +2561,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_subset_and_superset() {
         let mut a = HashSet::new();
         assert!(a.insert(0));
@@ -2588,6 +2591,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_iterate() {
         let mut a = HashSet::new();
         for i in 0..32 {
@@ -2601,6 +2605,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_intersection() {
         let mut a = HashSet::new();
         let mut b = HashSet::new();
@@ -2631,6 +2636,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_difference() {
         let mut a = HashSet::new();
         let mut b = HashSet::new();
@@ -2654,6 +2660,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_symmetric_difference() {
         let mut a = HashSet::new();
         let mut b = HashSet::new();
@@ -2680,6 +2687,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_union() {
         let mut a = HashSet::new();
         let mut b = HashSet::new();
@@ -2710,6 +2718,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_from_map() {
         let mut a = crate::HashMap::new();
         a.insert(1, ());
@@ -2727,6 +2736,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_from_iter() {
         let xs = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];
 
@@ -2740,6 +2750,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_move_iter() {
         let hs = {
             let mut hs = HashSet::new();
@@ -2755,6 +2766,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_eq() {
         // These constants once happened to expose a bug in insert().
         // I'm keeping them around to prevent a regression.
@@ -2777,6 +2789,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_show() {
         let mut set = HashSet::new();
         let empty = HashSet::<i32>::new();
@@ -2791,6 +2804,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_trivial_drain() {
         let mut s = HashSet::<i32>::new();
         for _ in s.drain() {}
@@ -2803,6 +2817,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_drain() {
         let mut s: HashSet<_> = (1..100).collect();
 
@@ -2830,6 +2845,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_replace() {
         use core::hash;
 
@@ -2864,6 +2880,7 @@ mod test_set {
 
     #[test]
     #[allow(clippy::needless_borrow)]
+    #[cfg(feature="ahash")]
     fn test_extend_ref() {
         let mut a = HashSet::new();
         a.insert(1);
@@ -2892,6 +2909,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_retain() {
         let xs = [1, 2, 3, 4, 5, 6];
         let mut set: HashSet<i32> = xs.iter().copied().collect();
@@ -2903,6 +2921,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn test_extract_if() {
         {
             let mut set: HashSet<i32> = (0..8).collect();
@@ -2942,6 +2961,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn rehash_in_place() {
         let mut set = HashSet::new();
 
@@ -2962,6 +2982,7 @@ mod test_set {
     }
 
     #[test]
+    #[cfg(feature="ahash")]
     fn collect() {
         // At the time of writing, this hits the ZST case in from_base_index
         // (and without the `map`, it does not).
