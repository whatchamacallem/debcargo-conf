--- a/Cargo.toml
+++ b/Cargo.toml
@@ -74,12 +74,6 @@
 ]
 signal_support = ["signal-hook"]
 threading = []
-tracing = [
-    "profiling/profile-with-tracing",
-    "tracing-subscriber",
-    "tracing-chrome",
-    "dep:tracing",
-]
 
 [lib]
 name = "rav1e"
@@ -183,9 +177,6 @@
 [dependencies.paste]
 version = "1.0"
 
-[dependencies.profiling]
-version = "1"
-
 [dependencies.rayon]
 version = "1"
 
@@ -213,18 +204,6 @@
 version = "0.8"
 optional = true
 
-[dependencies.tracing]
-version = "0.1.40"
-optional = true
-
-[dependencies.tracing-chrome]
-version = "0.7.1"
-optional = true
-
-[dependencies.tracing-subscriber]
-version = "0.3.18"
-optional = true
-
 [dependencies.v_frame]
 version = "0.3.7"
 
--- a/src/activity.rs
+++ b/src/activity.rs
@@ -19,7 +19,6 @@
 }
 
 impl ActivityMask {
-  #[profiling::function]
   pub fn from_plane<T: Pixel>(luma_plane: &Plane<T>) -> ActivityMask {
     let PlaneConfig { width, height, .. } = luma_plane.cfg;
 
@@ -54,7 +53,6 @@
     ActivityMask { variances: variances.into_boxed_slice() }
   }
 
-  #[profiling::function]
   pub fn fill_scales(
     &self, bit_depth: usize, activity_scales: &mut Box<[DistortionScale]>,
   ) {
--- a/src/api/internal.rs
+++ b/src/api/internal.rs
@@ -334,7 +334,6 @@
     }
   }
 
-  #[profiling::function]
   pub fn send_frame(
     &mut self, mut frame: Option<Arc<Frame<T>>>,
     params: Option<FrameParameters>,
@@ -666,7 +665,6 @@
   /// `rec_buffer` and `lookahead_rec_buffer` on the `FrameInvariants`. This
   /// function must be called after every new `FrameInvariants` is initially
   /// computed.
-  #[profiling::function]
   fn compute_lookahead_motion_vectors(&mut self, output_frameno: u64) {
     let frame_data = self.frame_data.get(&output_frameno).unwrap();
 
@@ -876,7 +874,6 @@
       });
   }
 
-  #[profiling::function]
   pub fn compute_keyframe_placement(
     lookahead_frames: &[&Arc<Frame<T>>], keyframes_forced: &BTreeSet<u64>,
     keyframe_detector: &mut SceneChangeDetector<T>,
@@ -895,7 +892,6 @@
     *next_lookahead_frame += 1;
   }
 
-  #[profiling::function]
   pub fn compute_frame_invariants(&mut self) {
     while self.set_frame_properties(self.next_lookahead_output_frameno).is_ok()
     {
@@ -908,7 +904,6 @@
     }
   }
 
-  #[profiling::function]
   fn update_block_importances(
     fi: &FrameInvariants<T>, me_stats: &crate::me::FrameMEStats,
     frame: &Frame<T>, reference_frame: &Frame<T>, bit_depth: usize,
@@ -1071,7 +1066,6 @@
   }
 
   /// Computes the block importances for the current output frame.
-  #[profiling::function]
   fn compute_block_importances(&mut self) {
     // SEF don't need block importances.
     if self.frame_data[&self.output_frameno]
@@ -1295,7 +1289,6 @@
     }
   }
 
-  #[profiling::function]
   pub fn encode_show_existing_packet(
     &mut self, cur_output_frameno: u64,
   ) -> Result<Packet<T>, EncoderStatus> {
@@ -1331,7 +1324,6 @@
     self.finalize_packet(rec, source, input_frameno, frame_type, qp, enc_stats)
   }
 
-  #[profiling::function]
   pub fn encode_normal_packet(
     &mut self, cur_output_frameno: u64,
   ) -> Result<Packet<T>, EncoderStatus> {
@@ -1494,7 +1486,6 @@
     }
   }
 
-  #[profiling::function]
   pub fn receive_packet(&mut self) -> Result<Packet<T>, EncoderStatus> {
     if self.done_processing() {
       return Err(EncoderStatus::LimitReached);
@@ -1560,7 +1551,6 @@
     })
   }
 
-  #[profiling::function]
   fn garbage_collect(&mut self, cur_input_frameno: u64) {
     if cur_input_frameno == 0 {
       return;
--- a/src/api/lookahead.rs
+++ b/src/api/lookahead.rs
@@ -26,7 +26,6 @@
 pub(crate) const IMP_BLOCK_AREA_IN_MV_UNITS: i64 =
   IMP_BLOCK_SIZE_IN_MV_UNITS * IMP_BLOCK_SIZE_IN_MV_UNITS;
 
-#[profiling::function]
 pub(crate) fn estimate_intra_costs<T: Pixel>(
   temp_plane: &mut Plane<T>, frame: &Frame<T>, bit_depth: usize,
   cpu_feature_level: CpuFeatureLevel,
@@ -122,7 +121,6 @@
   intra_costs.into_boxed_slice()
 }
 
-#[profiling::function]
 pub(crate) fn estimate_importance_block_difference<T: Pixel>(
   frame: Arc<Frame<T>>, ref_frame: Arc<Frame<T>>,
 ) -> f64 {
@@ -178,7 +176,6 @@
   imp_block_costs as f64 / (w_in_imp_b * h_in_imp_b) as f64
 }
 
-#[profiling::function]
 pub(crate) fn estimate_inter_costs<T: Pixel>(
   frame: Arc<Frame<T>>, ref_frame: Arc<Frame<T>>, bit_depth: usize,
   mut config: EncoderConfig, sequence: Arc<Sequence>, buffer: RefMEStats,
@@ -267,7 +264,6 @@
   inter_costs as f64 / (w_in_imp_b * h_in_imp_b) as f64
 }
 
-#[profiling::function]
 pub(crate) fn compute_motion_vectors<T: Pixel>(
   fi: &mut FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) {
--- a/src/bin/muxer/ivf.rs
+++ b/src/bin/muxer/ivf.rs
@@ -36,7 +36,6 @@
     );
   }
 
-  #[profiling::function]
   fn write_frame(&mut self, pts: u64, data: &[u8], _frame_type: FrameType) {
     write_ivf_frame(&mut self.output, pts, data);
   }
--- a/src/bin/muxer/y4m.rs
+++ b/src/bin/muxer/y4m.rs
@@ -12,7 +12,6 @@
 use std::io::Write;
 use std::slice;
 
-#[profiling::function]
 pub fn write_y4m_frame<T: Pixel>(
   y4m_enc: &mut y4m::Encoder<Box<dyn Write + Send>>, rec: &Frame<T>,
   y4m_details: VideoDetails,
--- a/src/bin/rav1e.rs
+++ b/src/bin/rav1e.rs
@@ -73,7 +73,6 @@
     }
   }
 
-  #[profiling::function]
   fn read_frame<T: Pixel>(
     &mut self, ctx: &mut Context<T>, video_info: VideoDetails,
   ) -> Result<(), CliError> {
@@ -109,7 +108,6 @@
 
 // Encode and write a frame.
 // Returns frame information in a `Result`.
-#[profiling::function]
 fn process_frame<T: Pixel, D: Decoder>(
   ctx: &mut Context<T>, output_file: &mut dyn Muxer, source: &mut Source<D>,
   pass1file: Option<&mut File>, pass2file: Option<&mut File>,
--- a/src/bin/stats.rs
+++ b/src/bin/stats.rs
@@ -27,7 +27,6 @@
   pub enc_stats: EncoderStats,
 }
 
-#[profiling::function]
 pub fn build_frame_summary<T: Pixel>(
   packets: Packet<T>, bit_depth: usize, chroma_sampling: ChromaSampling,
   metrics_cli: MetricsEnabled,
--- a/src/cdef.rs
+++ b/src/cdef.rs
@@ -321,7 +321,6 @@
   }
 }
 
-#[profiling::function]
 pub fn cdef_analyze_superblock_range<T: Pixel>(
   fi: &FrameInvariants<T>, in_frame: &Frame<T>, blocks: &TileBlocks<'_>,
   sb_w: usize, sb_h: usize,
@@ -336,7 +335,6 @@
   ret
 }
 
-#[profiling::function]
 pub fn cdef_analyze_superblock<T: Pixel>(
   fi: &FrameInvariants<T>, in_frame: &Frame<T>, blocks: &TileBlocks<'_>,
   sbo: TileSuperBlockOffset,
@@ -397,7 +395,6 @@
 /// # Panics
 ///
 /// - If called with invalid parameters
-#[profiling::function]
 pub fn cdef_filter_superblock<T: Pixel>(
   fi: &FrameInvariants<T>, input: &Frame<T>, output: &mut TileMut<'_, T>,
   blocks: &TileBlocks<'_>, tile_sbo: TileSuperBlockOffset, cdef_index: u8,
@@ -593,7 +590,6 @@
 //   tile boundary), the filtering process ignores input pixels that
 //   don't exist.
 
-#[profiling::function]
 pub fn cdef_filter_tile<T: Pixel>(
   fi: &FrameInvariants<T>, input: &Frame<T>, tb: &TileBlocks,
   output: &mut TileMut<'_, T>,
--- a/src/context/block_unit.rs
+++ b/src/context/block_unit.rs
@@ -1123,7 +1123,6 @@
     }
   }
 
-  #[profiling::function]
   fn setup_mvref_list<T: Pixel>(
     &self, bo: TileBlockOffset, ref_frames: [RefType; 2],
     mv_stack: &mut ArrayVec<CandidateMV, 9>, bsize: BlockSize,
--- a/src/deblock.rs
+++ b/src/deblock.rs
@@ -1290,7 +1290,6 @@
 }
 
 // Deblocks all edges, vertical and horizontal, in a single plane
-#[profiling::function]
 pub fn deblock_plane<T: Pixel>(
   deblock: &DeblockState, p: &mut PlaneRegionMut<T>, pli: usize,
   blocks: &TileBlocks, crop_w: usize, crop_h: usize, bd: usize,
@@ -1540,7 +1539,6 @@
 }
 
 // Deblocks all edges in all planes of a frame
-#[profiling::function]
 pub fn deblock_filter_frame<T: Pixel>(
   deblock: &DeblockState, tile: &mut TileMut<T>, blocks: &TileBlocks,
   crop_w: usize, crop_h: usize, bd: usize, planes: usize,
@@ -1616,7 +1614,6 @@
   level
 }
 
-#[profiling::function]
 pub fn deblock_filter_optimize<T: Pixel, U: Pixel>(
   fi: &FrameInvariants<T>, rec: &Tile<U>, input: &Tile<U>,
   blocks: &TileBlocks, crop_w: usize, crop_h: usize,
--- a/src/encoder.rs
+++ b/src/encoder.rs
@@ -562,7 +562,6 @@
 }
 
 impl SegmentationState {
-  #[profiling::function]
   pub fn update_threshold(&mut self, base_q_idx: u8, bd: usize) {
     let base_ac_q = ac_q(base_q_idx, 0, bd).get() as u64;
     let real_ac_q = ArrayVec::<_, MAX_SEGMENTS>::from_iter(
@@ -740,7 +739,6 @@
 
   // Assumes that we have already computed activity scales and distortion scales
   // Returns -0.5 log2(mean(scale))
-  #[profiling::function]
   pub fn compute_spatiotemporal_scores(&mut self) -> i64 {
     let mut scores = self
       .distortion_scales
@@ -766,7 +764,6 @@
 
   // Assumes that we have already computed distortion_scales
   // Returns -0.5 log2(mean(scale))
-  #[profiling::function]
   pub fn compute_temporal_scores(&mut self) -> i64 {
     let inv_mean = DistortionScale::inv_mean(&self.distortion_scales);
     for scale in self.distortion_scales.iter_mut() {
@@ -1663,7 +1660,6 @@
 /// # Panics
 ///
 /// - If the block size is invalid for subsampling
-#[profiling::function]
 pub fn motion_compensate<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, luma_mode: PredictionMode, ref_frames: [RefType; 2],
@@ -1892,7 +1888,6 @@
   }
 }
 
-#[profiling::function]
 pub fn encode_block_pre_cdef<T: Pixel, W: Writer>(
   seq: &Sequence, ts: &TileStateMut<'_, T>, cw: &mut ContextWriter, w: &mut W,
   bsize: BlockSize, tile_bo: TileBlockOffset, skip: bool,
@@ -1933,7 +1928,6 @@
 ///
 /// - If chroma and luma do not match for inter modes
 /// - If an invalid motion vector is found
-#[profiling::function]
 pub fn encode_block_post_cdef<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w: &mut W, luma_mode: PredictionMode,
@@ -2563,7 +2557,6 @@
   (partition_has_coeff, tx_dist)
 }
 
-#[profiling::function]
 pub fn encode_block_with_modes<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w_pre_cdef: &mut W, w_post_cdef: &mut W,
@@ -2630,7 +2623,6 @@
   );
 }
 
-#[profiling::function]
 fn encode_partition_bottomup<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w_pre_cdef: &mut W, w_post_cdef: &mut W,
@@ -3233,7 +3225,6 @@
   cdf.unwrap_or_else(|| CDFContext::new(fi.base_q_idx))
 }
 
-#[profiling::function]
 fn encode_tile_group<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) -> Vec<u8> {
@@ -3372,7 +3363,6 @@
   pub w_post_cdef: WriterBase<WriterRecorder>,
 }
 
-#[profiling::function]
 fn check_lf_queue<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w: &mut WriterBase<WriterEncoder>,
@@ -3464,7 +3454,6 @@
   }
 }
 
-#[profiling::function]
 fn encode_tile<'a, T: Pixel>(
   fi: &FrameInvariants<T>, ts: &'a mut TileStateMut<'_, T>,
   fc: &'a mut CDFContext, blocks: &'a mut TileBlocksMut<'a>,
@@ -3689,7 +3678,6 @@
 /// # Panics
 ///
 /// - If the frame packets cannot be written
-#[profiling::function]
 pub fn encode_show_existing_frame<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) -> Vec<u8> {
@@ -3764,7 +3752,6 @@
 /// # Panics
 ///
 /// - If the frame packets cannot be written
-#[profiling::function]
 pub fn encode_frame<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) -> Vec<u8> {
--- a/src/lrf.rs
+++ b/src/lrf.rs
@@ -526,7 +526,6 @@
 impl<T: Pixel> ExactSizeIterator for HorzPaddedIter<'_, T> {}
 impl<T: Pixel> FusedIterator for HorzPaddedIter<'_, T> {}
 
-#[profiling::function]
 pub fn setup_integral_image<T: Pixel>(
   integral_image_buffer: &mut IntegralImageBuffer,
   integral_image_stride: usize, crop_w: usize, crop_h: usize, stripe_w: usize,
@@ -626,7 +625,6 @@
   }
 }
 
-#[profiling::function]
 pub fn sgrproj_stripe_filter<T: Pixel, U: Pixel>(
   set: u8, xqd: [i8; 2], fi: &FrameInvariants<T>,
   integral_image_buffer: &IntegralImageBuffer, integral_image_stride: usize,
@@ -843,7 +841,6 @@
 
 // Input params follow the same rules as sgrproj_stripe_filter.
 // Inputs are relative to the colocated slice views.
-#[profiling::function]
 pub fn sgrproj_solve<T: Pixel>(
   set: u8, fi: &FrameInvariants<T>,
   integral_image_buffer: &IntegralImageBuffer, input: &PlaneRegion<'_, T>,
@@ -1095,7 +1092,6 @@
   }
 }
 
-#[profiling::function]
 fn wiener_stripe_filter<T: Pixel>(
   coeffs: [[i8; 3]; 2], fi: &FrameInvariants<T>, crop_w: usize, crop_h: usize,
   stripe_w: usize, stripe_h: usize, stripe_x: usize, stripe_y: isize,
@@ -1478,7 +1474,6 @@
     }
   }
 
-  #[profiling::function]
   pub fn lrf_filter_frame<T: Pixel>(
     &mut self, out: &mut Frame<T>, pre_cdef: &Frame<T>,
     fi: &FrameInvariants<T>,
--- a/src/me.rs
+++ b/src/me.rs
@@ -382,7 +382,6 @@
   }
 }
 
-#[profiling::function]
 fn get_subset_predictors(
   tile_bo: TileBlockOffset, tile_me_stats: &TileMEStats<'_>,
   frame_ref_opt: Option<ReadGuardMEStats<'_>>, ref_frame_id: usize,
@@ -689,7 +688,6 @@
   }
 }
 
-#[profiling::function]
 fn full_pixel_me<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &TileStateMut<'_, T>,
   org_region: &PlaneRegion<T>, p_ref: &Plane<T>, tile_bo: TileBlockOffset,
@@ -880,7 +878,6 @@
   );
 }
 
-#[profiling::function]
 fn get_best_predictor<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, predictors: &[MotionVector], bit_depth: usize,
@@ -951,7 +948,6 @@
 /// For each step size, candidate motion vectors are examined for improvement
 /// to the current search location. The search location is moved to the best
 /// candidate (if any). This is repeated until the search location stops moving.
-#[profiling::function]
 fn fullpel_diamond_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, current: &mut MotionSearchResult, bit_depth: usize,
@@ -1051,7 +1047,6 @@
 ///
 /// `current` provides the initial search location and serves as
 /// the output for the final search results.
-#[profiling::function]
 fn hexagon_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, current: &mut MotionSearchResult, bit_depth: usize,
@@ -1166,7 +1161,6 @@
 /// the output for the final search results.
 ///
 /// `me_range` parameter determines how far these stages can search.
-#[profiling::function]
 fn uneven_multi_hex_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, current: &mut MotionSearchResult, bit_depth: usize,
@@ -1307,7 +1301,6 @@
 /// For each step size, candidate motion vectors are examined for improvement
 /// to the current search location. The search location is moved to the best
 /// candidate (if any). This is repeated until the search location stops moving.
-#[profiling::function]
 fn subpel_diamond_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   _p_ref: &Plane<T>, bit_depth: usize, pmv: [MotionVector; 2], lambda: u32,
@@ -1460,7 +1453,6 @@
   MVCandidateRD { cost: 256 * sad as u64 + rate as u64 * lambda as u64, sad }
 }
 
-#[profiling::function]
 fn full_search<T: Pixel>(
   fi: &FrameInvariants<T>, x_lo: isize, x_hi: isize, y_lo: isize, y_hi: isize,
   w: usize, h: usize, org_region: &PlaneRegion<T>, p_ref: &Plane<T>,
--- a/src/rate.rs
+++ b/src/rate.rs
@@ -720,7 +720,6 @@
   }
 
   // TODO: Separate quantizers for Cb and Cr.
-  #[profiling::function]
   pub(crate) fn select_qi<T: Pixel>(
     &self, ctx: &ContextInner<T>, output_frameno: u64, fti: usize,
     maybe_prev_log_base_q: Option<i64>, log_isqrt_mean_scale: i64,
@@ -1069,7 +1068,6 @@
     (log_base_q, log_q)
   }
 
-  #[profiling::function]
   pub fn update_state(
     &mut self, bits: i64, fti: usize, show_frame: bool, log_target_q: i64,
     trial: bool, droppable: bool,
--- a/src/rdo.rs
+++ b/src/rdo.rs
@@ -812,7 +812,6 @@
 }
 
 #[inline]
-#[profiling::function]
 fn luma_chroma_mode_rdo<T: Pixel>(
   luma_mode: PredictionMode, fi: &FrameInvariants<T>, bsize: BlockSize,
   tile_bo: TileBlockOffset, ts: &mut TileStateMut<'_, T>,
@@ -959,7 +958,6 @@
 ///
 /// - If the best RD found is negative.
 ///   This should never happen and indicates a development error.
-#[profiling::function]
 pub fn rdo_mode_decision<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, bsize: BlockSize, tile_bo: TileBlockOffset,
@@ -1117,7 +1115,6 @@
   }
 }
 
-#[profiling::function]
 fn inter_frame_rdo_mode_decision<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, bsize: BlockSize, tile_bo: TileBlockOffset,
@@ -1390,7 +1387,6 @@
   best
 }
 
-#[profiling::function]
 fn intra_frame_rdo_mode_decision<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, bsize: BlockSize, tile_bo: TileBlockOffset,
@@ -1589,7 +1585,6 @@
 /// # Panics
 ///
 /// - If the block size is invalid for subsampling.
-#[profiling::function]
 pub fn rdo_cfl_alpha<T: Pixel>(
   ts: &mut TileStateMut<'_, T>, tile_bo: TileBlockOffset, bsize: BlockSize,
   luma_tx_size: TxSize, fi: &FrameInvariants<T>,
@@ -1945,7 +1940,6 @@
 ///
 /// - If the best RD found is negative.
 ///   This should never happen, and indicates a development error.
-#[profiling::function]
 pub fn rdo_partition_decision<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w_pre_cdef: &mut W, w_post_cdef: &mut W,
@@ -2023,7 +2017,6 @@
   }
 }
 
-#[profiling::function]
 fn rdo_loop_plane_error<T: Pixel>(
   base_sbo: TileSuperBlockOffset, offset_sbo: TileSuperBlockOffset,
   sb_w: usize, sb_h: usize, fi: &FrameInvariants<T>, ts: &TileStateMut<'_, T>,
@@ -2100,7 +2093,6 @@
 /// # Panics
 ///
 /// - If both CDEF and LRF are disabled.
-#[profiling::function]
 pub fn rdo_loop_decision<T: Pixel, W: Writer>(
   base_sbo: TileSuperBlockOffset, fi: &FrameInvariants<T>,
   ts: &mut TileStateMut<'_, T>, cw: &mut ContextWriter, w: &mut W,
--- a/src/segmentation.rs
+++ b/src/segmentation.rs
@@ -19,7 +19,6 @@
 
 pub const MAX_SEGMENTS: usize = 8;
 
-#[profiling::function]
 pub fn segmentation_optimize<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>,
 ) {
@@ -159,7 +158,6 @@
   fs.segmentation.update_threshold(fi.base_q_idx, fi.config.bit_depth);
 }
 
-#[profiling::function]
 pub fn select_segment<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &TileStateMut<'_, T>, tile_bo: TileBlockOffset,
   bsize: BlockSize, skip: bool,
