--- a/Cargo.toml
+++ b/Cargo.toml
@@ -28,24 +28,20 @@
 name = "derive_more"
 proc-macro = true
 
-[[test]]
-name = "no_std"
-path = "tests/no_std.rs"
-required-features = ["no_std"]
 [dependencies.lazy_static]
 version = "1.3"
 
 [dependencies.proc-macro2]
-version = "0.4"
+version = "1"
 
 [dependencies.quote]
-version = "0.6"
+version = "1"
 
 [dependencies.regex]
 version = "1"
 
 [dependencies.syn]
-version = "0.15"
+version = "1"
 features = ["extra-traits"]
 [build-dependencies.rustc_version]
 version = "0.2"
--- a/src/display.rs
+++ b/src/display.rs
@@ -7,9 +7,8 @@
 use regex::Regex;
 use syn::{
     parse::{Error, Result},
-    punctuated::Pair,
     spanned::Spanned,
-    Attribute, Data, DeriveInput, Fields, Lit, Meta, MetaNameValue, NestedMeta, Type,
+    Attribute, Data, DeriveInput, Fields, Lit, Meta, MetaNameValue, NestedMeta, Path, Type,
 };
 use utils::{add_extra_where_clauses, get_import_root};
 
@@ -123,8 +122,14 @@
     fn find_meta(&self, attrs: &[Attribute]) -> Result<Option<Meta>> {
         let mut it = attrs
             .iter()
-            .filter_map(Attribute::interpret_meta)
-            .filter(|m| m.name() == self.trait_attr);
+            .filter_map(|m| m.parse_meta().ok())
+            .filter(|m| {
+                if let Some(ident) = m.path().segments.first().map(|p| &p.ident) {
+                    ident == self.trait_attr
+                } else {
+                    false
+                }
+            });
 
         let meta = it.next();
         if it.next().is_some() {
@@ -141,10 +146,10 @@
 
         let fmt = match &list.nested[0] {
             NestedMeta::Meta(Meta::NameValue(MetaNameValue {
-                ident,
+                path,
                 lit: Lit::Str(s),
                 ..
-            })) if ident == "fmt" => s,
+            })) if path.segments.first().expect("path shouldn't be empty").ident == "fmt" => s,
             _ => return Err(Error::new(list.nested[0].span(), self.get_proper_syntax())),
         };
 
@@ -154,8 +159,8 @@
             .skip(1) // skip fmt = "..."
             .try_fold(TokenStream::new(), |args, arg| {
                 let arg = match arg {
-                    NestedMeta::Literal(Lit::Str(s)) => s,
-                    NestedMeta::Meta(Meta::Word(i)) => {
+                    NestedMeta::Lit(Lit::Str(s)) => s,
+                    NestedMeta::Meta(Meta::Path(i)) => {
                         return Ok(quote_spanned!(list.span()=> #args #i,));
                     }
                     _ => return Err(Error::new(arg.span(), self.get_proper_syntax())),
@@ -301,11 +306,12 @@
                 if !self.has_type_param_in(field) {
                     return None;
                 }
-                let ident = field
+                let path: Path = field
                     .ident
                     .clone()
-                    .unwrap_or_else(|| Ident::new(&format!("_{}", i), Span::call_site()));
-                Some((ident, field.ty.clone()))
+                    .unwrap_or_else(|| Ident::new(&format!("_{}", i), Span::call_site()))
+                    .into();
+                Some((path, field.ty.clone()))
             })
             .collect();
         if fields_type_params.is_empty() {
@@ -323,10 +329,10 @@
             .skip(1) // skip fmt = "..."
             .enumerate()
             .filter_map(|(i, arg)| match arg {
-                NestedMeta::Literal(Lit::Str(ref s)) => {
+                NestedMeta::Lit(Lit::Str(ref s)) => {
                     syn::parse_str(&s.value()).ok().map(|id| (i, id))
                 }
-                NestedMeta::Meta(Meta::Word(ref id)) => Some((i, id.clone())),
+                NestedMeta::Meta(Meta::Path(ref id)) => Some((i, id.clone())),
                 // This one has been checked already in get_meta_fmt() method.
                 _ => unreachable!(),
             })
@@ -336,10 +342,10 @@
         }
         let fmt_string = match &list.nested[0] {
             NestedMeta::Meta(Meta::NameValue(MetaNameValue {
-                ident,
+                path,
                 lit: Lit::Str(s),
                 ..
-            })) if ident == "fmt" => s.value(),
+            })) if path.segments.first().expect("path shouldn't be empty").ident == "fmt" => s.value(),
             // This one has been checked already in get_meta_fmt() method.
             _ => unreachable!(),
         };
@@ -397,8 +403,7 @@
     fn has_type_param_in(&self, field: &syn::Field) -> bool {
         if let Type::Path(ref ty) = field.ty {
             return match ty.path.segments.first() {
-                Some(Pair::Punctuated(ref t, _)) => self.type_params.contains(&t.ident),
-                Some(Pair::End(ref t)) => self.type_params.contains(&t.ident),
+                Some(t) => self.type_params.contains(&t.ident),
                 _ => false,
             };
         }
--- a/src/mul_assign_like.rs
+++ b/src/mul_assign_like.rs
@@ -36,7 +36,8 @@
     };
 
     let scalar_ident = &Ident::new("__RhsT", Span::call_site());
-    let tys: &HashSet<_> = &get_field_types_iter(&fields).collect();
+    let tys = get_field_types_iter(&fields).collect::<HashSet<_>>();
+    let tys = tys.iter();
     let scalar_iter = iter::repeat(scalar_ident);
     let trait_path_iter = iter::repeat(trait_path);
 
--- a/src/mul_like.rs
+++ b/src/mul_like.rs
@@ -38,13 +38,13 @@
     };
 
     let scalar_ident = &Ident::new("__RhsT", Span::call_site());
-    let tys: &HashSet<_> = &get_field_types_iter(&fields).collect();
-    let tys2 = tys;
+    let tys = get_field_types_iter(&fields).collect::<HashSet<_>>();
+    let tys = tys.iter();
     let scalar_iter = iter::repeat(scalar_ident);
     let trait_path_iter = iter::repeat(trait_path);
 
     let type_where_clauses = quote! {
-        where #(#tys: #trait_path_iter<#scalar_iter, Output=#tys2>),*
+        where #(#tys: #trait_path_iter<#scalar_iter, Output=#tys>),*
     };
 
     let new_generics =
