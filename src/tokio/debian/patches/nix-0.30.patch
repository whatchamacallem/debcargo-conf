Index: tokio/Cargo.toml
===================================================================
--- tokio.orig/Cargo.toml
+++ tokio/Cargo.toml
@@ -844,7 +844,7 @@ optional = true
 version = "0.2.168"
 
 [target."cfg(unix)".dev-dependencies.nix]
-version = "0.29.0"
+version = "0.30.0"
 features = [
     "aio",
     "fs",
Index: tokio/tests/io_async_fd.rs
===================================================================
--- tokio.orig/tests/io_async_fd.rs
+++ tokio/tests/io_async_fd.rs
@@ -2,6 +2,7 @@
 #![cfg(all(unix, feature = "full"))]
 
 use std::os::unix::io::{AsRawFd, RawFd};
+use std::os::fd::BorrowedFd;
 use std::sync::{
     atomic::{AtomicBool, Ordering},
     Arc,
@@ -69,7 +70,7 @@ impl AsRawFd for FileDescriptor {
 
 impl Read for &FileDescriptor {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        read(self.fd.as_raw_fd(), buf).map_err(io::Error::from)
+        read(&self.fd, buf).map_err(io::Error::from)
     }
 }
 
@@ -102,6 +103,7 @@ impl Write for FileDescriptor {
 fn set_nonblocking(fd: RawFd) {
     use nix::fcntl::{OFlag, F_GETFL, F_SETFL};
 
+    let fd = unsafe { BorrowedFd::borrow_raw(fd) };
     let flags = nix::fcntl::fcntl(fd, F_GETFL).expect("fcntl(F_GETFD)");
 
     if flags < 0 {
Index: tokio/tests/net_unix_pipe.rs
===================================================================
--- tokio.orig/tests/net_unix_pipe.rs
+++ tokio/tests/net_unix_pipe.rs
@@ -10,6 +10,7 @@ use std::fs::File;
 use std::io;
 use std::os::unix::fs::OpenOptionsExt;
 use std::os::unix::io::AsRawFd;
+use std::os::fd::BorrowedFd;
 use std::path::{Path, PathBuf};
 
 /// Helper struct which will clean up temporary files once dropped.
@@ -278,7 +279,7 @@ async fn from_file_detects_wrong_access_
 }
 
 fn is_nonblocking<T: AsRawFd>(fd: &T) -> io::Result<bool> {
-    let flags = nix::fcntl::fcntl(fd.as_raw_fd(), nix::fcntl::F_GETFL)?;
+    let flags = nix::fcntl::fcntl(unsafe { BorrowedFd::borrow_raw(fd.as_raw_fd()) }, nix::fcntl::F_GETFL)?;
     Ok((flags & libc::O_NONBLOCK) != 0)
 }
 
