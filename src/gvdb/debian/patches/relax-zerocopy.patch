From d7e1458d5ef9284d7b10465c267ec5607cfe4c4e Mon Sep 17 00:00:00 2001
From: NoisyCoil <noisycoil@tutanota.com>
Date: Mon, 20 Jan 2025 22:14:00 +0100
Subject: [PATCH] Downgrade zerocopy to v0.7

Revert 721e155d7e31 and 2e152eb589b8
---
 Cargo.toml            |  2 +-
 src/read/error.rs     | 28 +++++++++-------------------
 src/read/file.rs      |  2 +-
 src/read/hash.rs      | 25 ++++++++++++-------------
 src/read/hash_item.rs |  4 ++--
 src/read/header.rs    | 14 +++++++-------
 src/read/pointer.rs   |  4 ++--
 src/write/file.rs     |  2 +-
 8 files changed, 35 insertions(+), 46 deletions(-)

--- a/Cargo.toml
+++ b/Cargo.toml
@@ -78,7 +78,7 @@
 optional = true
 
 [dependencies.zerocopy]
-version = "0.8"
+version = "0.7"
 features = ["derive"]
 
 [dependencies.zvariant]
--- a/src/read/error.rs
+++ b/src/read/error.rs
@@ -34,16 +34,6 @@
     }
 }
 
-impl<Src, Dst: ?Sized> From<zerocopy::CastError<Src, Dst>> for Error {
-    fn from(value: zerocopy::CastError<Src, Dst>) -> Self {
-        match value {
-            zerocopy::ConvertError::Alignment(_) => Self::DataAlignment,
-            zerocopy::ConvertError::Size(_) => Self::DataOffset,
-            zerocopy::ConvertError::Validity(_infallible) => unreachable!(),
-        }
-    }
-}
-
 impl std::error::Error for Error {}
 
 impl From<FromUtf8Error> for Error {
@@ -117,7 +107,7 @@
     use crate::read::{Error, Header, Pointer};
     use matches::assert_matches;
     use std::num::TryFromIntError;
-    use zerocopy::{CastError, FromBytes, IntoBytes};
+    use zerocopy::{AsBytes, FromBytes};
 
     #[test]
     fn from() {
@@ -146,23 +136,23 @@
         let to_transmute = Header::new(false, 0, Pointer::NULL);
         let mut bytes = to_transmute.as_bytes().to_vec();
         bytes.extend_from_slice(b"fail");
-        let res = Header::ref_from_bytes(&bytes);
-        assert_matches!(res, Err(CastError::Size(_))); // unexpected trailing bytes
+        let res = Header::ref_from(&bytes);
+        assert_eq!(res, None); // unexpected trailing bytes
 
         let to_transmute = Header::new(false, 0, Pointer::NULL);
         let mut bytes = to_transmute.as_bytes().to_vec();
         bytes.remove(bytes.len() - 1);
-        let res = Header::ref_from_bytes(&bytes);
-        assert_matches!(res, Err(CastError::Size(_))); //Missing 1 byte
+        let res = Header::ref_from(&bytes);
+        assert_eq!(res, None); //Missing 1 byte
 
         let to_transmute = Header::new(false, 0, Pointer::NULL);
         let mut bytes = b"unalign".to_vec();
         bytes.extend_from_slice(to_transmute.as_bytes());
-        let res = Header::ref_from_bytes(&bytes[7..]);
-        assert_matches!(res, Err(CastError::Alignment(_))); // Unaligned
+        let res = Header::ref_from(&bytes[7..]);
+        assert_eq!(res, None); // Unaligned
 
         let bytes = vec![0u8; 5];
-        let res = <[Header]>::ref_from_bytes(&bytes);
-        assert_matches!(res, Err(CastError::Size(_))); // Invalid size
+        let res = Header::slice_from(&bytes);
+        assert_eq!(res, None); // Invalid size
     }
 }
--- a/src/read/file.rs
+++ b/src/read/file.rs
@@ -218,7 +218,7 @@
     use matches::assert_matches;
     #[allow(unused_imports)]
     use pretty_assertions::{assert_eq, assert_ne, assert_str_eq};
-    use zerocopy::IntoBytes;
+    use zerocopy::AsBytes;
 
     #[test]
     fn test_file_1() {
--- a/src/read/hash.rs
+++ b/src/read/hash.rs
@@ -4,7 +4,7 @@
 use std::fmt::{Debug, Formatter};
 use std::mem::size_of;
 use zerocopy::byteorder::little_endian::U32 as u32le;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
+use zerocopy::{AsBytes, FromBytes, FromZeroes};
 
 use super::{File, HashItemType};
 use crate::variant::{DecodeValue, DecodeVariant, VariantType};
@@ -21,7 +21,7 @@
 /// +-------+-----------------------+
 /// ```
 #[repr(C)]
-#[derive(Copy, Clone, PartialEq, Eq, Immutable, KnownLayout, FromBytes, IntoBytes)]
+#[derive(Copy, Clone, PartialEq, Eq, FromBytes, FromZeroes, AsBytes)]
 pub struct HashHeader {
     n_bloom_words: u32,
     n_buckets: u32,
@@ -43,8 +43,7 @@
     /// Read the hash table header from `data`
     pub fn try_from_bytes(data: &[u8]) -> Result<&Self> {
         HashHeader::ref_from_prefix(data)
-            .map(|(header, _remain)| header)
-            .map_err(|_| Error::Data("Invalid hash table header".to_string()))
+            .ok_or(Error::Data("Invalid hash table header".to_string()))
     }
 
     /// Number of bloom words in the hash table header
@@ -68,8 +67,8 @@
         let offset = self.bloom_words_offset();
         let len = self.bloom_words_len();
 
-        Ok(if len == 0 {
-            &[]
+        if len == 0 {
+            Ok(&[])
         } else {
             let words_data = data.get(offset..(offset + len)).ok_or_else(|| {
                 Error::Data(format!(
@@ -79,8 +78,8 @@
                 ))
             })?;
 
-            <[u32le]>::ref_from_bytes(words_data)?
-        })
+            u32le::slice_from(words_data).ok_or(Error::DataOffset)
+        }
     }
 
     /// The offset of the hash buckets section
@@ -103,8 +102,8 @@
         let offset = self.buckets_offset();
         let len = self.buckets_len();
 
-        Ok(if len == 0 {
-            &[]
+        if len == 0 {
+            Ok(&[])
         } else {
             let buckets_data = data.get(offset..(offset + len)).ok_or_else(|| {
                 Error::Data(format!(
@@ -114,8 +113,8 @@
                 ))
             })?;
 
-            <[u32le]>::ref_from_bytes(buckets_data)?
-        })
+            u32le::slice_from(buckets_data).ok_or(Error::DataOffset)
+        }
     }
 
     /// The start of the hash items region
@@ -139,7 +138,7 @@
             )))
         } else {
             let items_data = data.get(offset..(offset + len)).unwrap_or_default();
-            Ok(<[HashItem]>::ref_from_bytes(items_data)?)
+            HashItem::slice_from(items_data).ok_or(Error::DataOffset)
         }
     }
 }
--- a/src/read/hash_item.rs
+++ b/src/read/hash_item.rs
@@ -1,7 +1,7 @@
 use crate::read::error::{Error, Result};
 use crate::read::pointer::Pointer;
 use std::fmt::{Display, Formatter};
-use zerocopy::{FromBytes, Immutable, IntoBytes};
+use zerocopy::{AsBytes, FromBytes, FromZeroes};
 
 #[derive(PartialEq, Eq, Debug)]
 pub enum HashItemType {
@@ -71,7 +71,7 @@
 /// +-------+----------------------+
 /// ```
 #[repr(C)]
-#[derive(Copy, Clone, Immutable, FromBytes, IntoBytes)]
+#[derive(Copy, Clone, FromZeroes, FromBytes, AsBytes)]
 pub struct HashItem {
     hash_value: u32,
     parent: u32,
--- a/src/read/header.rs
+++ b/src/read/header.rs
@@ -1,6 +1,6 @@
 use crate::read::error::{Error, Result};
 use crate::read::pointer::Pointer;
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
+use zerocopy::{AsBytes, FromBytes, FromZeroes};
 
 // This is just a string, but it is stored in the byteorder of the file
 // Default byteorder is little endian, but the format supports big endian as well
@@ -44,7 +44,7 @@
 ///
 /// Points to the root hash table within the file.
 #[repr(C)]
-#[derive(Copy, Clone, PartialEq, Eq, Debug, Immutable, KnownLayout, FromBytes, IntoBytes)]
+#[derive(Copy, Clone, PartialEq, Eq, Debug, FromZeroes, FromBytes, AsBytes)]
 pub struct Header {
     signature: [u32; 2],
     version: u32,
@@ -58,8 +58,8 @@
     /// Returns [`Error::DataOffset`]` if the header doesn't fit, and [`Error::Data`] if the header
     /// is invalid.
     pub fn try_from_bytes(data: &[u8]) -> Result<Self> {
-        let (header, _) = Header::read_from_prefix(data)
-            .map_err(|_| Error::Data("Invalid GVDB header".to_string()))?;
+        let header =
+            Header::read_from_prefix(data).ok_or(Error::Data("Invalid GVDB header".to_string()))?;
 
         if !header.header_valid() {
             return Err(Error::Data(
@@ -154,7 +154,7 @@
 #[cfg(test)]
 mod test {
     use super::*;
-    use zerocopy::IntoBytes;
+    use zerocopy::AsBytes;
 
     #[test]
     fn derives() {
@@ -168,13 +168,13 @@
         let header = Header::new(false, 123, Pointer::NULL);
         assert!(!header.is_byteswap().unwrap());
         let data = header.as_bytes();
-        let parsed_header = Header::ref_from_bytes(data).unwrap();
+        let parsed_header = Header::ref_from(data).unwrap();
         assert!(!parsed_header.is_byteswap().unwrap());
 
         let header = Header::new(true, 0, Pointer::NULL);
         assert!(header.is_byteswap().unwrap());
         let data = header.as_bytes();
-        let parsed_header = Header::ref_from_bytes(data).unwrap();
+        let parsed_header = Header::ref_from(data).unwrap();
         assert!(parsed_header.is_byteswap().unwrap());
     }
 }
--- a/src/read/pointer.rs
+++ b/src/read/pointer.rs
@@ -1,4 +1,4 @@
-use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};
+use zerocopy::{AsBytes, FromBytes, FromZeroes};
 
 /// A pointer internal to the GVDB file.
 ///
@@ -8,7 +8,7 @@
 /// It is possible to retrieve the bytes stored at this pointer by using
 /// [`File::dereference()`](crate::read::File::dereference).
 #[repr(C)]
-#[derive(Copy, Clone, PartialEq, Eq, Immutable, KnownLayout, FromBytes, IntoBytes)]
+#[derive(Copy, Clone, PartialEq, Eq, AsBytes, FromBytes, FromZeroes)]
 pub struct Pointer {
     start: u32,
     end: u32,
--- a/src/write/file.rs
+++ b/src/write/file.rs
@@ -8,7 +8,7 @@
 use std::collections::{HashMap, VecDeque};
 use std::io::Write;
 use std::mem::size_of;
-use zerocopy::IntoBytes;
+use zerocopy::AsBytes;
 
 /// Create hash tables for use in GVDB files
 ///
