diff --git a/src/lib.md b/src/lib.md
index 841cf22..0fdbe63 100644
--- a/src/lib.md
+++ b/src/lib.md
@@ -8,7 +8,7 @@ Note that the derive macro _does not support unions_. You have to manually imple
 
 Deriving [`GetSize`] for a struct:
 
-```rust
+```ignore
 use get_size2::GetSize;
 
 #[derive(GetSize)]
@@ -29,7 +29,7 @@ fn main() {
 
 Deriving [`GetSize`] for an enum:
 
-```rust
+```ignore
 use get_size2::GetSize;
 
 #[derive(GetSize)]
@@ -67,7 +67,7 @@ fn main() {
 
 The derive macro does also work with generics. The generated trait implementation will by default require all generic types to implement [`GetSize`] themselves, but this [can be changed](#ignoring-certain-generic-types).
 
-```rust
+```ignore
 use get_size2::GetSize;
 
 #[derive(GetSize)]
@@ -115,7 +115,7 @@ You can tell the derive macro to ignore certain struct fields by adding the `ign
 
 The idiomatic use case for this helper is if you use shared ownership and do not want your data to be counted twice.
 
-```rust
+```ignore
 use std::sync::Arc;
 use get_size2::GetSize;
 
@@ -157,7 +157,7 @@ But you may also use this as a band aid, if a certain struct fields type does no
 
 Be aware though that this will result in an implementation which will return incorrect results, unless the heap size of that type is indeed always zero and can thus be ignored. It is therefor advisable to use one of the next two helper options instead.
 
-```rust
+```ignore
 use get_size2::GetSize;
 
 // Does not implement GetSize!
@@ -192,7 +192,7 @@ fn main() {
 
 In same cases you may be dealing with external types which allocate a fixed amount of bytes at the heap. In this case you may use the `size` attribute to always account the given field with a fixed value.
 
-```rust
+```ignore
 use get_size2::GetSize;
 #
 # struct Buffer1024 {}
@@ -228,7 +228,7 @@ The latter is especially useful if you can make use of a certain trait to calcul
 
 Note that unlike in other crates, the name of the function to be called is **not** encapsulated by double-quotes ("), but rather given directly.
 
-```rust
+```ignore
 use get_size2::GetSize;
 #
 # type ExternalVecAlike<T> = Vec<T>;
@@ -265,7 +265,7 @@ fn main() {
 
 If your struct uses generics, but the fields at which they are stored are ignored or get handled by helpers because the generic does not implement [`GetSize`], you will have to mark these generics with a special struct level `ignore` attribute. Otherwise the derived [`GetSize`] implementation would still require these generics to implement [`GetSize`], even through there is no need for it.
 
-```rust
+```ignore
 use get_size2::GetSize;
 
 #[derive(GetSize)]
