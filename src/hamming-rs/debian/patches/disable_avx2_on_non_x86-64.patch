--- a/src/lib.rs
+++ b/src/lib.rs
@@ -62,6 +62,7 @@
     assert_eq!(x.len(), y.len());
     unsafe {
         // from benchmarks, it seems avx2 implementation is slower than naive for very small vectors
+        #[cfg(target_arch = "x86_64")]
         if is_x86_feature_detected!("avx2") && x.len() >= 1024 {
             return lib_avx2::distance_vect(x, y);
         }
@@ -74,6 +75,7 @@
 /// Uses highly optimized avx2 version if available
 pub fn weight(x: &[u8]) -> u64 {
     unsafe {
+        #[cfg(target_arch = "x86_64")]
         if is_x86_feature_detected!("avx2") {
             return lib_avx2::weight_vect(x);
         }
--- a/src/lib_avx2.rs
+++ b/src/lib_avx2.rs
@@ -1,3 +1,4 @@
+#[cfg(target_arch = "x86_64")]
 use std::arch::x86_64::{
     __m256i, _mm256_add_epi64, _mm256_add_epi8, _mm256_and_si256, _mm256_extract_epi64,
     _mm256_or_si256, _mm256_sad_epu8, _mm256_set1_epi8, _mm256_setr_epi8, _mm256_setzero_si256,
@@ -8,6 +9,7 @@
 
 use crate::distance_naive;
 
+#[cfg(target_arch = "x86_64")]
 #[target_feature(enable = "avx2")]
 unsafe fn carry_save_adder(h: *mut __m256i, l: *mut __m256i, a: __m256i, b: __m256i, c: __m256i) {
     let u = _mm256_xor_si256(a, b);
@@ -15,6 +17,7 @@
     *l = _mm256_xor_si256(u, c);
 }
 
+#[cfg(target_arch = "x86_64")]
 #[target_feature(enable = "avx2")]
 unsafe fn count(v: __m256i) -> __m256i {
     let lookup = _mm256_setr_epi8(
@@ -30,6 +33,7 @@
     _mm256_sad_epu8(total, _mm256_setzero_si256())
 }
 
+#[cfg(target_arch = "x86_64")]
 #[target_feature(enable = "avx2")]
 unsafe fn avx2_harvey_seal_popcnt(x: *const __m256i, size: usize) -> u64 {
     let mut total = _mm256_setzero_si256();
@@ -76,6 +80,7 @@
         + _mm256_extract_epi64(total, 3)) as u64
 }
 
+#[cfg(target_arch = "x86_64")]
 #[target_feature(enable = "avx2")]
 unsafe fn avx2_harvey_seal_dist(x: *const __m256i, y: *const __m256i, size: usize) -> u64 {
     let mut total = _mm256_setzero_si256();
@@ -170,6 +175,7 @@
         + _mm256_extract_epi64(total, 3)) as u64
 }
 
+#[cfg(target_arch = "x86_64")]
 #[target_feature(enable = "avx2")]
 pub unsafe fn distance_vect(x: &[u8], y: &[u8]) -> u64 {
     assert_eq!(x.len(), y.len());
@@ -209,6 +215,7 @@
     accum
 }
 
+#[cfg(target_arch = "x86_64")]
 #[target_feature(enable = "avx2")]
 pub unsafe fn weight_vect(x: &[u8]) -> u64 {
     let mut accum = 0;
