From b06274be935a93a59b788d1e21108e8ffc90eafb Mon Sep 17 00:00:00 2001
From: Agathe Porte <989521+gagath@users.noreply.github.com>
Date: Tue, 8 Jul 2025 16:27:31 +0200
Subject: [PATCH] refactor: replace instant dep with web-time

The instant crate is no longer maintained since a year. Its upstream
author recommends [1] to switch to the web-time crate [2], which this
commit does.

[1] https://github.com/sebcrozet/instant/commit/d94bebae9fa470869dda4c1c916ac3686c7bc9bd
[2] https://crates.io/crates/web-time
---
 Cargo.toml                         |  3 +-
 src/kanata/millisecond_counting.rs | 14 ++++----
 src/kanata/mod.rs                  | 28 ++++++++--------
 4 files changed, 45 insertions(+), 53 deletions(-)

--- a/src/kanata/millisecond_counting.rs
+++ b/src/kanata/millisecond_counting.rs
@@ -1,12 +1,14 @@
+use web_time::Instant;
+
 pub struct MillisecondCountResult {
-    pub last_tick: instant::Instant,
+    pub last_tick: Instant,
     pub ms_elapsed: u128,
     pub ms_remainder_in_ns: u128,
 }
 
 pub fn count_ms_elapsed(
-    last_tick: instant::Instant,
-    now: instant::Instant,
+    last_tick: Instant,
+    now: Instant,
     prev_ms_remainder_in_ns: u128,
 ) -> MillisecondCountResult {
     const NS_IN_MS: u128 = 1_000_000;
@@ -29,7 +31,7 @@
 #[test]
 fn ms_counts_0_elapsed_correctly() {
     use std::time::Duration;
-    let last_tick = instant::Instant::now();
+    let last_tick = Instant::now();
     let now = last_tick + Duration::from_nanos(999999);
     let result = count_ms_elapsed(last_tick, now, 0);
     assert_eq!(0, result.ms_elapsed);
@@ -40,7 +42,7 @@
 #[test]
 fn ms_counts_1_elapsed_correctly() {
     use std::time::Duration;
-    let last_tick = instant::Instant::now();
+    let last_tick = Instant::now();
     let now = last_tick + Duration::from_nanos(1234567);
     let result = count_ms_elapsed(last_tick, now, 0);
     assert_eq!(1, result.ms_elapsed);
@@ -51,7 +53,7 @@
 #[test]
 fn ms_counts_1_then_2_elapsed_correctly() {
     use std::time::Duration;
-    let last_tick = instant::Instant::now();
+    let last_tick = Instant::now();
     let now = last_tick + Duration::from_micros(1750);
     let result = count_ms_elapsed(last_tick, now, 0);
     assert_eq!(1, result.ms_elapsed);
--- a/src/kanata/mod.rs
+++ b/src/kanata/mod.rs
@@ -146,7 +146,7 @@
     pub override_states: OverrideStates,
     /// Time of the last tick to know how many tick iterations to run, to achieve a 1ms tick
     /// interval more closely.
-    last_tick: instant::Instant,
+    last_tick: web_time::Instant,
     /// Tracks the non-whole-millisecond gaps between ticks to know when to do another tick
     /// iteration without sleeping, to achive a 1ms tick interval more closely.
     time_remainder: u128,
@@ -383,7 +383,7 @@
             sequence_timeout: cfg.options.sequence_timeout,
             sequence_state: SequenceState::new(),
             sequences: cfg.sequences,
-            last_tick: instant::Instant::now(),
+            last_tick: web_time::Instant::now(),
             time_remainder: 0,
             live_reload_requested: false,
             overrides: cfg.overrides,
@@ -527,7 +527,7 @@
             sequence_timeout: cfg.options.sequence_timeout,
             sequence_state: SequenceState::new(),
             sequences: cfg.sequences,
-            last_tick: instant::Instant::now(),
+            last_tick: web_time::Instant::now(),
             time_remainder: 0,
             live_reload_requested: false,
             overrides: cfg.overrides,
@@ -793,7 +793,7 @@
     /// Returns the number of ms elapsed for the procesing loop according to current monotonic time
     /// and stored internal state. Mutates the internal time-tracking state.
     pub fn get_ms_elapsed(&mut self) -> u128 {
-        let now = instant::Instant::now();
+        let now = web_time::Instant::now();
         let ms_count_result = count_ms_elapsed(self.last_tick, now, self.time_remainder);
         let ms_elapsed = ms_count_result.ms_elapsed;
         self.time_remainder = ms_count_result.ms_remainder_in_ns;
@@ -806,7 +806,7 @@
             // 1000 ticks in 1ms on average. In practice, there will already be fewer than 1000
             // ticks in 1ms when running expensive operations, this just avoids having tens to
             // thousands of ticks all happening as soon as the expensive operations end.
-            _ => instant::Instant::now(),
+            _ => web_time::Instant::now(),
         };
 
         ms_elapsed
@@ -1963,7 +1963,7 @@
             #[cfg(all(not(feature = "interception_driver"), target_os = "windows"))]
             let mut idle_clear_happened = false;
             #[cfg(all(not(feature = "interception_driver"), target_os = "windows"))]
-            let mut last_input_time = instant::Instant::now();
+            let mut last_input_time = web_time::Instant::now();
 
             let err = loop {
                 let can_block = {
@@ -1982,7 +1982,7 @@
                     match rx.recv() {
                         Ok(kev) => {
                             let mut k = kanata.lock();
-                            let now = instant::Instant::now()
+                            let now = web_time::Instant::now()
                                 .checked_sub(time::Duration::from_millis(1))
                                 .expect("subtract 1ms from current time");
 
@@ -2019,7 +2019,7 @@
                             k.last_tick = now;
 
                             #[cfg(feature = "perf_logging")]
-                            let start = instant::Instant::now();
+                            let start = web_time::Instant::now();
 
                             if let Err(e) = k.handle_input_event(&kev) {
                                 break e;
@@ -2045,7 +2045,7 @@
                                 (start.elapsed()).as_nanos()
                             );
                             #[cfg(feature = "perf_logging")]
-                            let start = instant::Instant::now();
+                            let start = web_time::Instant::now();
 
                             match k.handle_time_ticks(&tx) {
                                 Ok(ms) => ms_elapsed = ms,
@@ -2068,7 +2068,7 @@
                     match rx.try_recv() {
                         Ok(kev) => {
                             #[cfg(feature = "perf_logging")]
-                            let start = instant::Instant::now();
+                            let start = web_time::Instant::now();
 
                             if let Err(e) = k.handle_input_event(&kev) {
                                 break e;
@@ -2078,7 +2078,7 @@
                                 target_os = "windows"
                             ))]
                             {
-                                last_input_time = instant::Instant::now();
+                                last_input_time = web_time::Instant::now();
                             }
                             #[cfg(all(
                                 not(feature = "interception_driver"),
@@ -2094,7 +2094,7 @@
                                 (start.elapsed()).as_nanos()
                             );
                             #[cfg(feature = "perf_logging")]
-                            let start = instant::Instant::now();
+                            let start = web_time::Instant::now();
 
                             match k.handle_time_ticks(&tx) {
                                 Ok(ms) => ms_elapsed = ms,
@@ -2109,7 +2109,7 @@
                         }
                         Err(TryRecvError::Empty) => {
                             #[cfg(feature = "perf_logging")]
-                            let start = instant::Instant::now();
+                            let start = web_time::Instant::now();
 
                             match k.handle_time_ticks(&tx) {
                                 Ok(ms) => ms_elapsed = ms,
@@ -2141,7 +2141,7 @@
                                 // the states that might be stuck. A real use case might be to have
                                 // a fake key pressed for a long period of time, so make sure those
                                 // are not cleared.
-                                if (instant::Instant::now() - (last_input_time))
+                                if (web_time::Instant::now() - (last_input_time))
                                     > time::Duration::from_secs(LLHOOK_IDLE_TIME_SECS_CLEAR_INPUTS)
                                     && !idle_clear_happened
                                 {
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -72,7 +72,6 @@
 simulated_input = ["indoc"]
 simulated_output = ["indoc"]
 tcp_server = ["serde_json"]
-wasm = ["instant/wasm-bindgen"]
 win_llhook_read_scancodes = ["kanata-parser/win_llhook_read_scancodes"]
 win_manifest = [
     "embed-resource",
@@ -110,10 +109,6 @@
 version = "2.0.4"
 optional = true
 
-[dependencies.instant]
-version = "0.1.12"
-default-features = false
-
 [dependencies.kanata-keyberon]
 version = "0.190.0"
 
@@ -155,6 +150,9 @@
 [dependencies.time]
 version = "0.3.36"
 
+[dependencies.web-time]
+version = "1.1.0"
+
 [target.'cfg(not(target_arch = "wasm32"))'.dependencies.arboard]
 version = "3.4"
 
