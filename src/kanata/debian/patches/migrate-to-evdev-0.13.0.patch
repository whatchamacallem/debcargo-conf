From 09bbfb90c879ec73349fc012d79ec00a71056ae6 Mon Sep 17 00:00:00 2001
From: Agathe Porte <989521+gagath@users.noreply.github.com>
Date: Wed, 9 Jul 2025 14:44:42 +0200
Subject: [PATCH] chore: migrate to evdev 0.13.0

Forwarded: https://github.com/jtroo/kanata/pull/1686
---
 Cargo.toml          |  2 +-
 src/kanata/linux.rs | 20 +++++------
 src/oskbd/linux.rs  | 82 ++++++++++++++++++++++-----------------------
 src/oskbd/macos.rs  |  2 +-
 5 files changed, 70 insertions(+), 75 deletions(-)

--- a/src/kanata/linux.rs
+++ b/src/kanata/linux.rs
@@ -4,7 +4,7 @@
 )]
 
 use anyhow::{anyhow, bail, Result};
-use evdev::{InputEvent, InputEventKind, RelativeAxisType};
+use evdev::{InputEvent, EventSummary, RelativeAxisCode};
 use log::info;
 use parking_lot::Mutex;
 use std::convert::TryFrom;
@@ -46,7 +46,7 @@
 
             for in_event in events.iter().copied() {
                 if let Some(ms_mvmt_key) = *mouse_movement_key.lock() {
-                    if let InputEventKind::RelAxis(_) = in_event.kind() {
+                    if let EventSummary::RelativeAxis(_, _, _) = in_event.destructure() {
                         let fake_event = KeyEvent::new(ms_mvmt_key, KeyValue::Tap);
                         if let Err(e) = tx.try_send(fake_event) {
                             bail!("failed to send on channel: {}", e)
@@ -148,10 +148,10 @@
 ) -> Result<bool> {
     let direction: MWheelDirection = code.try_into().unwrap();
     let scroll_distance = in_event.value().unsigned_abs() as u16;
-    match in_event.kind() {
-        InputEventKind::RelAxis(axis_type) => {
+    match in_event.destructure() {
+        EventSummary::RelativeAxis(_, axis_type, _) => {
             match axis_type {
-                RelativeAxisType::REL_WHEEL | RelativeAxisType::REL_HWHEEL => {
+                RelativeAxisCode::REL_WHEEL | RelativeAxisCode::REL_HWHEEL => {
                     if MAPPED_KEYS.lock().contains(&code) {
                         return Ok(true);
                     }
@@ -168,10 +168,10 @@
                     let mut kanata = kanata.lock();
                     if !all_events.iter().any(|ev| {
                         matches!(
-                            ev.kind(),
-                            InputEventKind::RelAxis(
-                                RelativeAxisType::REL_WHEEL_HI_RES
-                                    | RelativeAxisType::REL_HWHEEL_HI_RES
+                            ev.destructure(),
+                            EventSummary::RelativeAxis(_,
+                                RelativeAxisCode::REL_WHEEL_HI_RES
+                                    | RelativeAxisCode::REL_HWHEEL_HI_RES, _
                             )
                         )
                     }) {
@@ -182,7 +182,7 @@
                     }
                     Ok(false)
                 }
-                RelativeAxisType::REL_WHEEL_HI_RES | RelativeAxisType::REL_HWHEEL_HI_RES => {
+                RelativeAxisCode::REL_WHEEL_HI_RES | RelativeAxisCode::REL_HWHEEL_HI_RES => {
                     if !MAPPED_KEYS.lock().contains(&code) {
                         // Passthrough if the scroll wheel event is not mapped
                         // in the configuration.
--- a/src/oskbd/linux.rs
+++ b/src/oskbd/linux.rs
@@ -3,7 +3,7 @@
 #![cfg_attr(feature = "simulated_output", allow(dead_code, unused_imports))]
 
 pub use evdev::BusType;
-use evdev::{uinput, Device, EventType, InputEvent, Key, PropType, RelativeAxisType};
+use evdev::{uinput, Device, EventType, InputEvent, KeyCode, PropType, RelativeAxisCode};
 use inotify::{Inotify, WatchMask};
 use mio::{unix::SourceFd, Events, Interest, Poll, Token};
 use nix::ioctl_read_buf;
@@ -264,7 +264,7 @@
     let is_keyboard = device.supported_keys().is_some_and(has_keyboard_keys);
     let is_mouse = device
         .supported_relative_axes()
-        .is_some_and(|axes| axes.contains(RelativeAxisType::REL_X));
+        .is_some_and(|axes| axes.contains(RelativeAxisCode::REL_X));
     let device_type = match (is_keyboard, is_mouse) {
         (true, true) => DeviceType::KeyboardMouse,
         (true, false) => DeviceType::Keyboard,
@@ -305,14 +305,14 @@
     }
 }
 
-fn has_keyboard_keys(keys: &evdev::AttributeSetRef<Key>) -> bool {
+fn has_keyboard_keys(keys: &evdev::AttributeSetRef<KeyCode>) -> bool {
     const SENSIBLE_KEYBOARD_SCANCODE_LOWER_BOUND: u16 = 1;
     // The next one is power button. Some keyboards have it,
     // but so does the power button...
     const SENSIBLE_KEYBOARD_SCANCODE_UPPER_BOUND: u16 = 115;
     let mut sensible_keyboard_keys = (SENSIBLE_KEYBOARD_SCANCODE_LOWER_BOUND
         ..=SENSIBLE_KEYBOARD_SCANCODE_UPPER_BOUND)
-        .map(Key::new);
+        .map(KeyCode::new);
     sensible_keyboard_keys.any(|k| keys.contains(k))
 }
 
@@ -320,22 +320,22 @@
     type Error = ();
     fn try_from(item: InputEvent) -> Result<Self, Self::Error> {
         use OsCode::*;
-        match item.kind() {
-            evdev::InputEventKind::Key(k) => Ok(Self {
+        match item.destructure() {
+            evdev::EventSummary::Key(_, k, _) => Ok(Self {
                 code: OsCode::from_u16(k.0).ok_or(())?,
                 value: KeyValue::from(item.value()),
             }),
-            evdev::InputEventKind::RelAxis(axis_type) => {
+            evdev::EventSummary::RelativeAxis(_, axis_type, _) => {
                 let dist = item.value();
                 let code: OsCode = match axis_type {
-                    RelativeAxisType::REL_WHEEL | RelativeAxisType::REL_WHEEL_HI_RES => {
+                    RelativeAxisCode::REL_WHEEL | RelativeAxisCode::REL_WHEEL_HI_RES => {
                         if dist > 0 {
                             MouseWheelUp
                         } else {
                             MouseWheelDown
                         }
                     }
-                    RelativeAxisType::REL_HWHEEL | RelativeAxisType::REL_HWHEEL_HI_RES => {
+                    RelativeAxisCode::REL_HWHEEL | RelativeAxisCode::REL_HWHEEL_HI_RES => {
                         if dist > 0 {
                             MouseWheelRight
                         } else {
@@ -356,7 +356,7 @@
 
 impl From<KeyEvent> for InputEvent {
     fn from(item: KeyEvent) -> Self {
-        InputEvent::new(EventType::KEY, item.code as u16, item.value as i32)
+        InputEvent::new(EventType::KEY.0, item.code as u16, item.value as i32)
     }
 }
 
@@ -384,23 +384,23 @@
         // TODO investigate the rare possibility that a device is e.g. a Joystick and a Keyboard or a Mouse at the same time, which could lead to lost events
 
         // For some reason 0..0x300 (max value for a key) doesn't work, the closest that I've got to work is 560
-        let keys = evdev::AttributeSet::from_iter((0..560).map(evdev::Key));
+        let keys = evdev::AttributeSet::from_iter((0..560).map(evdev::KeyCode));
         let relative_axes = evdev::AttributeSet::from_iter([
-            RelativeAxisType::REL_WHEEL,
-            RelativeAxisType::REL_HWHEEL,
-            RelativeAxisType::REL_X,
-            RelativeAxisType::REL_Y,
-            RelativeAxisType::REL_Z,
-            RelativeAxisType::REL_RX,
-            RelativeAxisType::REL_RY,
-            RelativeAxisType::REL_RZ,
-            RelativeAxisType::REL_DIAL,
-            RelativeAxisType::REL_MISC,
-            RelativeAxisType::REL_WHEEL_HI_RES,
-            RelativeAxisType::REL_HWHEEL_HI_RES,
+            RelativeAxisCode::REL_WHEEL,
+            RelativeAxisCode::REL_HWHEEL,
+            RelativeAxisCode::REL_X,
+            RelativeAxisCode::REL_Y,
+            RelativeAxisCode::REL_Z,
+            RelativeAxisCode::REL_RX,
+            RelativeAxisCode::REL_RY,
+            RelativeAxisCode::REL_RZ,
+            RelativeAxisCode::REL_DIAL,
+            RelativeAxisCode::REL_MISC,
+            RelativeAxisCode::REL_WHEEL_HI_RES,
+            RelativeAxisCode::REL_HWHEEL_HI_RES,
         ]);
 
-        let device = uinput::VirtualDeviceBuilder::new()?
+        let device = uinput::VirtualDevice::builder()?
             .name(&name)
             // libinput's "disable while typing" feature don't work when bus_type
             // is set to BUS_USB, but appears to work when it's set to BUS_I8042.
@@ -496,7 +496,7 @@
     }
 
     pub fn write_code(&mut self, code: u32, value: KeyValue) -> Result<(), io::Error> {
-        let event = InputEvent::new(EventType::KEY, code as u16, value as i32);
+        let event = InputEvent::new(EventType::KEY.0, code as u16, value as i32);
         self.device.emit(&[event])?;
         Ok(())
     }
@@ -584,11 +584,11 @@
         }
 
         let hi_res_scroll_event = InputEvent::new(
-            EventType::RELATIVE,
+            EventType::RELATIVE.0,
             match direction {
-                MWheelDirection::Up | MWheelDirection::Down => RelativeAxisType::REL_WHEEL_HI_RES.0,
+                MWheelDirection::Up | MWheelDirection::Down => RelativeAxisCode::REL_WHEEL_HI_RES.0,
                 MWheelDirection::Left | MWheelDirection::Right => {
-                    RelativeAxisType::REL_HWHEEL_HI_RES.0
+                    RelativeAxisCode::REL_HWHEEL_HI_RES.0
                 }
             },
             match direction {
@@ -601,13 +601,13 @@
             self.write_many(&[
                 hi_res_scroll_event,
                 InputEvent::new(
-                    EventType::RELATIVE,
+                    EventType::RELATIVE.0,
                     match direction {
                         MWheelDirection::Up | MWheelDirection::Down => {
-                            RelativeAxisType::REL_WHEEL.0
+                            RelativeAxisCode::REL_WHEEL.0
                         }
                         MWheelDirection::Left | MWheelDirection::Right => {
-                            RelativeAxisType::REL_HWHEEL.0
+                            RelativeAxisCode::REL_HWHEEL.0
                         }
                     },
                     match direction {
@@ -625,24 +625,24 @@
 
     pub fn move_mouse(&mut self, mv: CalculatedMouseMove) -> Result<(), io::Error> {
         let (axis, distance) = match mv.direction {
-            MoveDirection::Up => (RelativeAxisType::REL_Y, -i32::from(mv.distance)),
-            MoveDirection::Down => (RelativeAxisType::REL_Y, i32::from(mv.distance)),
-            MoveDirection::Left => (RelativeAxisType::REL_X, -i32::from(mv.distance)),
-            MoveDirection::Right => (RelativeAxisType::REL_X, i32::from(mv.distance)),
+            MoveDirection::Up => (RelativeAxisCode::REL_Y, -i32::from(mv.distance)),
+            MoveDirection::Down => (RelativeAxisCode::REL_Y, i32::from(mv.distance)),
+            MoveDirection::Left => (RelativeAxisCode::REL_X, -i32::from(mv.distance)),
+            MoveDirection::Right => (RelativeAxisCode::REL_X, i32::from(mv.distance)),
         };
-        self.write(InputEvent::new(EventType::RELATIVE, axis.0, distance))
+        self.write(InputEvent::new(EventType::RELATIVE.0, axis.0, distance))
     }
 
     pub fn move_mouse_many(&mut self, moves: &[CalculatedMouseMove]) -> Result<(), io::Error> {
         let mut events = vec![];
         for mv in moves {
             let (axis, distance) = match mv.direction {
-                MoveDirection::Up => (RelativeAxisType::REL_Y, -i32::from(mv.distance)),
-                MoveDirection::Down => (RelativeAxisType::REL_Y, i32::from(mv.distance)),
-                MoveDirection::Left => (RelativeAxisType::REL_X, -i32::from(mv.distance)),
-                MoveDirection::Right => (RelativeAxisType::REL_X, i32::from(mv.distance)),
+                MoveDirection::Up => (RelativeAxisCode::REL_Y, -i32::from(mv.distance)),
+                MoveDirection::Down => (RelativeAxisCode::REL_Y, i32::from(mv.distance)),
+                MoveDirection::Left => (RelativeAxisCode::REL_X, -i32::from(mv.distance)),
+                MoveDirection::Right => (RelativeAxisCode::REL_X, i32::from(mv.distance)),
             };
-            events.push(InputEvent::new(EventType::RELATIVE, axis.0, distance));
+            events.push(InputEvent::new(EventType::RELATIVE.0, axis.0, distance));
         }
         self.write_many(&events)
     }
--- a/src/oskbd/macos.rs
+++ b/src/oskbd/macos.rs
@@ -144,7 +144,7 @@
 
         wait_key(&mut event);
 
-        Ok(InputEvent::new(event))
+        Ok(InputEvent::new(event.0))
     }
 }
 
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -136,7 +136,7 @@
 version = "3.4"
 
 [target.'cfg(target_os = "linux")'.dependencies.evdev]
-version = "0.12.2"
+version = "0.13.0"
 
 [target.'cfg(target_os = "linux")'.dependencies.inotify]
 version = "0.10.0"
