Description: Call bindgen during build to refresh bindings
Author: Antonin Delpeuch <antonin@delpeuch.eu>
Bug: https://github.com/KWARC/rust-libxml/issues/73
Forwarded: https://github.com/KWARC/rust-libxml/pull/143
Last-Update: 2025-04-08
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -39,6 +39,13 @@ name = "libxml"
 [dependencies.libc]
 version = "0.2"
 
+[build-dependencies.bindgen]
+version = "0.71"
+features = [
+    "runtime",
+]
+default-features = false
+
 [dev-dependencies.criterion]
 version = "0.5.1"
 
--- a/build.rs
+++ b/build.rs
@@ -1,4 +1,10 @@
-fn main() {
+use std::{env, fs, path::{Path, PathBuf}};
+
+/// Finds libxml2 and optionally return a list of header
+/// files from which the bindings can be generated.
+fn find_libxml2() -> Option<Vec<PathBuf>> {
+  #![allow(unreachable_code)] // for platform-dependent dead code
+
   if let Ok(ref s) = std::env::var("LIBXML2") {
     // println!("{:?}", std::env::vars());
     // panic!("set libxml2.");
@@ -20,18 +26,20 @@ fn main() {
         .expect("no library path in LIBXML2 env")
         .to_string_lossy()
     );
+    None
   } else {
     #[cfg(any(target_family = "unix", target_os = "macos"))]
     {
-      if pkg_config_dep::find() {
-        return;
-      }
+      let lib = pkg_config::Config::new()
+        .probe("libxml-2.0")
+        .expect("Couldn't find libxml2 via pkg-config");
+      return Some(lib.include_paths)
     }
 
     #[cfg(windows)]
     {
       if vcpkg_dep::find() {
-        return;
+        return None
       }
     }
 
@@ -39,13 +47,30 @@ fn main() {
   }
 }
 
-#[cfg(any(target_family = "unix", target_os = "macos"))]
-mod pkg_config_dep {
-  pub fn find() -> bool {
-    if pkg_config::find_library("libxml-2.0").is_ok() {
-      return true;
-    }
-    false
+fn generate_bindings(header_dirs: Vec<PathBuf>, output_path: &Path) {
+  let bindings = bindgen::Builder::default()
+    .header("src/wrapper.h")
+    // invalidate build as soon as the wrapper changes
+    .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
+    .layout_tests(true)
+    .clang_args(&["-DPKG-CONFIG"])
+    .clang_args(
+      header_dirs.iter()
+        .map(|dir| format!("-I{}", dir.display()))
+    );
+  bindings
+    .generate()
+    .expect("failed to generate bindings with bindgen")
+    .write_to_file(output_path)
+    .expect("Failed to write bindings.rs");
+}
+
+fn main() {
+  let bindings_path = PathBuf::from(env::var_os("OUT_DIR").unwrap()).join("bindings.rs");
+  if let Some(header_dirs) = find_libxml2() {
+    generate_bindings(header_dirs, &bindings_path);
+  } else {
+    panic!("could not locate libxml2 headers. Make sure LIBXML2 is not set and pkg-config is available.");
   }
 }
 
--- /dev/null
+++ b/src/bindings.rs
@@ -0,0 +1,15 @@
+// Issues coming from bindgen
+#![allow(non_upper_case_globals)]
+#![allow(non_camel_case_types)]
+#![allow(non_snake_case)]
+#![allow(dead_code)]
+#![allow(improper_ctypes)]
+#![allow(missing_docs)]
+
+/*
+ * helper var until we figure out well-formedness checks
+ */
+
+pub static mut HACKY_WELL_FORMED: bool = false;
+
+include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
--- a/src/c_helpers.rs
+++ b/src/c_helpers.rs
@@ -94,7 +94,7 @@ pub fn xmlNodeGetName(cur: xmlNodePtr) -
 }
 
 // dummy function: no debug output at all
-fn _ignoreInvalidTagsErrorFunc(_user_data: *mut c_void, error: xmlErrorPtr) {
+unsafe extern "C" fn _ignoreInvalidTagsErrorFunc(_user_data: *mut c_void, error: xmlErrorPtr) {
   unsafe {
     if !error.is_null() && (*error).code as u32 == xmlParserErrors_XML_HTML_UNKNOWN_TAG {
       // do not record invalid, in fact (out of despair) claim we ARE well-formed, when a tag is invalid.
--- a/src/schemas/common.rs
+++ b/src/schemas/common.rs
@@ -9,7 +9,7 @@ use std::ffi::c_void;
 
 /// Provides a callback to the C side of things to accumulate xmlErrors to be
 /// handled back on the Rust side.
-pub fn structured_error_handler(ctx: *mut c_void, error: bindings::xmlErrorPtr) {
+pub unsafe extern "C" fn structured_error_handler(ctx: *mut c_void, error: bindings::xmlErrorPtr) {
   assert!(!ctx.is_null());
   let errlog = unsafe { &mut *{ ctx as *mut Vec<StructuredError> } };
 
--- /dev/null
+++ b/src/wrapper.h
@@ -0,0 +1,6 @@
+#include <libxml/parser.h>
+#include <libxml/xpath.h>
+#include <libxml/xpathInternals.h>
+#include <libxml/xmlsave.h>
+#include <libxml/HTMLparser.h>
+#include <libxml/xmlschemas.h>
\ No newline at end of file
