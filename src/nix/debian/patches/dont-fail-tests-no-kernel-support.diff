Index: nix/test/sys/test_socket.rs
===================================================================
--- nix.orig/test/sys/test_socket.rs
+++ nix/test/sys/test_socket.rs
@@ -40,7 +40,14 @@ pub fn test_timestamping() {
     .unwrap();
     nix::sys::socket::bind(rsock.as_raw_fd(), &sock_addr).unwrap();
 
-    setsockopt(&rsock, Timestamping, &TimestampingFlag::all()).unwrap();
+    let result = setsockopt(&rsock, Timestamping, &TimestampingFlag::all());
+    if let Err(e) = result {
+        use nix::errno::Errno::ENOPROTOOPT;
+        if e == ENOPROTOOPT {
+            return; // skipped due to lack of kernel support.
+        }
+    }
+    result.unwrap();
 
     let sbuf = [0u8; 2048];
     let mut rbuf = [0u8; 2048];
@@ -954,8 +961,14 @@ pub fn test_af_alg_cipher() {
         SockType::SeqPacket,
         SockFlag::empty(),
         None,
-    )
-    .expect("socket failed");
+    );
+    // don't fail the tests on systems that don't support this functionality
+    if let Err(e) = sock {
+        if e == nix::errno::Errno::EAFNOSUPPORT {
+            return;
+        }
+    }
+    let sock = sock.expect("socket failed");
 
     let sockaddr = AlgAddr::new(alg_type, alg_name);
     bind(sock.as_raw_fd(), &sockaddr).expect("bind failed");
@@ -3085,7 +3098,14 @@ fn test_recvmm2() -> nix::Result<()> {
 
     bind(rsock.as_raw_fd(), &sock_addr)?;
 
-    setsockopt(&rsock, Timestamping, &TimestampingFlag::all())?;
+    if let Err(e) = setsockopt(&rsock, Timestamping, &TimestampingFlag::all()) {
+       use nix::errno::Errno::ENOPROTOOPT;
+       if e != ENOPROTOOPT {
+           return Err(e);
+       } else {
+           return Ok(()); // test skipped due to lack of kernel support.
+       }
+    }
 
     let sbuf = (0..400).map(|i| i as u8).collect::<Vec<_>>();
 
Index: nix/test/test_fcntl.rs
===================================================================
--- nix.orig/test/test_fcntl.rs
+++ nix/test/test_fcntl.rs
@@ -78,8 +78,11 @@ fn test_openat2() {
             .flags(OFlag::O_RDONLY)
             .mode(Mode::empty())
             .resolve(ResolveFlag::RESOLVE_BENEATH),
-    )
-    .unwrap();
+    );
+    if fd.as_ref().err() == Some(&nix::errno::Errno::ENOSYS) {
+        return; //no kernel support.
+    }
+    let fd = fd.unwrap();
 
     let mut buf = [0u8; 1024];
     assert_eq!(4, read(&fd, &mut buf).unwrap());
@@ -109,6 +112,9 @@ fn test_openat2_forbidden() {
             .flags(OFlag::O_RDONLY)
             .resolve(ResolveFlag::RESOLVE_BENEATH),
     );
+    if res.as_ref().err() == Some(&Errno::ENOSYS) {
+        return; // no kernel support
+    }
     assert_eq!(res.unwrap_err(), Errno::EXDEV);
 }
 
@@ -285,7 +291,11 @@ fn test_copy_file_range() {
     tmp1.flush().unwrap();
 
     let mut from_offset: i64 = 3;
-    copy_file_range(&tmp1, Some(&mut from_offset), &tmp2, None, 3).unwrap();
+    let result = copy_file_range(&tmp1, Some(&mut from_offset), &tmp2, None, 3);
+    if result == Err(nix::errno::Errno::ENOSYS) {
+        return; //the kernel doesn't support this functionality.
+    }
+    result.unwrap();
 
     let mut res: String = String::new();
     tmp2.rewind().unwrap();
@@ -375,8 +385,14 @@ mod linux_android {
     fn test_fallocate() {
         let tmp = NamedTempFile::new().unwrap();
 
-        fallocate(&tmp, FallocateFlags::empty(), 0, 100).unwrap();
-
+        let result = fallocate(&tmp, FallocateFlags::empty(), 0, 100);
+        // don't fail the tests on systems that don't support this functionality
+        if let Err(e) = result {
+           if e == nix::errno::Errno::EOPNOTSUPP {
+                return;
+           }
+        }
+        result.unwrap();
         // Check if we read exactly 100 bytes
         let mut buf = [0u8; 200];
         assert_eq!(100, read(&tmp, &mut buf).unwrap());
Index: nix/test/sys/test_fanotify.rs
===================================================================
--- nix.orig/test/sys/test_fanotify.rs
+++ nix/test/sys/test_fanotify.rs
@@ -152,12 +152,15 @@ fn test_fanotify_responses() {
 }
 
 fn test_fanotify_overflow() {
-    let max_events: usize =
-        read_to_string("/proc/sys/fs/fanotify/max_queued_events")
-            .unwrap()
-            .trim()
-            .parse()
-            .unwrap();
+    let max_events =
+        read_to_string("/proc/sys/fs/fanotify/max_queued_events");
+
+    if let Err(ref e) = max_events {
+        if e.kind() == ErrorKind::NotFound {
+            return; // not found error, assume kernel support unavailable.
+        }
+    }
+    let max_events: usize = max_events.unwrap().trim().parse().unwrap();
 
     // make sure the kernel is configured with the default value,
     // just so this test doesn't run forever
