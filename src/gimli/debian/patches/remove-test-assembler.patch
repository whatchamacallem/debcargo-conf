Index: gimli/Cargo.toml
===================================================================
--- gimli.orig/Cargo.toml
+++ gimli/Cargo.toml
@@ -72,9 +72,6 @@ version = "1.1.0"
 optional = true
 default-features = false
 
-[dev-dependencies.test-assembler]
-version = "0.1.3"
-
 [features]
 default = [
     "read-all",
Index: gimli/src/read/abbrev.rs
===================================================================
--- gimli.orig/src/read/abbrev.rs
+++ gimli/src/read/abbrev.rs
@@ -636,10 +636,10 @@ pub(crate) mod tests {
     use crate::constants;
     use crate::endianity::LittleEndian;
     use crate::read::{EndianSlice, Error};
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     #[cfg(target_pointer_width = "32")]
     use core::u32;
-    use test_assembler::Section;
+    //use test_assembler::Section;
 
     pub trait AbbrevSectionMethods {
         fn abbrev(self, code: u64, tag: constants::DwTag, children: constants::DwChildren) -> Self;
@@ -649,7 +649,7 @@ pub(crate) mod tests {
         fn abbrev_attr_null(self) -> Self;
     }
 
-    impl AbbrevSectionMethods for Section {
+    /*impl AbbrevSectionMethods for Section {
         fn abbrev(self, code: u64, tag: constants::DwTag, children: constants::DwChildren) -> Self {
             self.uleb(code).uleb(tag.0.into()).D8(children.0)
         }
@@ -671,9 +671,9 @@ pub(crate) mod tests {
         fn abbrev_attr_null(self) -> Self {
             self.D8(0).D8(0)
         }
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_debug_abbrev_ok() {
         let extra_start = [1, 2, 3, 4];
         let expected_rest = [5, 6, 7, 8];
@@ -730,7 +730,7 @@ pub(crate) mod tests {
             .expect("Should parse abbreviations");
         assert_eq!(abbrevs.get(1), Some(&abbrev1));
         assert_eq!(abbrevs.get(2), Some(&abbrev2));
-    }
+    }*/
 
     #[test]
     fn test_abbreviations_insert() {
@@ -827,7 +827,7 @@ pub(crate) mod tests {
         assert_abbrev(&abbrevs, wrap_code);
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_abbreviations_ok() {
         let expected_rest = [1, 2, 3, 4];
         #[rustfmt::skip]
@@ -904,7 +904,7 @@ pub(crate) mod tests {
             Err(Error::DuplicateAbbreviationCode) => {}
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         };
-    }
+    }*/
 
     #[test]
     fn test_parse_abbreviation_tag_ok() {
@@ -939,7 +939,7 @@ pub(crate) mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_abbreviation_ok() {
         let expected_rest = [0x01, 0x02, 0x03, 0x04];
         let buf = Section::new()
@@ -1025,7 +1025,7 @@ pub(crate) mod tests {
         let abbrev = Abbreviation::parse(rest).expect("Should parse null abbreviation");
         assert!(abbrev.is_none());
         assert_eq!(*rest, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
     #[test]
     fn test_parse_attribute_form_ok() {
Index: gimli/src/read/addr.rs
===================================================================
--- gimli.orig/src/read/addr.rs
+++ gimli/src/read/addr.rs
@@ -74,11 +74,11 @@ impl<R> From<R> for DebugAddr<R> {
 mod tests {
     use super::*;
     use crate::read::EndianSlice;
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     use crate::{Format, LittleEndian};
-    use test_assembler::{Endian, Label, LabelMaker, Section};
+    //use test_assembler::{Endian, Label, LabelMaker, Section};
 
-    #[test]
+    /*#[test]
     fn test_get_address() {
         for format in [Format::Dwarf32, Format::Dwarf64] {
             for address_size in [4, 8] {
@@ -114,5 +114,5 @@ mod tests {
                 );
             }
         }
-    }
+    }*/
 }
Index: gimli/src/read/cfi.rs
===================================================================
--- gimli.orig/src/read/cfi.rs
+++ gimli/src/read/cfi.rs
@@ -3725,15 +3725,15 @@ mod tests {
     use crate::read::{
         EndianSlice, Error, Pointer, ReaderOffsetId, Result, Section as ReadSection,
     };
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     use alloc::boxed::Box;
     use alloc::vec::Vec;
     use core::marker::PhantomData;
     use core::mem;
-    use test_assembler::{Endian, Label, LabelMaker, LabelOrNum, Section, ToLabelOrNum};
+    //use test_assembler::{Endian, Label, LabelMaker, LabelOrNum, Section, ToLabelOrNum};
 
     // Ensure each test tries to read the same section kind that it wrote.
-    #[derive(Clone, Copy)]
+    /*#[derive(Clone, Copy)]
     struct SectionKind<Section>(PhantomData<Section>);
 
     impl<T> SectionKind<T> {
@@ -3762,15 +3762,15 @@ mod tests {
 
     fn debug_frame_le<'a>() -> SectionKind<DebugFrame<EndianSlice<'a, LittleEndian>>> {
         SectionKind(PhantomData)
-    }
+    }*/
 
-    fn debug_frame_be<'a>() -> SectionKind<DebugFrame<EndianSlice<'a, BigEndian>>> {
+    /*fn debug_frame_be<'a>() -> SectionKind<DebugFrame<EndianSlice<'a, BigEndian>>> {
         SectionKind(PhantomData)
-    }
+    }*/
 
-    fn eh_frame_le<'a>() -> SectionKind<EhFrame<EndianSlice<'a, LittleEndian>>> {
+    /*fn eh_frame_le<'a>() -> SectionKind<EhFrame<EndianSlice<'a, LittleEndian>>> {
         SectionKind(PhantomData)
-    }
+    }*/
 
     fn parse_fde<Section, O, F, R>(
         section: Section,
@@ -3793,7 +3793,7 @@ mod tests {
 
     // Mixin methods for `Section` to help define binary test data.
 
-    trait CfiSectionMethods: GimliSectionMethods {
+    /*trait CfiSectionMethods: GimliSectionMethods {
         fn cie<'aug, 'input, E, T>(
             self,
             _kind: SectionKind<T>,
@@ -3815,9 +3815,9 @@ mod tests {
             T: UnwindSection<EndianSlice<'input, E>>,
             T::Offset: UnwindOffset,
             L: ToLabelOrNum<'a, u64>;
-    }
+    }*/
 
-    impl CfiSectionMethods for Section {
+    /*impl CfiSectionMethods for Section {
         fn cie<'aug, 'input, E, T>(
             self,
             _kind: SectionKind<T>,
@@ -3956,7 +3956,7 @@ mod tests {
 
             section
         }
-    }
+    }*/
 
     trait ResultExt {
         fn map_eof(self, input: &[u8]) -> Self;
@@ -3974,7 +3974,7 @@ mod tests {
         }
     }
 
-    fn assert_parse_cie<'input, E>(
+    /*fn assert_parse_cie<'input, E>(
         kind: SectionKind<DebugFrame<EndianSlice<'input, E>>>,
         section: Section,
         address_size: u8,
@@ -4065,9 +4065,9 @@ mod tests {
         let kind = debug_frame_le();
         let section = Section::with_endian(kind.endian()).cie(kind, None, &mut cie);
         assert_parse_cie(kind, section, 4, Err(Error::UnknownVersion(99)));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_cie_unknown_augmentation() {
         let length = Label::new();
         let start = Label::new();
@@ -4103,9 +4103,9 @@ mod tests {
         length.set_const(expected_length);
 
         assert_parse_cie(kind, section, 8, Err(Error::UnknownAugmentation));
-    }
+    }*/
 
-    fn test_parse_cie(format: Format, version: u8, address_size: u8) {
+    /*fn test_parse_cie(format: Format, version: u8, address_size: u8) {
         let expected_rest = [1, 2, 3, 4, 5, 6, 7, 8, 9];
         let expected_instrs: Vec<_> = (0..4).map(|_| constants::DW_CFA_nop.0).collect();
 
@@ -4190,9 +4190,9 @@ mod tests {
             .map_eof(&contents),
             Err(Error::UnexpectedEof(ReaderOffsetId(4)))
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_fde_incomplete_length_32() {
         let kind = debug_frame_le();
         let section = Section::with_endian(kind.endian()).L16(5);
@@ -4234,9 +4234,9 @@ mod tests {
             parse_fde(debug_frame, rest, UnwindSection::cie_from_offset).map_eof(&section),
             Err(Error::UnexpectedEof(ReaderOffsetId(4)))
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_fde_32_ok() {
         let expected_rest = [1, 2, 3, 4, 5, 6, 7, 8, 9];
         let cie_offset = 0xbad0_bad1;
@@ -4331,9 +4331,9 @@ mod tests {
 
         assert_eq!(parse_fde(debug_frame, rest, get_cie), Ok(fde));
         assert_eq!(*rest, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_cfi_entry_on_cie_32_ok() {
         let expected_rest = [1, 2, 3, 4, 5, 6, 7, 8, 9];
         let expected_instrs: Vec<_> = (0..4).map(|_| constants::DW_CFA_nop.0).collect();
@@ -4424,7 +4424,7 @@ mod tests {
             }
             otherwise => panic!("Unexpected result: {:#?}", otherwise),
         }
-    }
+    }*/
 
     #[test]
     fn test_cfi_entries_iter() {
@@ -4462,7 +4462,7 @@ mod tests {
             initial_instructions: EndianSlice::new(&expected_instrs2, BigEndian),
         };
 
-        let cie1_location = Label::new();
+        /*let cie1_location = Label::new();
         let cie2_location = Label::new();
 
         // Write the CIEs first so that their length gets set before we clone
@@ -4546,10 +4546,10 @@ mod tests {
             otherwise => panic!("Unexpected result: {:#?}", otherwise),
         }
 
-        assert_eq!(entries.next(), Ok(None));
+        assert_eq!(entries.next(), Ok(None));*/
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_cie_from_offset() {
         let filler = [1, 2, 3, 4, 5, 6, 7, 8, 9];
         let instrs: Vec<_> = (0..5).map(|_| constants::DW_CFA_nop.0).collect();
@@ -4585,7 +4585,7 @@ mod tests {
         let bases = Default::default();
 
         assert_eq!(debug_frame.cie_from_offset(&bases, cie_offset), Ok(cie));
-    }
+    }*/
 
     fn parse_cfi_instruction<R: Reader + Default>(
         input: &mut R,
@@ -4601,7 +4601,7 @@ mod tests {
         CallFrameInstruction::parse(input, None, parameters, Vendor::Default)
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_cfi_instruction_advance_loc() {
         let expected_rest = [1, 2, 3, 4];
         let expected_delta = 42;
@@ -4970,9 +4970,9 @@ mod tests {
             })
         );
         assert_eq!(*input, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_cfi_instruction_def_cfa_expression() {
         let expected_rest = [1, 2, 3, 4];
         let expected_expr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
@@ -5041,9 +5041,9 @@ mod tests {
             })
         );
         assert_eq!(*input, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_cfi_instruction_offset_extended_sf() {
         let expected_rest = [1, 2, 3, 4];
         let expected_reg = 7;
@@ -5206,9 +5206,9 @@ mod tests {
             Ok(CallFrameInstruction::NegateRaState)
         );
         assert_eq!(*input, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_cfi_instruction_unknown_instruction() {
         let expected_rest = [1, 2, 3, 4];
         let unknown_instr = constants::DwCfa(0b0011_1111);
@@ -5221,9 +5221,9 @@ mod tests {
             parse_cfi_instruction(input, 8),
             Err(Error::UnknownCallFrameInstruction(unknown_instr))
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_call_frame_instruction_iter_ok() {
         let expected_reg = 50;
         let expected_expr = [2, 2, 1, 1, 5, 5];
@@ -5279,9 +5279,9 @@ mod tests {
         );
 
         assert_eq!(iter.next(), Ok(None));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_call_frame_instruction_iter_err() {
         // DW_CFA_advance_loc1 without an operand.
         let section = Section::with_endian(Endian::Big).D8(constants::DW_CFA_advance_loc1.0);
@@ -5306,7 +5306,7 @@ mod tests {
             Err(Error::UnexpectedEof(ReaderOffsetId(1)))
         );
         assert_eq!(iter.next(), Ok(None));
-    }
+    }*/
 
     fn assert_eval<'a, I>(
         mut initial_ctx: UnwindContext<usize>,
@@ -5842,7 +5842,7 @@ mod tests {
         assert_eval(ctx, expected, cie, None, instructions);
     }
 
-    #[test]
+    /*#[test]
     fn test_unwind_table_cie_no_rule() {
         let initial_instructions = Section::with_endian(Endian::Little)
             // The CFA is -12 from register 4.
@@ -6240,9 +6240,9 @@ mod tests {
         // All done!
         assert_eq!(Ok(None), table.next_row());
         assert_eq!(Ok(None), table.next_row());
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_unwind_info_for_address_ok() {
         let instrs1 = Section::with_endian(Endian::Big)
             // The CFA is -12 from register 4.
@@ -6360,7 +6360,7 @@ mod tests {
                 registers: [(Register(0), RegisterRule::Offset(-16))].iter().collect(),
             }
         );
-    }
+    }*/
 
     #[test]
     fn test_unwind_info_for_address_not_found() {
@@ -6386,7 +6386,7 @@ mod tests {
         assert_eq!(result.unwrap_err(), Error::UnknownVersion(42));
     }
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_hdr_omit_ehptr() {
         let section = Section::with_endian(Endian::Little)
             .L8(1)
@@ -6539,9 +6539,9 @@ mod tests {
         assert_eq!(table.lookup(20, &bases), Ok(Pointer::Direct(2)));
         assert_eq!(table.lookup(21, &bases), Ok(Pointer::Direct(2)));
         assert_eq!(table.lookup(100_000, &bases), Ok(Pointer::Direct(2)));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_fde_for_address_good() {
         // First, setup eh_frame
         // Write the CIE first so that its length gets set before we clone it
@@ -6679,9 +6679,9 @@ mod tests {
             table.fde_for_address(&eh_frame, &bases, 100_000, f),
             Err(Error::NoUnwindInfoForAddress)
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_stops_at_zero_length() {
         let mut cie = make_test_cie();
         let kind = eh_frame_le();
@@ -6722,9 +6722,9 @@ mod tests {
             debug_frame.cie_from_offset(&bases, DebugFrameOffset(0)),
             Err(Error::NoEntryAtGivenOffset)
         );
-    }
+    }*/
 
-    fn resolve_cie_offset(buf: &[u8], cie_offset: usize) -> Result<usize> {
+    /*fn resolve_cie_offset(buf: &[u8], cie_offset: usize) -> Result<usize> {
         let mut fde = FrameDescriptionEntry {
             offset: 0,
             length: 0,
@@ -6781,9 +6781,9 @@ mod tests {
             resolve_cie_offset(&buf, usize::MAX),
             Err(Error::OffsetOutOfBounds)
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_fde_ok() {
         let mut cie = make_test_cie();
         cie.format = Format::Dwarf32;
@@ -6836,9 +6836,9 @@ mod tests {
             otherwise => panic!("Unexpected result {:?}", otherwise),
         }
         assert!(offset.is_some());
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_fde_out_of_bounds() {
         let mut cie = make_test_cie();
         cie.version = 1;
@@ -6873,7 +6873,7 @@ mod tests {
             UnwindSection::cie_from_offset,
         );
         assert_eq!(result, Err(Error::OffsetOutOfBounds));
-    }
+    }*/
 
     #[test]
     fn test_augmentation_parse_not_z_augmentation() {
@@ -6907,7 +6907,7 @@ mod tests {
         );
     }
 
-    #[test]
+    /*#[test]
     fn test_augmentation_parse_unknown_part_of_z_augmentation() {
         // The 'Z' character is not defined by the z-style augmentation.
         let bases = Default::default();
@@ -7076,9 +7076,9 @@ mod tests {
             Ok(augmentation)
         );
         assert_eq!(*input, EndianSlice::new(&rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_fde_no_augmentation() {
         let instrs = [1, 2, 3, 4];
         let cie_offset = 1;
@@ -7234,9 +7234,9 @@ mod tests {
         let result = parse_fde(section, input, |_, _, _| Ok(cie.clone()));
         assert_eq!(result, Ok(fde));
         assert_eq!(*input, EndianSlice::new(&rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_eh_frame_cie_personality_function_relative_bad_context() {
         let instrs = [1, 2, 3, 4];
 
@@ -7286,7 +7286,7 @@ mod tests {
         let bases = BaseAddresses::default();
         let mut iter = section.entries(&bases);
         assert_eq!(iter.next(), Err(Error::FuncRelativePointerInBadContext));
-    }
+    }*/
 
     #[test]
     fn register_rule_map_eq() {
@@ -7419,7 +7419,7 @@ mod tests {
         );
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_encoded_pointer_absptr() {
         let encoding = constants::DW_EH_PE_absptr;
         let expected_rest = [1, 2, 3, 4];
@@ -7514,9 +7514,9 @@ mod tests {
             Ok(Pointer::Direct(0x11))
         );
         assert_eq!(rest, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_encoded_pointer_textrel_undefined() {
         let encoding = constants::DW_EH_PE_textrel;
 
@@ -7560,9 +7560,9 @@ mod tests {
             Ok(Pointer::Direct(0x11))
         );
         assert_eq!(rest, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_encoded_pointer_datarel_undefined() {
         let encoding = constants::DW_EH_PE_datarel;
 
@@ -7581,9 +7581,9 @@ mod tests {
             parse_encoded_pointer(encoding, &parameters, &mut rest),
             Err(Error::DataRelativePointerButDataBaseIsUndefined)
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_encoded_pointer_funcrel() {
         let encoding = constants::DW_EH_PE_funcrel;
         let expected_rest = [1, 2, 3, 4];
@@ -7830,9 +7830,9 @@ mod tests {
             Ok(Pointer::Direct(expected as u64))
         );
         assert_eq!(rest, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_parse_encoded_pointer_omit() {
         let encoding = constants::DW_EH_PE_omit;
 
@@ -7921,7 +7921,7 @@ mod tests {
             Ok(Pointer::Indirect(0x1234_5678))
         );
         assert_eq!(rest, EndianSlice::new(&expected_rest, LittleEndian));
-    }
+    }*/
 
     #[test]
     fn test_unwind_context_reuse() {
Index: gimli/src/read/index.rs
===================================================================
--- gimli.orig/src/read/index.rs
+++ gimli/src/read/index.rs
@@ -389,7 +389,7 @@ impl IndexSectionId {
 mod tests {
     use super::*;
     use crate::endianity::BigEndian;
-    use test_assembler::{Endian, Section};
+    //use test_assembler::{Endian, Section};
 
     #[test]
     fn test_empty() {
@@ -401,7 +401,7 @@ mod tests {
         assert!(index.find(0).is_none());
     }
 
-    #[test]
+    /*#[test]
     fn test_zero_slots() {
         #[rustfmt::skip]
         let section = Section::with_endian(Endian::Big)
@@ -414,9 +414,9 @@ mod tests {
         assert_eq!(index.unit_count(), 0);
         assert_eq!(index.slot_count(), 0);
         assert!(index.find(0).is_none());
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_version_2() {
         #[rustfmt::skip]
         let section = Section::with_endian(Endian::Big)
@@ -627,5 +627,5 @@ mod tests {
         let tu_index = DebugTuIndex::new(&buf, BigEndian);
         let index = tu_index.index().unwrap();
         assert_eq!(index.version, 5);
-    }
+    }*/
 }
Index: gimli/src/read/line.rs
===================================================================
--- gimli.orig/src/read/line.rs
+++ gimli/src/read/line.rs
@@ -1883,8 +1883,8 @@ mod tests {
     use crate::constants;
     use crate::endianity::LittleEndian;
     use crate::read::{EndianSlice, Error};
-    use crate::test_util::GimliSectionMethods;
-    use test_assembler::{Endian, Label, LabelMaker, Section};
+    //use crate::test_util::GimliSectionMethods;
+    //use test_assembler::{Endian, Label, LabelMaker, Section};
 
     #[test]
     fn test_parse_debug_line_32_ok() {
@@ -2984,7 +2984,7 @@ mod tests {
             },
         ];
 
-        for format in [Format::Dwarf32, Format::Dwarf64] {
+        /*for format in [Format::Dwarf32, Format::Dwarf64] {
             let length = Label::new();
             let header_length = Label::new();
             let start = Label::new();
@@ -3102,7 +3102,7 @@ mod tests {
             );
             assert_eq!(header.file_names(), expected_file_names);
             assert_eq!(header.file(0), Some(&expected_file_names[0]));
-        }
+        }*/
     }
 
     #[test]
Index: gimli/src/read/loclists.rs
===================================================================
--- gimli.orig/src/read/loclists.rs
+++ gimli/src/read/loclists.rs
@@ -697,11 +697,11 @@ mod tests {
     use crate::constants::*;
     use crate::endianity::LittleEndian;
     use crate::read::{EndianSlice, Range};
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     use alloc::vec::Vec;
-    use test_assembler::{Endian, Label, LabelMaker, Section};
+    //use test_assembler::{Endian, Label, LabelMaker, Section};
 
-    #[test]
+    /*#[test]
     fn test_loclists() {
         let format = Format::Dwarf32;
         for size in [4, 8] {
@@ -1079,7 +1079,7 @@ mod tests {
                 Ok(LocationListsOffset(base.0 + 1019))
             );
         }
-    }
+    }*/
 
     #[test]
     fn test_loclists_gnu_v4_split_dwarf() {
Index: gimli/src/read/mod.rs
===================================================================
--- gimli.orig/src/read/mod.rs
+++ gimli/src/read/mod.rs
@@ -705,9 +705,9 @@ mod tests {
     use super::*;
     use crate::common::Format;
     use crate::endianity::LittleEndian;
-    use test_assembler::{Endian, Section};
+    //use test_assembler::{Endian, Section};
 
-    #[test]
+    /*#[test]
     fn test_parse_initial_length_32_ok() {
         let section = Section::with_endian(Endian::Little).L32(0x7856_3412);
         let buf = section.get_contents().unwrap();
@@ -846,5 +846,5 @@ mod tests {
             Err(Error::UnsupportedOffset) => {}
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         };
-    }
+    }*/
 }
Index: gimli/src/read/op.rs
===================================================================
--- gimli.orig/src/read/op.rs
+++ gimli/src/read/op.rs
@@ -2024,8 +2024,8 @@ mod tests {
     use crate::endianity::LittleEndian;
     use crate::leb128;
     use crate::read::{EndianSlice, Error, Result, UnitOffset};
-    use crate::test_util::GimliSectionMethods;
-    use test_assembler::{Endian, Section};
+    //use crate::test_util::GimliSectionMethods;
+    //use test_assembler::{Endian, Section};
 
     fn encoding4() -> Encoding {
         Encoding {
@@ -2095,7 +2095,7 @@ mod tests {
         }
     }
 
-    fn check_op_parse<F>(
+    /*fn check_op_parse<F>(
         input: F,
         expect: &Operation<EndianSlice<'_, LittleEndian>>,
         encoding: Encoding,
@@ -2109,9 +2109,9 @@ mod tests {
             check_op_parse_eof(&input[..i], encoding);
         }
         check_op_parse_simple(&input, expect, encoding);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_op_parse_onebyte() {
         // Doesn't matter for this test.
         let encoding = encoding4();
@@ -2239,9 +2239,9 @@ mod tests {
             let (opcode, ref result) = *item;
             check_op_parse(|s| s.D8(opcode.0), result, encoding);
         }
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_op_parse_twobyte() {
         // Doesn't matter for this test.
         let encoding = encoding4();
@@ -2522,7 +2522,7 @@ mod tests {
                 ));
             }
 
-            for item in inputs.iter() {
+            /*for item in inputs.iter() {
                 let (op, ref expect) = *item;
                 let input = Section::with_endian(Endian::Little)
                     .D8(op.0)
@@ -2530,7 +2530,7 @@ mod tests {
                     .get_contents()
                     .unwrap();
                 check_op_parse_simple(&input, expect, encoding);
-            }
+            }*/
         }
     }
 
@@ -2567,7 +2567,7 @@ mod tests {
         }
     }
 
-    #[test]
+    /*#[test]
     fn test_op_parse_bit_piece() {
         // Doesn't matter for this test.
         let encoding = encoding4();
@@ -2592,7 +2592,7 @@ mod tests {
                 );
             }
         }
-    }
+    }*/
 
     #[test]
     fn test_op_parse_implicit_value() {
@@ -2706,9 +2706,9 @@ mod tests {
             },
             encoding,
         );
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_op_convert() {
         // Doesn't matter for this test.
         let encoding = encoding4();
@@ -2842,7 +2842,7 @@ mod tests {
             &Operation::WasmGlobal { index: 1000 },
             encoding,
         );
-    }
+    }*/
 
     enum AssemblerEntry {
         Op(constants::DwOp),
Index: gimli/src/read/rnglists.rs
===================================================================
--- gimli.orig/src/read/rnglists.rs
+++ gimli/src/read/rnglists.rs
@@ -660,11 +660,11 @@ mod tests {
     use crate::common::Format;
     use crate::constants::*;
     use crate::endianity::LittleEndian;
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     use alloc::vec::Vec;
-    use test_assembler::{Endian, Label, LabelMaker, Section};
+    //use crate::test_util::GimliSectionMethods;
 
-    #[test]
+    /*#[test]
     fn test_rnglists() {
         let format = Format::Dwarf32;
         for size in [4, 8] {
@@ -821,7 +821,7 @@ mod tests {
                 .unwrap();
             assert_eq!(ranges.next(), Ok(None));
         }
-    }
+    }*/
 
     #[test]
     fn test_raw_range() {
@@ -855,7 +855,7 @@ mod tests {
         assert!(range.is_base_address(8));
     }
 
-    #[test]
+    /*#[test]
     fn test_ranges() {
         for size in [4, 8] {
             let base = u64::ones_sized(size);
@@ -943,9 +943,9 @@ mod tests {
                 .unwrap();
             assert_eq!(ranges.next(), Ok(None));
         }
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_ranges_invalid() {
         #[rustfmt::skip]
         let section = Section::with_endian(Endian::Little)
@@ -1001,9 +1001,9 @@ mod tests {
             Err(Error::UnexpectedEof(_)) => {}
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         }
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_get_offset() {
         for format in [Format::Dwarf32, Format::Dwarf64] {
             let encoding = Encoding {
@@ -1046,5 +1046,5 @@ mod tests {
                 Ok(RangeListsOffset(base.0 + 1019))
             );
         }
-    }
+    }*/
 }
Index: gimli/src/read/str.rs
===================================================================
--- gimli.orig/src/read/str.rs
+++ gimli/src/read/str.rs
@@ -250,11 +250,11 @@ impl<R> From<R> for DebugLineStr<R> {
 #[cfg(all(test,feature = "read"))]
 mod tests {
     use super::*;
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     use crate::LittleEndian;
-    use test_assembler::{Endian, Label, LabelMaker, Section};
+    //use test_assembler::{Endian, Label, LabelMaker, Section};
 
-    #[test]
+    /*#[test]
     fn test_get_str_offset() {
         for format in [Format::Dwarf32, Format::Dwarf64] {
             let zero = Label::new();
@@ -287,5 +287,5 @@ mod tests {
                 Ok(DebugStrOffset(1019))
             );
         }
-    }
+    }*/
 }
Index: gimli/src/read/unit.rs
===================================================================
--- gimli.orig/src/read/unit.rs
+++ gimli/src/read/unit.rs
@@ -3198,14 +3198,14 @@ mod tests {
     use crate::read::{
         Abbreviation, AttributeSpecification, DebugAbbrev, EndianSlice, Error, Result,
     };
-    use crate::test_util::GimliSectionMethods;
+    //use crate::test_util::GimliSectionMethods;
     use alloc::vec::Vec;
     use core::cell::Cell;
-    use test_assembler::{Endian, Label, LabelMaker, Section};
+    //use test_assembler::{Endian, Label, LabelMaker, Section};
 
     // Mixin methods for `Section` to help define binary test data.
 
-    trait UnitSectionMethods {
+    /*trait UnitSectionMethods {
         fn unit<E>(self, unit: &mut UnitHeader<EndianSlice<'_, E>>) -> Self
         where
             E: Endianity;
@@ -3310,7 +3310,7 @@ mod tests {
                 Format::Dwarf64 => self.L64(offset as u64),
             }
         }
-    }
+    }*/
 
     /// Ensure that `UnitHeader<R>` is covariant wrt R.
     #[test]
@@ -3323,7 +3323,7 @@ mod tests {
         }
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_debug_abbrev_offset_32() {
         let section = Section::with_endian(Endian::Little).L32(0x0403_0201);
         let buf = section.get_contents().unwrap();
@@ -3333,7 +3333,7 @@ mod tests {
             Ok(val) => assert_eq!(val, DebugAbbrevOffset(0x0403_0201)),
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         };
-    }
+    }*/
 
     #[test]
     fn test_parse_debug_abbrev_offset_32_incomplete() {
@@ -3346,7 +3346,7 @@ mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     #[cfg(target_pointer_width = "64")]
     fn test_parse_debug_abbrev_offset_64() {
         let section = Section::with_endian(Endian::Little).L64(0x0807_0605_0403_0201);
@@ -3357,7 +3357,7 @@ mod tests {
             Ok(val) => assert_eq!(val, DebugAbbrevOffset(0x0807_0605_0403_0201)),
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         };
-    }
+    }*/
 
     #[test]
     fn test_parse_debug_abbrev_offset_64_incomplete() {
@@ -3370,7 +3370,7 @@ mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_debug_info_offset_32() {
         let section = Section::with_endian(Endian::Little).L32(0x0403_0201);
         let buf = section.get_contents().unwrap();
@@ -3380,7 +3380,7 @@ mod tests {
             Ok(val) => assert_eq!(val, DebugInfoOffset(0x0403_0201)),
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         };
-    }
+    }*/
 
     #[test]
     fn test_parse_debug_info_offset_32_incomplete() {
@@ -3393,7 +3393,7 @@ mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     #[cfg(target_pointer_width = "64")]
     fn test_parse_debug_info_offset_64() {
         let section = Section::with_endian(Endian::Little).L64(0x0807_0605_0403_0201);
@@ -3404,7 +3404,7 @@ mod tests {
             Ok(val) => assert_eq!(val, DebugInfoOffset(0x0807_0605_0403_0201)),
             otherwise => panic!("Unexpected result: {:?}", otherwise),
         };
-    }
+    }*/
 
     #[test]
     fn test_parse_debug_info_offset_64_incomplete() {
@@ -3417,7 +3417,7 @@ mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     #[cfg(target_pointer_width = "64")]
     fn test_units() {
         let expected_rest = &[1, 2, 3, 4, 5, 6, 7, 8, 9];
@@ -3456,7 +3456,7 @@ mod tests {
         assert_eq!(units.next(), Ok(Some(unit64)));
         assert_eq!(units.next(), Ok(Some(unit32)));
         assert_eq!(units.next(), Ok(None));
-    }
+    }*/
 
     #[test]
     fn test_unit_version_unknown_version() {
@@ -3488,7 +3488,7 @@ mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_unit_header_32_ok() {
         let expected_rest = &[1, 2, 3, 4, 5, 6, 7, 8, 9];
         let encoding = Encoding {
@@ -3515,9 +3515,9 @@ mod tests {
             Ok(expected_unit)
         );
         assert_eq!(*rest, EndianSlice::new(expected_rest, LittleEndian));
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     #[cfg(target_pointer_width = "64")]
     fn test_parse_unit_header_64_ok() {
         let expected_rest = &[1, 2, 3, 4, 5, 6, 7, 8, 9];
@@ -3781,7 +3781,7 @@ mod tests {
             Ok(expected_unit)
         );
         assert_eq!(*rest, EndianSlice::new(expected_rest, LittleEndian));
-    }
+    }*/
 
     #[test]
     fn test_parse_type_offset_32_ok() {
@@ -3824,7 +3824,7 @@ mod tests {
         };
     }
 
-    #[test]
+    /*#[test]
     fn test_parse_type_unit_header_32_ok() {
         let expected_rest = &[1, 2, 3, 4, 5, 6, 7, 8, 9];
         let encoding = Encoding {
@@ -4184,7 +4184,7 @@ mod tests {
             assert_eq!(attribute.raw_value(), expect_raw);
             assert_eq!(attribute.value(), expect_value);
         }
-    }
+    }*/
 
     #[test]
     fn test_attribute_udata_sdata_value() {
@@ -5137,7 +5137,7 @@ mod tests {
         }
     }
 
-    fn entries_cursor_tests_abbrev_buf() -> Vec<u8> {
+    /*fn entries_cursor_tests_abbrev_buf() -> Vec<u8> {
         #[rustfmt::skip]
         let section = Section::with_endian(Endian::Little)
             .abbrev(1, DW_TAG_subprogram, DW_CHILDREN_yes)
@@ -5245,9 +5245,9 @@ mod tests {
 
         assert!(cursor.next_entry().is_err());
         assert!(cursor.next_entry().is_err());
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_cursor_next_entry() {
         let info_buf = &entries_cursor_tests_debug_info_buf();
         let debug_info = DebugInfo::new(info_buf, LittleEndian);
@@ -5431,9 +5431,9 @@ mod tests {
             .expect("Should parse next sibling")
             .is_none());
         assert!(cursor.current().is_none());
-    }
+    }*/
 
-    fn entries_cursor_sibling_abbrev_buf() -> Vec<u8> {
+    /*fn entries_cursor_sibling_abbrev_buf() -> Vec<u8> {
         #[rustfmt::skip]
         let section = Section::with_endian(Endian::Little)
             .abbrev(1, DW_TAG_subprogram, DW_CHILDREN_yes)
@@ -5496,7 +5496,7 @@ mod tests {
         sibling009_ref.set_const(offset);
 
         section.get_contents().unwrap()
-    }
+    }*/
 
     fn test_cursor_next_sibling_with_ptr(
         cursor: &mut EntriesCursor<'_, '_, EndianSlice<'_, LittleEndian>>,
@@ -5523,7 +5523,7 @@ mod tests {
         assert!(cursor.current().is_none());
     }
 
-    #[test]
+    /*#[test]
     fn test_debug_info_next_sibling_with_ptr() {
         let encoding = Encoding {
             format: Format::Dwarf32,
@@ -5561,9 +5561,9 @@ mod tests {
 
         let mut cursor = unit.entries(&abbrevs);
         test_cursor_next_sibling_with_ptr(&mut cursor);
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_debug_types_next_sibling_with_ptr() {
         let encoding = Encoding {
             format: Format::Dwarf32,
@@ -5687,9 +5687,9 @@ mod tests {
             .unwrap();
         let entry2 = UnitOffset(header_size + (&entry2 - &start) as usize);
         (section, entry2)
-    }
+    }*/
 
-    #[test]
+    /*#[test]
     fn test_entries_tree() {
         fn assert_entry<'input, 'abbrev, 'unit, 'tree, Endian>(
             node: Result<
@@ -6055,7 +6055,7 @@ mod tests {
             UnitOffset(length - 1).to_debug_types_offset(&unit),
             Some(DebugTypesOffset(offset + length - 1))
         );
-    }
+    }*/
 
     #[test]
     fn test_length_including_self() {
Index: gimli/src/test_util.rs
===================================================================
--- gimli.orig/src/test_util.rs
+++ gimli/src/test_util.rs
@@ -1,9 +1,9 @@
 #![allow(missing_docs)]
 
 use crate::Format;
-use test_assembler::{Label, Section};
+//use test_assembler::{Label, Section};
 
-pub trait GimliSectionMethods {
+/*pub trait GimliSectionMethods {
     fn sleb(self, val: i64) -> Self;
     fn uleb(self, val: u64) -> Self;
     fn initial_length(self, format: Format, length: &Label, start: &Label) -> Self;
@@ -50,4 +50,4 @@ impl GimliSectionMethods for Section {
             _ => panic!("unsupported word size"),
         }
     }
-}
+}*/
