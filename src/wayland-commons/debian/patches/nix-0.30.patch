--- rust-wayland-commons-0.29.5.orig/Cargo.toml
+++ rust-wayland-commons-0.29.5/Cargo.toml
@@ -25,6 +25,9 @@ categories = [
 license = "MIT"
 repository = "https://github.com/smithay/wayland-rs"
 
+[dependencies]
+libc = "0.2.175"
+
 [dependencies.nix]
 version = ">=0.24.1, < 1"
 features = [
--- rust-wayland-commons-0.29.5.orig/src/socket.rs
+++ rust-wayland-commons-0.29.5/src/socket.rs
@@ -4,6 +4,7 @@ use std::io::{IoSlice, IoSliceMut};
 use std::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};
 
 use nix::{sys::socket, Result as NixResult};
+use nix::errno::Errno;
 
 use crate::wire::{ArgumentType, Message, MessageParseError, MessageWriteError};
 
@@ -488,8 +489,10 @@ mod tests {
     use smallvec::smallvec;
 
     fn same_file(a: RawFd, b: RawFd) -> bool {
-        let stat1 = ::nix::sys::stat::fstat(a).unwrap();
-        let stat2 = ::nix::sys::stat::fstat(b).unwrap();
+        let mut stat1 = unsafe { core::mem::zeroed() };
+        let mut stat2 = unsafe { core::mem::zeroed() };
+        Errno::result(unsafe { ::libc::fstat(a,&mut stat1) }).unwrap();
+        Errno::result(unsafe { ::libc::fstat(b,&mut stat2) }).unwrap();
         stat1.st_dev == stat2.st_dev && stat1.st_ino == stat2.st_ino
     }
 
--- rust-wayland-commons-0.29.5.orig/src/wire.rs
+++ rust-wayland-commons-0.29.5/src/wire.rs
@@ -5,6 +5,7 @@ use std::os::unix::io::RawFd;
 use std::ptr;
 
 use nix::{Error as NixError, Result as NixResult};
+use nix::errno::Errno;
 
 use smallvec::SmallVec;
 
@@ -357,18 +358,19 @@ impl Message {
 
 /// Duplicate a `RawFd` and set the CLOEXEC flag on the copy
 pub fn dup_fd_cloexec(fd: RawFd) -> NixResult<RawFd> {
+  unsafe {
     use nix::fcntl;
-    match fcntl::fcntl(fd, fcntl::FcntlArg::F_DUPFD_CLOEXEC(0)) {
+    match Errno::result(libc::fcntl(fd, libc::F_DUPFD_CLOEXEC,0 as RawFd)) {
         Ok(newfd) => Ok(newfd),
         Err(NixError::EINVAL) => {
             // F_DUPFD_CLOEXEC is not recognized, kernel too old, fallback
             // to setting CLOEXEC manually
-            let newfd = fcntl::fcntl(fd, fcntl::FcntlArg::F_DUPFD(0))?;
+            let newfd = Errno::result(libc::fcntl(fd, libc::F_DUPFD,0 as RawFd))?;
 
-            let flags = fcntl::fcntl(newfd, fcntl::FcntlArg::F_GETFD);
+            let flags = Errno::result(libc::fcntl(newfd, libc::F_GETFD));
             let result = flags
                 .map(|f| fcntl::FdFlag::from_bits(f).unwrap() | fcntl::FdFlag::FD_CLOEXEC)
-                .and_then(|f| fcntl::fcntl(newfd, fcntl::FcntlArg::F_SETFD(f)));
+                .and_then(|f| Errno::result(libc::fcntl(newfd, libc::F_SETFD,f.bits())));
             match result {
                 Ok(_) => {
                     // setting the O_CLOEXEC worked
@@ -383,6 +385,7 @@ pub fn dup_fd_cloexec(fd: RawFd) -> NixR
         }
         Err(e) => Err(e),
     }
+  }
 }
 
 /*
