This patch is based on the upstream commit described below, adapted for use in
the debian package by Peter Michael Green

commit 291908ac22a4c05f9fcad31cb460c502723b22ae
Author: Paul Grandperrin <paul.grandperrin@gmail.com>
Date:   Mon Dec 21 23:42:11 2020 -0300

    Update rand to 0.8, rand_chacha to 0.3 and rand_xorshift to 0.3
    
    and fix broken code from api change

diff --git proptest/src/char.rs proptest/src/char.rs
index c957ec71c..043394a3b 100644
--- proptest/src/char.rs
+++ proptest/src/char.rs
@@ -114,16 +114,16 @@ fn select_range_index(
     }
 
     if !special.is_empty() && rnd.gen() {
-        let s = special[rnd.gen_range(0, special.len())];
+        let s = special[rnd.gen_range(0..special.len())];
         if let Some(ret) = in_range(ranges, s) {
             return ret;
         }
     }
 
     if !preferred.is_empty() && rnd.gen() {
-        let range = preferred[rnd.gen_range(0, preferred.len())].clone();
+        let range = preferred[rnd.gen_range(0..preferred.len())].clone();
         if let Some(ch) = ::core::char::from_u32(
-            rnd.gen_range(*range.start() as u32, *range.end() as u32 + 1),
+            rnd.gen_range(*range.start() as u32 .. *range.end() as u32 + 1),
         ) {
             if let Some(ret) = in_range(ranges, ch) {
                 return ret;
@@ -132,9 +132,9 @@ fn select_range_index(
     }
 
     for _ in 0..65_536 {
-        let range = ranges[rnd.gen_range(0, ranges.len())].clone();
+        let range = ranges[rnd.gen_range(0..ranges.len())].clone();
         if let Some(ch) = ::core::char::from_u32(
-            rnd.gen_range(*range.start() as u32, *range.end() as u32 + 1),
+            rnd.gen_range(*range.start() as u32 .. *range.end() as u32 + 1),
         ) {
             return (*range.start() as u32, ch as u32 - *range.start() as u32);
         }
diff --git proptest/src/strategy/shuffle.rs proptest/src/strategy/shuffle.rs
index 274dabb38..d772a481b 100644
--- proptest/src/strategy/shuffle.rs
+++ proptest/src/strategy/shuffle.rs
@@ -170,7 +170,7 @@ where
             // Determine the other index to be swapped, then skip the swap if
             // it is too far. This ordering is critical, as it ensures that we
             // generate the same sequence of random numbers every time.
-            let end_index = rng.gen_range(start_index + 1, len);
+            let end_index = rng.gen_range(start_index + 1 .. len);
             if end_index - start_index <= max_swap {
                 value.shuffle_swap(start_index, end_index);
             }
