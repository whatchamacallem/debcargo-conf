From 98ad0f42db9039b508e4fbbb612d4ac5d3f020f4 Mon Sep 17 00:00:00 2001
From: Josh Stone <cuviper@gmail.com>
Date: Mon, 10 Sep 2018 16:27:21 -0700
Subject: [PATCH] Port to crossbeam-deque 0.6

---
 Cargo.toml                 |  2 +-
 rayon-core/Cargo.toml      |  4 +---
 rayon-core/src/registry.rs | 47 +++++++++++++++-----------------------
 src/iter/par_bridge.rs     | 19 ++++++++-------
 4 files changed, 31 insertions(+), 41 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index 14230aa2..97b0ba53 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -47,3 +47,3 @@ path = "tests/simple_panic.rs"
 [dependencies.crossbeam-deque]
-version = "0.2.0"
+version = "0.6.0"

diff --git a/src/registry.rs b/src/registry.rs
index 0fb8e203..16f3f01e 100644
--- a/src/registry.rs
+++ b/src/registry.rs
@@ -1,5 +1,5 @@
 use ::{ExitHandler, PanicHandler, StartHandler, ThreadPoolBuilder, ThreadPoolBuildError, ErrorKind};
-use crossbeam_deque::{Deque, Steal, Stealer};
+use crossbeam_deque::{self as deque, Worker, Pop, Steal, Stealer};
 use job::{JobRef, StackJob};
 #[cfg(rayon_unstable)]
 use job::Job;
@@ -46,7 +46,7 @@ pub struct Registry {
 }
 
 struct RegistryState {
-    job_injector: Deque<JobRef>,
+    job_injector: Worker<JobRef>,
 }
 
 /// ////////////////////////////////////////////////////////////////////////
@@ -100,12 +100,10 @@ impl Registry {
         let n_threads = builder.get_num_threads();
         let breadth_first = builder.get_breadth_first();
 
-        let inj_worker = Deque::new();
-        let inj_stealer = inj_worker.stealer();
-        let workers: Vec<_> = (0..n_threads)
-            .map(|_| Deque::new())
-            .collect();
-        let stealers: Vec<_> = workers.iter().map(|d| d.stealer()).collect();
+        let (inj_worker, inj_stealer) = deque::fifo();
+        let (workers, stealers): (Vec<_>, Vec<_>) = (0..n_threads)
+            .map(|_| if breadth_first { deque::fifo() } else { deque::lifo() })
+            .unzip();
 
         let registry = Arc::new(Registry {
             thread_infos: stealers.into_iter()
@@ -132,7 +130,7 @@ impl Registry {
             if let Some(stack_size) = builder.get_stack_size() {
                 b = b.stack_size(stack_size);
             }
-            if let Err(e) = b.spawn(move || unsafe { main_loop(worker, registry, index, breadth_first) }) {
+            if let Err(e) = b.spawn(move || unsafe { main_loop(worker, registry, index) }) {
                 return Err(ThreadPoolBuildError::new(ErrorKind::IOError(e)))
             }
         }
@@ -417,7 +415,7 @@ pub struct RegistryId {
 }
 
 impl RegistryState {
-    pub fn new(job_injector: Deque<JobRef>) -> RegistryState {
+    pub fn new(job_injector: Worker<JobRef>) -> RegistryState {
         RegistryState {
             job_injector: job_injector,
         }
@@ -453,13 +451,10 @@ impl ThreadInfo {
 
 pub struct WorkerThread {
     /// the "worker" half of our local deque
-    worker: Deque<JobRef>,
+    worker: Worker<JobRef>,
 
     index: usize,
 
-    /// are these workers configured to steal breadth-first or not?
-    breadth_first: bool,
-
     /// A weak random number generator.
     rng: XorShift64Star,
 
@@ -513,7 +508,7 @@ impl WorkerThread {
 
     #[inline]
     pub fn local_deque_is_empty(&self) -> bool {
-        self.worker.len() == 0
+        self.worker.is_empty()
     }
 
     /// Attempts to obtain a "local" job -- typically this means
@@ -522,15 +517,11 @@ impl WorkerThread {
     /// bottom.
     #[inline]
     pub unsafe fn take_local_job(&self) -> Option<JobRef> {
-        if !self.breadth_first {
-            self.worker.pop()
-        } else {
-            loop {
-                match self.worker.steal() {
-                    Steal::Empty => return None,
-                    Steal::Data(d) => return Some(d),
-                    Steal::Retry => {},
-                }
+        loop {
+            match self.worker.pop() {
+                Pop::Empty => return None,
+                Pop::Data(d) => return Some(d),
+                Pop::Retry => {},
             }
         }
     }
@@ -596,7 +587,7 @@ impl WorkerThread {
     /// local work to do.
     unsafe fn steal(&self) -> Option<JobRef> {
         // we only steal when we don't have any work to do locally
-        debug_assert!(self.worker.pop().is_none());
+        debug_assert!(self.local_deque_is_empty());
 
         // otherwise, try to steal
         let num_threads = self.registry.thread_infos.len();
@@ -630,13 +621,11 @@ impl WorkerThread {
 
 /// ////////////////////////////////////////////////////////////////////////
 
-unsafe fn main_loop(worker: Deque<JobRef>,
+unsafe fn main_loop(worker: Worker<JobRef>,
                     registry: Arc<Registry>,
-                    index: usize,
-                    breadth_first: bool) {
+                    index: usize) {
     let worker_thread = WorkerThread {
         worker: worker,
-        breadth_first: breadth_first,
         index: index,
         rng: XorShift64Star::new(),
         registry: registry.clone(),
