Index: grcov/src/defs.rs
===================================================================
--- grcov.orig/src/defs.rs
+++ grcov/src/defs.rs
@@ -1,4 +1,4 @@
-use crossbeam::sync::MsQueue;
+use crossbeam::channel::{Receiver, Sender};
 use std::collections::{BTreeMap, HashMap};
 use std::path::PathBuf;
 use std::sync::Mutex;
@@ -45,7 +45,8 @@ pub struct WorkItem {
     pub name: String,
 }
 
-pub type WorkQueue = MsQueue<Option<WorkItem>>;
+pub type JobReceiver = Receiver<Option<WorkItem>>;
+pub type JobSender = Sender<Option<WorkItem>>;
 
 pub type CovResultMap = HashMap<String, CovResult>;
 pub type SyncCovResultMap = Mutex<CovResultMap>;
Index: grcov/src/lib.rs
===================================================================
--- grcov.orig/src/lib.rs
+++ grcov/src/lib.rs
@@ -135,12 +135,16 @@ pub fn consumer(
     working_dir: &PathBuf,
     source_dir: &Option<PathBuf>,
     result_map: &SyncCovResultMap,
-    queue: &WorkQueue,
+    receiver: JobReceiver,
     branch_enabled: bool,
 ) {
     let mut gcov_type = GcovType::Unknown;
 
-    while let Some(work_item) = queue.pop() {
+    while let Ok(work_item) = receiver.recv() {
+        if work_item.is_none() {
+            break;
+        }
+        let work_item = work_item.unwrap();
         let new_results = match work_item.format {
             ItemFormat::GCNO => {
                 match work_item.item {
Index: grcov/src/main.rs
===================================================================
--- grcov.orig/src/main.rs
+++ grcov/src/main.rs
@@ -4,7 +4,7 @@ extern crate num_cpus;
 extern crate serde_json;
 extern crate tempfile;
 
-use crossbeam::sync::MsQueue;
+use crossbeam::crossbeam_channel::unbounded;
 use serde_json::Value;
 use std::alloc::System;
 use std::collections::HashMap;
@@ -245,11 +245,11 @@ fn main() {
     assert!(tmp_path.exists());
 
     let result_map: Arc<SyncCovResultMap> = Arc::new(Mutex::new(HashMap::with_capacity(20_000)));
-    let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+    let (sender, receiver) = unbounded();
     let path_mapping: Arc<Mutex<Option<Value>>> = Arc::new(Mutex::new(None));
 
     let producer = {
-        let queue = Arc::clone(&queue);
+        let sender: JobSender = sender.clone();
         let tmp_path = tmp_path.clone();
         let path_mapping_file = path_mapping_file.to_owned();
         let path_mapping = Arc::clone(&path_mapping);
@@ -258,7 +258,7 @@ fn main() {
             let producer_path_mapping_buf = producer(
                 &tmp_path,
                 &paths,
-                &queue,
+                &sender,
                 filter_option.is_some() && filter_option.unwrap(),
                 is_llvm,
             );
@@ -278,7 +278,7 @@ fn main() {
     let mut parsers = Vec::new();
 
     for i in 0..num_threads {
-        let queue = Arc::clone(&queue);
+        let receiver = receiver.clone();
         let result_map = Arc::clone(&result_map);
         let working_dir = tmp_path.join(format!("{}", i));
         let source_root = source_root.clone();
@@ -289,7 +289,7 @@ fn main() {
                 &working_dir,
                 &source_root,
                 &result_map,
-                &queue,
+                receiver,
                 branch_enabled,
             );
         }).unwrap();
@@ -302,9 +302,9 @@ fn main() {
         process::exit(1);
     }
 
-    // Poison the queue, now that the producer is finished.
+    // Poison the receiver, now that the producer is finished.
     for _ in 0..num_threads {
-        queue.push(None);
+        sender.send(None).unwrap();
     }
 
     for parser in parsers {
Index: grcov/src/producer.rs
===================================================================
--- grcov.orig/src/producer.rs
+++ grcov/src/producer.rs
@@ -295,15 +295,15 @@ fn gcno_gcda_producer(
     tmp_dir: &Path,
     gcno_stem_archives: &HashMap<GCNOStem, &Archive>,
     gcda_stem_archives: &HashMap<String, Vec<&Archive>>,
-    queue: &WorkQueue,
+    sender: &JobSender,
     ignore_orphan_gcno: bool,
 ) {
-    let push_to_queue = |item, name| {
-        queue.push(Some(WorkItem {
+    let send_job = |item, name| {
+        sender.send(Some(WorkItem {
             format: ItemFormat::GCNO,
             item: item,
             name: name,
-        }))
+        })).unwrap()
     };
 
     for (gcno_stem, gcno_archive) in gcno_stem_archives {
@@ -324,7 +324,7 @@ fn gcno_gcda_producer(
                             gcda_buffers.push(gcda_buf);
                         }
                     }
-                    push_to_queue(
+                    send_job(
                         ItemType::Buffers(GcnoBuffers {
                             stem: stem.clone(),
                             gcno_buf: gcno_buffer,
@@ -349,7 +349,7 @@ fn gcno_gcda_producer(
                         if gcda_archive.extract(&gcda, &gcda_path)
                             || (num == 0 && !ignore_orphan_gcno)
                         {
-                            push_to_queue(
+                            send_job(
                                 ItemType::Path(gcno_path),
                                 gcda_archive.get_name().to_string(),
                             );
@@ -365,7 +365,7 @@ fn gcno_gcda_producer(
                         let mut buffer: Vec<u8> = Vec::new();
                         gcno_archive.read_in_buffer(&gcno, &mut buffer);
 
-                        push_to_queue(
+                        send_job(
                             ItemType::Buffers(GcnoBuffers {
                                 stem: stem.clone(),
                                 gcno_buf: buffer,
@@ -376,7 +376,7 @@ fn gcno_gcda_producer(
                     } else {
                         let physical_gcno_path = tmp_dir.join(format!("{}_{}.gcno", stem, 1));
                         if gcno_archive.extract(&gcno, &physical_gcno_path) {
-                            push_to_queue(
+                            send_job(
                                 ItemType::Path(physical_gcno_path),
                                 gcno_archive.get_name().to_string(),
                             );
@@ -390,18 +390,18 @@ fn gcno_gcda_producer(
 
 fn file_content_producer(
     files: &HashMap<String, Vec<&Archive>>,
-    queue: &WorkQueue,
+    sender: &JobSender,
     item_format: ItemFormat,
 ) {
     for (name, archives) in files {
         for archive in archives {
             let mut buffer = Vec::new();
             archive.read_in_buffer(name, &mut buffer);
-            queue.push(Some(WorkItem {
+            sender.send(Some(WorkItem {
                 format: item_format,
                 item: ItemType::Content(buffer),
                 name: archive.get_name().to_string(),
-            }));
+            })).unwrap();
         }
     }
 }
@@ -426,7 +426,7 @@ fn open_archive(path: &str) -> ZipArchiv
 pub fn producer(
     tmp_dir: &Path,
     paths: &[String],
-    queue: &WorkQueue,
+    sender: &JobSender,
     ignore_orphan_gcno: bool,
     is_llvm: bool,
 ) -> Option<Vec<u8>> {
@@ -498,13 +498,13 @@ pub fn producer(
         "No input files found"
     );
 
-    file_content_producer(&infos.into_inner(), queue, ItemFormat::INFO);
-    file_content_producer(&xmls.into_inner(), queue, ItemFormat::JACOCO_XML);
+    file_content_producer(&infos.into_inner(), sender, ItemFormat::INFO);
+    file_content_producer(&xmls.into_inner(), sender, ItemFormat::JACOCO_XML);
     gcno_gcda_producer(
         tmp_dir,
         &gcno_stems_archives.into_inner(),
         &gcda_stems_archives.into_inner(),
-        queue,
+        sender,
         ignore_orphan_gcno,
     );
 
@@ -514,23 +514,18 @@ pub fn producer(
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crossbeam::queue::MsQueue;
+    use crossbeam::crossbeam_channel::unbounded;
     use serde_json::{self, Value};
-    use std::sync::Arc;
 
     fn check_produced(
         directory: PathBuf,
-        queue: &WorkQueue,
+        receiver: &JobReceiver,
         expected: Vec<(ItemFormat, bool, &str, bool)>,
     ) {
         let mut vec: Vec<Option<WorkItem>> = Vec::new();
 
-        loop {
-            let elem = queue.try_pop();
-            if elem.is_none() {
-                break;
-            }
-            vec.push(elem.unwrap());
+        while let Ok(elem) = receiver.try_recv() {
+            vec.push(elem);
         }
 
         for elem in &expected {
@@ -601,11 +596,11 @@ mod tests {
 
     #[test]
     fn test_dir_producer() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
-        let mapping = producer(&tmp_path, &["test".to_string()], &queue, false, false);
+        let mapping = producer(&tmp_path, &["test".to_string()], &sender, false, false);
 
         let expected = vec![
             (ItemFormat::GCNO, true, "Platform_1.gcno", true),
@@ -694,7 +689,7 @@ mod tests {
             ),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_some());
         let mapping: Value = serde_json::from_slice(&mapping.unwrap()).unwrap();
         assert_eq!(
@@ -709,14 +704,14 @@ mod tests {
 
     #[test]
     fn test_dir_producer_multiple_directories() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         let mapping = producer(
             &tmp_path,
             &["test/sub".to_string(), "test/sub2".to_string()],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -726,40 +721,40 @@ mod tests {
             (ItemFormat::GCNO, true, "prova2_1.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
     #[test]
     fn test_dir_producer_directory_with_gcno_symlinks() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         let mapping = producer(
             &tmp_path,
             &["test/gcno_symlink/gcda".to_string()],
-            &queue,
+            &sender,
             false,
             false,
         );
 
         let expected = vec![(ItemFormat::GCNO, true, "main_1.gcno", true)];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
     #[test]
     fn test_dir_producer_directory_with_no_gcda() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         let mapping = producer(
             &tmp_path,
             &["test/only_one_gcda".to_string()],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -769,33 +764,33 @@ mod tests {
             (ItemFormat::GCNO, true, "orphan_1.gcno", false),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
     #[test]
     fn test_dir_producer_directory_with_no_gcda_ignore_orphan_gcno() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         let mapping = producer(
             &tmp_path,
             &["test/only_one_gcda".to_string()],
-            &queue,
+            &sender,
             true,
             false,
         );
 
         let expected = vec![(ItemFormat::GCNO, true, "main_1.gcno", true)];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
     #[test]
     fn test_zip_producer_with_gcda_dir() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -805,7 +800,7 @@ mod tests {
                 "test/zip_dir/gcno.zip".to_string(),
                 "test/zip_dir".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -829,7 +824,7 @@ mod tests {
             (ItemFormat::GCNO, true, "nsGnomeModule_1.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_some());
         let mapping: Value = serde_json::from_slice(&mapping.unwrap()).unwrap();
         assert_eq!(
@@ -845,7 +840,7 @@ mod tests {
     // Test extracting multiple gcda archives.
     #[test]
     fn test_zip_producer_multiple_gcda_archives() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -856,7 +851,7 @@ mod tests {
                 "test/gcda1.zip".to_string(),
                 "test/gcda2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -889,7 +884,7 @@ mod tests {
             (ItemFormat::GCNO, true, "sub/prova2_2.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_some());
         let mapping: Value = serde_json::from_slice(&mapping.unwrap()).unwrap();
         assert_eq!(
@@ -905,7 +900,7 @@ mod tests {
     // Test extracting gcno with no path mapping.
     #[test]
     fn test_zip_producer_gcno_with_no_path_mapping() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -915,7 +910,7 @@ mod tests {
                 "test/gcno_no_path_mapping.zip".to_string(),
                 "test/gcda1.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -939,14 +934,14 @@ mod tests {
             (ItemFormat::GCNO, true, "nsGnomeModule_1.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
     // Test calling zip_producer with a different order of zip files.
     #[test]
     fn test_zip_producer_different_order_of_zip_files() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -957,7 +952,7 @@ mod tests {
                 "test/gcno.zip".to_string(),
                 "test/gcda2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -990,20 +985,20 @@ mod tests {
             (ItemFormat::GCNO, true, "sub/prova2_2.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting info files.
     #[test]
     fn test_zip_producer_info_files() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         producer(
             &tmp_path,
             &["test/info1.zip".to_string(), "test/info2.zip".to_string()],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1023,13 +1018,13 @@ mod tests {
             (ItemFormat::INFO, false, "1494603973-2977-7_1.info", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting jacoco report XML files.
     #[test]
     fn test_zip_producer_jacoco_xml_files() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1039,7 +1034,7 @@ mod tests {
                 "test/jacoco1.zip".to_string(),
                 "test/jacoco2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1054,13 +1049,13 @@ mod tests {
             (ItemFormat::JACOCO_XML, false, "inner-classes.xml", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting both jacoco xml and info files.
     #[test]
     fn test_zip_producer_both_info_and_jacoco_xml() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1072,7 +1067,7 @@ mod tests {
                 "test/info1.zip".to_string(),
                 "test/info2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1099,13 +1094,13 @@ mod tests {
             (ItemFormat::INFO, false, "1494603973-2977-7_1.info", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting both info and gcno/gcda files.
     #[test]
     fn test_zip_producer_both_info_and_gcnogcda_files() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1117,7 +1112,7 @@ mod tests {
                 "test/info1.zip".to_string(),
                 "test/info2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1153,13 +1148,13 @@ mod tests {
             (ItemFormat::INFO, false, "1494603973-2977-7_1.info", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting gcno with no associated gcda.
     #[test]
     fn test_zip_producer_gcno_with_no_associated_gcda() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1169,21 +1164,21 @@ mod tests {
                 "test/no_gcda/main.gcno.zip".to_string(),
                 "test/no_gcda/empty.gcda.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
 
         let expected = vec![(ItemFormat::GCNO, true, "main_1.gcno", false)];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
     // Test extracting gcno with an associated gcda file in only one zip file.
     #[test]
     fn test_zip_producer_gcno_with_associated_gcda_in_only_one_archive() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1194,14 +1189,14 @@ mod tests {
                 "test/no_gcda/empty.gcda.zip".to_string(),
                 "test/no_gcda/main.gcda.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
 
         let expected = vec![(ItemFormat::GCNO, true, "main_1.gcno", true)];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
         assert!(mapping.is_none());
     }
 
@@ -1209,14 +1204,14 @@ mod tests {
     #[test]
     #[should_panic]
     fn test_zip_producer_with_gcda_archive_and_no_gcno_archive() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, _) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         producer(
             &tmp_path,
             &["test/no_gcda/main.gcda.zip".to_string()],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1225,14 +1220,14 @@ mod tests {
     // Test extracting gcno/gcda archives, where a gcno file exist with no matching gcda file.
     #[test]
     fn test_zip_producer_no_matching_gcno() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         producer(
             &tmp_path,
             &["test/gcno.zip".to_string(), "test/gcda2.zip".to_string()],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1256,14 +1251,14 @@ mod tests {
             (ItemFormat::GCNO, true, "nsGnomeModule_1.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting gcno/gcda archives, where a gcno file exist with no matching gcda file.
     // The gcno file should be produced only once, not twice.
     #[test]
     fn test_zip_producer_no_matching_gcno_two_gcda_archives() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1274,7 +1269,7 @@ mod tests {
                 "test/gcda2.zip".to_string(),
                 "test/gcda2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             false,
             false,
         );
@@ -1307,20 +1302,20 @@ mod tests {
             (ItemFormat::GCNO, true, "nsGnomeModule_2.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting gcno/gcda archives, where a gcno file exist with no matching gcda file and ignore orphan gcno files.
     #[test]
     fn test_zip_producer_no_matching_gcno_ignore_orphan_gcno() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
         producer(
             &tmp_path,
             &["test/gcno.zip".to_string(), "test/gcda2.zip".to_string()],
-            &queue,
+            &sender,
             true,
             false,
         );
@@ -1337,13 +1332,13 @@ mod tests {
             (ItemFormat::GCNO, true, "nsGnomeModule_1.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     // Test extracting gcno/gcda archives, where a gcno file exist with no matching gcda file and ignore orphan gcno files.
     #[test]
     fn test_zip_producer_no_matching_gcno_two_gcda_archives_ignore_orphan_gcno() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1354,7 +1349,7 @@ mod tests {
                 "test/gcda2.zip".to_string(),
                 "test/gcda2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             true,
             false,
         );
@@ -1380,12 +1375,12 @@ mod tests {
             (ItemFormat::GCNO, true, "nsGnomeModule_2.gcno", true),
         ];
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     #[test]
     fn test_zip_producer_llvm_buffers() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1396,7 +1391,7 @@ mod tests {
                 "test/llvm/gcda1.zip".to_string(),
                 "test/llvm/gcda2.zip".to_string(),
             ],
-            &queue,
+            &sender,
             true,
             true,
         );
@@ -1425,12 +1420,8 @@ mod tests {
             0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         ];
 
-        loop {
-            let elem = queue.try_pop();
-            if elem.is_none() {
-                break;
-            }
-            let elem = elem.unwrap().unwrap();
+        while let Ok(elem) = receiver.try_recv() {
+            let elem = elem.unwrap();
             if let ItemType::Buffers(buffers) = elem.item {
                 let stem = PathBuf::from(buffers.stem);
                 let stem = stem.file_stem().expect("Unable to get file_stem");
@@ -1448,7 +1439,7 @@ mod tests {
 
     #[test]
     fn test_plain_producer() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, receiver) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1459,7 +1450,7 @@ mod tests {
                 "test/prova.info".to_string(),
                 json_path.to_string(),
             ],
-            &queue,
+            &sender,
             true,
             false,
         );
@@ -1482,13 +1473,13 @@ mod tests {
             },
         }
 
-        check_produced(tmp_path, &queue, expected);
+        check_produced(tmp_path, &receiver, expected);
     }
 
     #[test]
     #[should_panic]
     fn test_plain_producer_with_gcno() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, _) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
@@ -1497,7 +1488,7 @@ mod tests {
             &[
                 "sub2/RootAccessibleWrap_1.gcno".to_string(),
             ],
-            &queue,
+            &sender,
             true,
             false,
         );
@@ -1506,7 +1497,7 @@ mod tests {
     #[test]
     #[should_panic]
     fn test_plain_producer_with_gcda() {
-        let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());
+        let (sender, _) = unbounded();
 
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let tmp_path = tmp_dir.path().to_owned();
